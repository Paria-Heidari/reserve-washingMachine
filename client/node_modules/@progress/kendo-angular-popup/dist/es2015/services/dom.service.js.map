{"version":3,"file":"dom.service.js","sources":["/Users/paria/workspace/washIt/client/node_modules/@progress/kendo-angular-popup/dist/es2015/services/dom.service.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as tslib_1 from \"tslib\";\nimport { Injectable } from '@angular/core';\nimport { align, boundingOffset, getWindowViewPort, offset, positionWithScroll, restrictToView, addScroll, removeScroll, scrollPosition } from '@progress/kendo-popup-common';\nimport { isWindowAvailable, hasRelativeStackingContext, scrollableParents, zIndex } from '../util';\nimport { isDocumentAvailable } from '@progress/kendo-angular-common';\nconst STYLES = [\n    'font-size',\n    'font-family',\n    'font-stretch',\n    'font-style',\n    'font-weight',\n    'line-height'\n];\n/**\n * @hidden\n */\nlet DOMService = class DOMService {\n    addOffset(current, addition) {\n        return {\n            left: current.left + addition.left,\n            top: current.top + addition.top\n        };\n    }\n    addScroll(rect, scroll) {\n        return addScroll(rect, scroll);\n    }\n    align(settings) {\n        return align(settings);\n    }\n    boundingOffset(el) {\n        return boundingOffset(this.nativeElement(el));\n    }\n    getFontStyles(el) {\n        const window = this.getWindow();\n        if (!window || !el) {\n            return [];\n        }\n        const computedStyles = window.getComputedStyle(this.nativeElement(el));\n        return STYLES.map(font => ({ key: font, value: computedStyles[font] }));\n    }\n    getWindow() {\n        return isWindowAvailable() ? window : null;\n    }\n    hasOffsetParent(el) {\n        if (!el) {\n            return false;\n        }\n        return !!this.nativeElement(el).offsetParent;\n    }\n    offset(el) {\n        if (!el) {\n            return null;\n        }\n        return offset(this.nativeElement(el));\n    }\n    offsetAtPoint(el, currentLocation) {\n        if (!el) {\n            return null;\n        }\n        const element = this.nativeElement(el);\n        const { left, top, transition } = element.style;\n        element.style.transition = 'none';\n        element.style.left = `${currentLocation.left}px`;\n        element.style.top = `${currentLocation.top}px`;\n        const currentOffset = offset(element);\n        element.style.left = left;\n        element.style.top = top;\n        // prevents elements with transition to be animated because of the change\n        // tslint:disable-next-line:no-unused-expression\n        element.offsetHeight;\n        element.style.transition = transition;\n        return currentOffset;\n    }\n    nativeElement(el) {\n        if (!el) {\n            return null;\n        }\n        return el.nativeElement || el;\n    }\n    position(element, popup, scale = 1) {\n        if (!element || !popup) {\n            return null;\n        }\n        return positionWithScroll(this.nativeElement(element), this.nativeElement(popup), scale);\n    }\n    removeScroll(rect, scroll) {\n        return removeScroll(rect, scroll);\n    }\n    restrictToView(settings) {\n        return restrictToView(settings);\n    }\n    scrollPosition(el) {\n        return scrollPosition(this.nativeElement(el));\n    }\n    scrollableParents(el) {\n        return scrollableParents(this.nativeElement(el));\n    }\n    stackingElementOffset(el) {\n        const relativeContextElement = this.getRelativeContextElement(el);\n        if (!relativeContextElement) {\n            return null;\n        }\n        return offset(relativeContextElement);\n    }\n    stackingElementScroll(el) {\n        const relativeContextElement = this.getRelativeContextElement(el);\n        if (!relativeContextElement) {\n            return { x: 0, y: 0 };\n        }\n        return {\n            x: relativeContextElement.scrollLeft,\n            y: relativeContextElement.scrollTop\n        };\n    }\n    getRelativeContextElement(el) {\n        if (!el || !hasRelativeStackingContext()) {\n            return null;\n        }\n        let parent = this.nativeElement(el).parentElement;\n        while (parent) {\n            if (window.getComputedStyle(parent).transform !== 'none') {\n                return parent;\n            }\n            parent = parent.parentElement;\n        }\n        return null;\n    }\n    useRelativePosition(el) {\n        return !!this.getRelativeContextElement(el);\n    }\n    windowViewPort(el) {\n        return getWindowViewPort(this.nativeElement(el));\n    }\n    zIndex(anchor, container) {\n        return zIndex(this.nativeElement(anchor), this.nativeElement(container));\n    }\n    zoomLevel() {\n        if (!isDocumentAvailable() || !isWindowAvailable()) {\n            return 1;\n        }\n        return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;\n    }\n    isZoomed() {\n        return this.zoomLevel() > 1;\n    }\n};\nDOMService = tslib_1.__decorate([\n    Injectable()\n], DOMService);\nexport { DOMService };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kcA4IC,CAAC,AAGa;;"}