/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { isJapanese } from './../shared/utils';
import { closest } from './../common/dom-utils';
import { NG_VALUE_ACCESSOR, NgControl } from '@angular/forms';
import { Component, ElementRef, forwardRef, Input, Output, EventEmitter, HostBinding, ViewChild, NgZone, ChangeDetectorRef, Injector, ContentChild, Renderer2 } from '@angular/core';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from '../package-metadata';
import { invokeElementMethod } from '../common/dom-utils';
import { areSame, requiresZoneOnBlur } from '../common/utils';
import { guid, hasObservers, KendoInput, Keys } from '@progress/kendo-angular-common';
import { TextBoxSuffixTemplateDirective } from './textbox-suffix.directive';
import { TextBoxPrefixTemplateDirective } from './textbox-prefix.directive';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { isSafari } from '../shared/utils';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './localization/localized-textbox-messages.directive';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@progress/kendo-angular-common';

const _c0 = ["input"];
const _c1 = ["kendoTextBoxLocalizedMessages", "", 6, "clear"];
var I18N_2;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the **Clear** button in the TextBox.
     * @meaning kendo.textbox.clear
     */ 
    const MSG_EXTERNAL_2651889799249671820$$DIST_ES_TEXTBOX_TEXTBOX_COMPONENT_JS_3 = goog.getMsg("Clear");
    I18N_2 = MSG_EXTERNAL_2651889799249671820$$DIST_ES_TEXTBOX_TEXTBOX_COMPONENT_JS_3;
}
else {
    I18N_2 = ɵngcc0.ɵɵi18nLocalize("Clear");
}
const _c4 = ["clear", I18N_2];
const _c5 = [1, "k-input-prefix"];
const _c6 = [4, "ngIf"];
const _c7 = [1, "k-input", 3, "id", "disabled", "readonly", "value", "kendoEventsOutsideAngular"];
const _c8 = ["input", ""];
const _c9 = [1, "k-input-suffix"];
const _c10 = [3, "ngClass", 4, "ngIf"];
const _c11 = ["role", "button", "class", "k-clear-value", 3, "tabindex", "title", "click", "mousedown", "keydown.enter", "keydown.space", 4, "ngIf"];
const _c12 = [3, "ngTemplateOutlet"];
function TextBoxComponent_3_ng_template_0_Template(rf, ctx) { }
function TextBoxComponent_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TextBoxComponent_3_ng_template_0_Template, 0, 0, "ng-template", _c12);
} if (rf & 2) {
    const ctx_r302 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r302.prefixTemplate == null ? null : ctx_r302.prefixTemplate.templateRef);
} }
const _c13 = [3, "ngClass"];
function TextBoxComponent_span_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", _c13);
} if (rf & 2) {
    const ctx_r304 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r304.errorIconClasses);
} }
function TextBoxComponent_span_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", _c13);
} if (rf & 2) {
    const ctx_r305 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r305.successIconClasses);
} }
const _c14 = ["role", "button", 1, "k-clear-value", 3, "tabindex", "title", "click", "mousedown", "keydown.enter", "keydown.space"];
function TextBoxComponent_span_9_Template(rf, ctx) { if (rf & 1) {
    const _r310 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", _c14);
    ɵngcc0.ɵɵlistener("click", function TextBoxComponent_span_9_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r310); const ctx_r309 = ɵngcc0.ɵɵnextContext(); return ctx_r309.clearValue(); });
    ɵngcc0.ɵɵlistener("mousedown", function TextBoxComponent_span_9_Template_span_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r310); return $event.preventDefault(); });
    ɵngcc0.ɵɵlistener("keydown.enter", function TextBoxComponent_span_9_Template_span_keydown_enter_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r310); const ctx_r312 = ɵngcc0.ɵɵnextContext(); return ctx_r312.clearValue($event); });
    ɵngcc0.ɵɵlistener("keydown.space", function TextBoxComponent_span_9_Template_span_keydown_space_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r310); const ctx_r313 = ɵngcc0.ɵɵnextContext(); return ctx_r313.clearValue($event); });
    ɵngcc0.ɵɵelement(1, "span", _c13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r306 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tabindex", ctx_r306.tabIndex)("title", ctx_r306.clearTitle());
    ɵngcc0.ɵɵattribute("aria-label", ctx_r306.clearTitle());
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r306.clearButtonClasses);
} }
function TextBoxComponent_10_ng_template_0_Template(rf, ctx) { }
function TextBoxComponent_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TextBoxComponent_10_ng_template_0_Template, 0, 0, "ng-template", _c12);
} if (rf & 2) {
    const ctx_r307 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r307.suffixTemplate == null ? null : ctx_r307.suffixTemplate.templateRef);
} }
const _c15 = function (a0, a1, a2) { return { focus: a0, blur: a1, input: a2 }; };
var FOCUSED = 'k-state-focused';
var TextBoxComponent = /** @class */ (function () {
    function TextBoxComponent(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
        var _this = this;
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        this.injector = injector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = "k-" + guid();
        /**
         * Sets the `title` attribute of the `input` element of the TextBox.
         */
        this.title = '';
        /**
         * Sets the disabled state of the component.
         *
         * @default false
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         *
         * @default false
         */
        this.readonly = false;
        /**
         * Specifies the `tabindex` of the TextBox.
         *
         * @default 0
         */
        this.tabindex = 0;
        /**
         * Provides a value for the TextBox.
         */
        this.value = null;
        /**
         * Determines whether the whole value will be selected when the TextBox is clicked. Defaults to `false`.
         *
         * @default false
         */
        this.selectOnFocus = false;
        /**
         * Specifies when the Success icon will be shown ([see example]({% slug validation_textbox %})).
         *
         * The possible values are:
         *
         * `boolean`&mdash;The Success icon is displayed, if the condition given by the developer is met.
         *
         * `initial`&mdash;The Success icon will be displayed when the component state is neither `invalid` nor `touched` or `dirty`.
         *
         * @default false
         */
        this.showSuccessIcon = false;
        /**
         * Specifies when the Error icon will be shown ([see example]({% slug validation_textbox %})).
         *
         * The possible values are:
         *
         * * `initial`&mdash;The Error icon will be displayed when the component state is
         * `invalid` and `touched` or `dirty`.
         * * `boolean`&mdash;The Error icon is displayed, if the condition given by the developer is met.
         *
         * @default false
         */
        this.showErrorIcon = false;
        /**
         * Specifies whether a Clear button will be rendered.
         *
         * @default false
         */
        this.clearButton = false;
        /**
         * Fires each time the value is changed&mdash;
         * when the component is blurred or the value is cleared through the **Clear** button
         * ([see example]({% slug overview_textbox %}#toc-events)).
         * When the value of the component is programmatically changed to `ngModel` or `formControl`
         * through its API or form binding, the `valueChange` event is not triggered because it
         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user focuses the `input` element.
         */
        this.inputFocus = new EventEmitter();
        /**
         * Fires each time the `input` element gets blurred.
         */
        this.inputBlur = new EventEmitter();
        /**
         * Fires each time the user focuses the TextBox component.
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textbox (focus)="handleFocus()"></kendo-textbox>
         * `
         * })
         * class AppComponent {
         *   public handleFocus(): void {
         *      console.log('Component is isFocused');
         *   }
         * }
         * ```
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the TextBox component gets blurred.
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textbox (blur)="handleBlur()"></kendo-textbox>
         * `
         * })
         * class AppComponent {
         *   public handleBlur(): void {
         *      console.log('Component is blurred');
         *   }
         * }
         * ```
         */
        this.onBlur = new EventEmitter();
        this.hostClass = true;
        this._isFocused = false;
        this.focusChangedProgrammatically = false;
        /**
         * @hidden
         */
        this.handleInputFocus = function () {
            if (!_this.disabled) {
                if (_this.selectOnFocus && _this.value) {
                    _this.ngZone.run(function () {
                        setTimeout(function () { _this.selectAll(); });
                    });
                }
                if (hasObservers(_this.onFocus)) {
                    if (!_this.isFocused) {
                        _this.ngZone.run(function () {
                            _this.onFocus.emit();
                        });
                    }
                }
                if (hasObservers(_this.inputFocus)) {
                    if (!_this.focusChangedProgrammatically || (_this.focusChangedProgrammatically && _this.clearButtonClicked)) {
                        _this.ngZone.run(function () {
                            _this.inputFocus.emit();
                        });
                    }
                }
                _this.ngZone.run(function () {
                    _this.isFocused = true;
                });
            }
        };
        /**
         * @hidden
         */
        this.handleInputBlur = function () {
            _this.changeDetector.markForCheck();
            if (hasObservers(_this.inputBlur) || requiresZoneOnBlur(_this.control)) {
                _this.ngZone.run(function () {
                    _this.ngTouched();
                    _this.inputBlur.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleInput = function (ev) {
            var incomingValue = isSafari(navigator.userAgent) && isJapanese(ev.target.value) ? ev.data : ev.target.value;
            _this.updateValue(incomingValue);
        };
        this.ngChange = function (_) { };
        this.ngTouched = function () { };
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    TextBoxComponent_1 = TextBoxComponent;
    Object.defineProperty(TextBoxComponent.prototype, "tabIndex", {
        get: function () {
            return this.tabindex;
        },
        /**
         * @hidden
         */
        set: function (tabIndex) {
            this.tabindex = tabIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxComponent.prototype, "disabledClass", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    TextBoxComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.control = this.injector.get(NgControl, null);
        this.checkClearButton();
        this.subscriptions = this.localizationService.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
        });
    };
    TextBoxComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        var hostElement = this.hostElement.nativeElement;
        var cursorInsideWrapper = false;
        var tabbing = false;
        this.ngZone.runOutsideAngular(function () {
            // focusIn and focusOut are relative to the host element
            _this.subscriptions.add(_this.renderer.listen(hostElement, 'focusin', function () {
                if (!_this.isFocused) {
                    _this.ngZone.run(function () {
                        _this.onFocus.emit();
                        _this.isFocused = true;
                    });
                }
            }));
            _this.subscriptions.add(_this.renderer.listen(hostElement, 'focusout', function (args) {
                if (!_this.isFocused) {
                    return;
                }
                if (tabbing) {
                    var closestTextbox = closest(args.relatedTarget, function (element) { return element === _this.hostElement.nativeElement; });
                    if (!closestTextbox) {
                        _this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper && !_this.clearButtonClicked) {
                        _this.handleBlur();
                    }
                }
            }));
            _this.subscriptions.add(_this.renderer.listen(hostElement, 'mouseenter', function () {
                cursorInsideWrapper = true;
            }));
            _this.subscriptions.add(_this.renderer.listen(hostElement, 'mouseleave', function () {
                cursorInsideWrapper = false;
            }));
            _this.subscriptions.add(_this.renderer.listen(hostElement, 'keydown', function (args) {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
        });
    };
    TextBoxComponent.prototype.ngOnChanges = function (changes) {
        if (changes.disabled || changes.readonly || changes.value) {
            this.checkClearButton();
        }
    };
    TextBoxComponent.prototype.ngOnDestroy = function () {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    };
    /**
     * Focuses the TextBox.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="input.focus()">Focus the input</button>
     *  <kendo-textbox #input></kendo-textbox>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    TextBoxComponent.prototype.focus = function () {
        if (!this.input) {
            return;
        }
        this.focusChangedProgrammatically = true;
        this.isFocused = true;
        this.input.nativeElement.focus();
        this.focusChangedProgrammatically = false;
    };
    /**
     * Blurs the TextBox.
     */
    TextBoxComponent.prototype.blur = function () {
        this.focusChangedProgrammatically = true;
        var isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');
        if (isFocusedElement) {
            isFocusedElement.blur();
        }
        this.isFocused = false;
        this.focusChangedProgrammatically = false;
    };
    /**
     * @hidden
     */
    TextBoxComponent.prototype.clearTitle = function () {
        return this.localizationService.get('clear');
    };
    /**
     * @hidden
     */
    TextBoxComponent.prototype.checkClearButton = function () {
        this.showClearButton =
            !this.disabled &&
                !this.readonly &&
                this.clearButton &&
                !!this.value;
    };
    /**
     * @hidden
     */
    TextBoxComponent.prototype.clearValue = function (ev) {
        if (ev) {
            ev.preventDefault();
        }
        this.clearButtonClicked = true;
        this.input.nativeElement.value = '';
        this.input.nativeElement.focus();
        this.updateValue('');
        this.checkClearButton();
        this.clearButtonClicked = false;
    };
    /**
     * @hidden
     */
    TextBoxComponent.prototype.writeValue = function (value) {
        this.value = value;
        this.checkClearButton();
    };
    /**
     * @hidden
     */
    TextBoxComponent.prototype.registerOnChange = function (fn) {
        this.ngChange = fn;
    };
    /**
     * @hidden
     */
    TextBoxComponent.prototype.registerOnTouched = function (fn) {
        this.ngTouched = fn;
    };
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    TextBoxComponent.prototype.setDisabledState = function (isDisabled) {
        this.changeDetector.markForCheck();
        this.disabled = isDisabled;
    };
    /**
     * @hidden
     */
    TextBoxComponent.prototype.showErrorsInitial = function () {
        if (!this.control) {
            return false;
        }
        var _a = this.control, invalid = _a.invalid, dirty = _a.dirty, touched = _a.touched;
        return invalid && (dirty || touched);
    };
    /**
     * @hidden
     */
    TextBoxComponent.prototype.showSuccessInitial = function () {
        if (!this.control) {
            return false;
        }
        var _a = this.control, valid = _a.valid, dirty = _a.dirty, touched = _a.touched;
        return valid && (dirty || touched);
    };
    Object.defineProperty(TextBoxComponent.prototype, "successIconClasses", {
        /**
         * @hidden
         */
        get: function () {
            return this.successIcon
                ? "k-text-success " + this.successIcon
                : "k-text-success k-icon k-i-check-outline";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxComponent.prototype, "errorIconClasses", {
        /**
         * @hidden
         */
        get: function () {
            return this.errorIcon
                ? "k-text-error " + this.errorIcon
                : "k-text-error k-icon k-i-warning";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxComponent.prototype, "clearButtonClasses", {
        /**
         * @hidden
         */
        get: function () {
            return this.clearButtonIcon
                ? this.clearButtonIcon
                : "k-icon k-i-close-circle";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxComponent.prototype, "hasErrors", {
        /**
         * @hidden
         */
        get: function () {
            return this.showErrorIcon === 'initial'
                ? this.showErrorsInitial()
                : this.showErrorIcon;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxComponent.prototype, "isSuccessful", {
        /**
         * @hidden
         */
        get: function () {
            return this.showSuccessIcon === 'initial'
                ? this.showSuccessInitial()
                : this.showSuccessIcon;
        },
        enumerable: true,
        configurable: true
    });
    TextBoxComponent.prototype.setSelection = function (start, end) {
        if (this.isFocused) {
            invokeElementMethod(this.input, 'setSelectionRange', start, end);
        }
    };
    TextBoxComponent.prototype.selectAll = function () {
        if (this.value) {
            this.setSelection(0, this.value.length);
        }
    };
    TextBoxComponent.prototype.updateValue = function (value) {
        var _this = this;
        if (!areSame(this.value, value)) {
            this.ngZone.run(function () {
                _this.value = value;
                _this.ngChange(value);
                _this.valueChange.emit(value);
                _this.checkClearButton();
                _this.changeDetector.markForCheck();
            });
        }
    };
    Object.defineProperty(TextBoxComponent.prototype, "isFocused", {
        get: function () {
            return this._isFocused;
        },
        set: function (value) {
            if (this._isFocused !== value && this.hostElement) {
                var element = this.hostElement.nativeElement;
                if (value && !this.disabled) {
                    this.renderer.addClass(element, FOCUSED);
                }
                else {
                    this.renderer.removeClass(element, FOCUSED);
                }
                this._isFocused = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    TextBoxComponent.prototype.handleBlur = function () {
        var _this = this;
        this.ngZone.run(function () {
            if (!_this.focusChangedProgrammatically) {
                _this.onBlur.emit();
            }
            _this.isFocused = false;
        });
    };
    var TextBoxComponent_1;
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], TextBoxComponent.prototype, "focusableId", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], TextBoxComponent.prototype, "title", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], TextBoxComponent.prototype, "disabled", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], TextBoxComponent.prototype, "readonly", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number)
    ], TextBoxComponent.prototype, "tabindex", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], TextBoxComponent.prototype, "value", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], TextBoxComponent.prototype, "selectOnFocus", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], TextBoxComponent.prototype, "showSuccessIcon", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], TextBoxComponent.prototype, "showErrorIcon", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], TextBoxComponent.prototype, "clearButton", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], TextBoxComponent.prototype, "successIcon", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], TextBoxComponent.prototype, "errorIcon", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], TextBoxComponent.prototype, "clearButtonIcon", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number),
        tslib_1.__metadata("design:paramtypes", [Number])
    ], TextBoxComponent.prototype, "tabIndex", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], TextBoxComponent.prototype, "placeholder", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number)
    ], TextBoxComponent.prototype, "maxlength", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], TextBoxComponent.prototype, "valueChange", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], TextBoxComponent.prototype, "inputFocus", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], TextBoxComponent.prototype, "inputBlur", void 0);
    tslib_1.__decorate([
        Output('focus'),
        tslib_1.__metadata("design:type", EventEmitter)
    ], TextBoxComponent.prototype, "onFocus", void 0);
    tslib_1.__decorate([
        Output('blur'),
        tslib_1.__metadata("design:type", EventEmitter)
    ], TextBoxComponent.prototype, "onBlur", void 0);
    tslib_1.__decorate([
        ViewChild('input', { static: true }),
        tslib_1.__metadata("design:type", ElementRef)
    ], TextBoxComponent.prototype, "input", void 0);
    tslib_1.__decorate([
        ContentChild(TextBoxSuffixTemplateDirective, { static: false }),
        tslib_1.__metadata("design:type", TextBoxSuffixTemplateDirective)
    ], TextBoxComponent.prototype, "suffixTemplate", void 0);
    tslib_1.__decorate([
        ContentChild(TextBoxPrefixTemplateDirective, { static: false }),
        tslib_1.__metadata("design:type", TextBoxPrefixTemplateDirective)
    ], TextBoxComponent.prototype, "prefixTemplate", void 0);
    tslib_1.__decorate([
        HostBinding('class.k-state-disabled'),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [])
    ], TextBoxComponent.prototype, "disabledClass", null);
    tslib_1.__decorate([
        HostBinding('class.k-textbox'),
        tslib_1.__metadata("design:type", Boolean)
    ], TextBoxComponent.prototype, "hostClass", void 0);
    tslib_1.__decorate([
        HostBinding('attr.dir'),
        tslib_1.__metadata("design:type", String)
    ], TextBoxComponent.prototype, "direction", void 0);
    TextBoxComponent = TextBoxComponent_1 = tslib_1.__decorate([
        tslib_1.__metadata("design:paramtypes", [LocalizationService,
            NgZone,
            ChangeDetectorRef,
            Renderer2,
            Injector,
            ElementRef])
    ], TextBoxComponent);
TextBoxComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: TextBoxComponent, selectors: [["kendo-textbox"]], factory: function TextBoxComponent_Factory(t) { return new (t || TextBoxComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(Injector), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, contentQueries: function TextBoxComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TextBoxSuffixTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, TextBoxPrefixTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.suffixTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.prefixTemplate = _t.first);
    } }, viewQuery: function TextBoxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.input = _t.first);
    } }, hostBindings: function TextBoxComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(3);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-textbox", ctx.hostClass);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabledClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { focusableId: "focusableId", title: "title", disabled: "disabled", readonly: "readonly", tabindex: "tabindex", value: "value", selectOnFocus: "selectOnFocus", showSuccessIcon: "showSuccessIcon", showErrorIcon: "showErrorIcon", clearButton: "clearButton", tabIndex: "tabIndex", successIcon: "successIcon", errorIcon: "errorIcon", clearButtonIcon: "clearButtonIcon", placeholder: "placeholder", maxlength: "maxlength" }, outputs: { valueChange: "valueChange", inputFocus: "inputFocus", inputBlur: "inputBlur", onFocus: "focus", onBlur: "blur" }, exportAs: ["kendoTextBox"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.textbox' },
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(function () { return TextBoxComponent_1; }),
                multi: true
            },
            { provide: KendoInput, useExisting: forwardRef(function () { return TextBoxComponent_1; }) }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], consts: 11, vars: 18, template: function TextBoxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, _c1);
        ɵngcc0.ɵɵi18nAttributes(1, _c4);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "span", _c5);
        ɵngcc0.ɵɵtemplate(3, TextBoxComponent_3_Template, 1, 1, undefined, _c6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "input", _c7, _c8);
        ɵngcc0.ɵɵelementStart(6, "span", _c9);
        ɵngcc0.ɵɵtemplate(7, TextBoxComponent_span_7_Template, 1, 1, "span", _c10);
        ɵngcc0.ɵɵtemplate(8, TextBoxComponent_span_8_Template, 1, 1, "span", _c10);
        ɵngcc0.ɵɵtemplate(9, TextBoxComponent_span_9_Template, 2, 4, "span", _c11);
        ɵngcc0.ɵɵtemplate(10, TextBoxComponent_10_Template, 1, 1, undefined, _c6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("disabled", ctx.disabled)("readonly", ctx.readonly)("value", ctx.value)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction3(14, _c15, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));
        ɵngcc0.ɵɵattribute("tabindex", ctx.disabled ? undefined : ctx.tabindex)("placeholder", ctx.placeholder)("title", ctx.title)("maxlength", ctx.maxlength);
        ɵngcc0.ɵɵselect(7);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasErrors);
        ɵngcc0.ɵɵselect(8);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isSuccessful);
        ɵngcc0.ɵɵselect(9);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showClearButton);
        ɵngcc0.ɵɵselect(10);
        ɵngcc0.ɵɵproperty("ngIf", ctx.suffixTemplate);
    } }, directives: [ɵngcc1.LocalizedTextBoxMessagesDirective, ɵngcc2.NgIf, ɵngcc3.EventsOutsideAngularDirective, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgClass], encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextBoxComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoTextBox',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.textbox' },
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(function () { return TextBoxComponent_1; }),
                        multi: true
                    },
                    { provide: KendoInput, useExisting: forwardRef(function () { return TextBoxComponent_1; }) }
                ],
                selector: 'kendo-textbox',
                template: "\n        <ng-container kendoTextBoxLocalizedMessages\n            i18n-clear=\"kendo.textbox.clear|The title for the **Clear** button in the TextBox.\"\n            clear=\"Clear\">\n        </ng-container>\n        <span class=\"k-input-prefix\">\n            <ng-template\n                *ngIf=\"prefixTemplate\"\n                [ngTemplateOutlet]=\"prefixTemplate?.templateRef\">\n            </ng-template>\n        </span>\n        <input\n            class=\"k-input\"\n            #input\n            [id]=\"focusableId\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [attr.tabindex]=\"disabled ? undefined : tabindex\"\n            [value]=\"value\"\n            [attr.placeholder]=\"placeholder\"\n            [attr.title]=\"title\"\n            [attr.maxlength]=\"maxlength\"\n            [kendoEventsOutsideAngular]=\"{\n                focus: handleInputFocus,\n                blur: handleInputBlur,\n                input: handleInput}\"/>\n        <span class=\"k-input-suffix\">\n            <span *ngIf=\"hasErrors\" [ngClass]=\"errorIconClasses\"></span>\n            <span *ngIf=\"isSuccessful\" [ngClass]=\"successIconClasses\"></span>\n            <span\n                role=\"button\"\n                class=\"k-clear-value\"\n                *ngIf=\"showClearButton\"\n                (click)=\"clearValue()\"\n                (mousedown)=\"$event.preventDefault()\"\n                [tabindex]=\"tabIndex\"\n                [attr.aria-label]=\"clearTitle()\"\n                [title]=\"clearTitle()\"\n                (keydown.enter)=\"clearValue($event)\"\n                (keydown.space)=\"clearValue($event)\"\n                >\n                <span [ngClass]=\"clearButtonClasses\"></span>\n            </span>\n            <ng-template\n                *ngIf=\"suffixTemplate\"\n                [ngTemplateOutlet]=\"suffixTemplate?.templateRef\">\n            </ng-template>\n        </span>\n    "
            }]
    }], function () { return [{ type: LocalizationService }, { type: NgZone }, { type: ChangeDetectorRef }, { type: Renderer2 }, { type: Injector }, { type: ElementRef }]; }, { localizationService: [], ngZone: [], changeDetector: [], renderer: [], injector: [], hostElement: [], focusableId: [{
            type: Input
        }], title: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], value: [{
            type: Input
        }], selectOnFocus: [{
            type: Input
        }], showSuccessIcon: [{
            type: Input
        }], showErrorIcon: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], inputFocus: [{
            type: Output
        }], inputBlur: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-textbox']
        }], _isFocused: [], focusChangedProgrammatically: [], handleInputFocus: [], handleInputBlur: [], handleInput: [], ngChange: [], ngTouched: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], tabIndex: [{
            type: Input
        }], tabIndex: [], disabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], ngOnInit: [], control: [], subscriptions: [], ngAfterViewInit: [], ngOnChanges: [], ngOnDestroy: [], focus: [], isFocused: [], blur: [], clearTitle: [], checkClearButton: [], showClearButton: [], clearValue: [], clearButtonClicked: [], writeValue: [], registerOnChange: [], registerOnTouched: [], setDisabledState: [], showErrorsInitial: [], showSuccessInitial: [], successIconClasses: [], errorIconClasses: [], clearButtonClasses: [], hasErrors: [], isSuccessful: [], setSelection: [], selectAll: [], updateValue: [], handleBlur: [], successIcon: [{
            type: Input
        }], errorIcon: [{
            type: Input
        }], clearButtonIcon: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], maxlength: [{
            type: Input
        }], input: [{
            type: ViewChild,
            args: ['input', { static: true }]
        }], suffixTemplate: [{
            type: ContentChild,
            args: [TextBoxSuffixTemplateDirective, { static: false }]
        }], prefixTemplate: [{
            type: ContentChild,
            args: [TextBoxPrefixTemplateDirective, { static: false }]
        }] });
    return TextBoxComponent;
}());
export { TextBoxComponent };

//# sourceMappingURL=textbox.component.js.map