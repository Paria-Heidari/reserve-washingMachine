/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { ContentChild, Component, ElementRef, EventEmitter, HostBinding, Input, Inject, Optional, Renderer2, isDevMode, ChangeDetectorRef } from '@angular/core';
import { RTL } from '@progress/kendo-angular-l10n';
import { TextAreaDirective } from '../shared/textarea.directive';
import { NgControl } from '@angular/forms';
import { guid, KendoInput } from '@progress/kendo-angular-common';
import { FloatingLabelInputAdapter } from './floating-label-input-adapter';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["class", "k-label", 3, "for", 4, "ngIf"];
const _c1 = [1, "k-label", 3, "for"];
function TextBoxContainerComponent_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", _c1);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r288 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("for", ctx_r288.id);
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r288.floatingLabel);
} }
const _c2 = ["*"];
var isFunction = function (x) { return Object.prototype.toString.call(x) === '[object Function]'; };
var ɵ0 = isFunction;
/**
 * @hidden
 */
var TextBoxContainerComponent = /** @class */ (function () {
    function TextBoxContainerComponent(elementRef, renderer, changeDetectorRef, rtl) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.changeDetectorRef = changeDetectorRef;
        /**
         * @hidden
         */
        this.focused = false;
        /**
         * @hidden
         */
        this.empty = true;
        /**
         * @hidden
         */
        this.invalid = false;
        this._subscriptions = [];
        this.autoFillStarted = false;
        this.direction = rtl ? 'rtl' : 'ltr';
        this.renderer.removeAttribute(this.elementRef.nativeElement, "id");
    }
    Object.defineProperty(TextBoxContainerComponent.prototype, "hostClasses", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxContainerComponent.prototype, "textareaElementClass", {
        get: function () {
            return !!this.textarea;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxContainerComponent.prototype, "focusedClass", {
        get: function () {
            return this.focused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxContainerComponent.prototype, "invalidClass", {
        get: function () {
            return this.invalid;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    TextBoxContainerComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        if (!this.formControl && !this.kendoInput) {
            if (isDevMode()) {
                throw new Error("The TextBoxContainer requires a Kendo Input component" +
                    " or a forms-bound component to function properly.");
            }
            return;
        }
        // add focus/blur/valueChange handlers
        var control = new FloatingLabelInputAdapter(this.kendoInput || this.formControl.valueAccessor, this.formControl);
        var setFocus = function (isFocused) { return function () {
            _this.focused = isFocused;
            _this.updateState();
        }; };
        this.subscribe(control, 'onFocus', setFocus(true));
        this.subscribe(control, 'onBlur', setFocus(false));
        this.subscribe(control, 'autoFillStart', function () {
            _this.autoFillStarted = true;
            _this.renderer.removeClass(_this.elementRef.nativeElement, 'k-state-empty');
        });
        this.subscribe(control, 'autoFillEnd', function () {
            if (_this.autoFillStarted) {
                _this.autoFillStarted = false;
                if (_this.empty) {
                    _this.renderer.addClass(_this.elementRef.nativeElement, 'k-state-empty');
                }
            }
        });
        var updateState = function () { return _this.updateState(); };
        updateState();
        this.subscribe(control, 'onValueChange', updateState);
        // set label id for floating label
        if (this.id && control.focusableId) {
            // input wins
            this.id = control.focusableId;
        }
        else if (this.id) {
            control.focusableId = this.id;
        }
        else if (control.focusableId) {
            this.id = control.focusableId;
        }
        else {
            var id = "_" + guid();
            control.focusableId = id;
            this.id = id;
        }
    };
    /**
     * @hidden
     */
    TextBoxContainerComponent.prototype.ngOnDestroy = function () {
        this._subscriptions.forEach(function (s) { return s.unsubscribe(); });
        this._subscriptions = [];
    };
    TextBoxContainerComponent.prototype.subscribe = function (control, eventName, handler) {
        if (control[eventName] instanceof EventEmitter) {
            var subscription = control[eventName].subscribe(handler);
            this._subscriptions.push(subscription);
        }
    };
    TextBoxContainerComponent.prototype.updateState = function () {
        var empty = function (value) {
            // zero is not an empty value (e.g., NumericTextBox)
            if (value === 0 || value === false) {
                return false;
            }
            // empty arrays are an empty value (e.g., MultiSelect)
            if (Array.isArray(value) && !value.length) {
                return true;
            }
            return !value;
        };
        var formControl = this.formControl;
        if (formControl) {
            var valueAccessor = formControl.valueAccessor;
            if (isFunction(valueAccessor.isEmpty)) {
                this.empty = valueAccessor.isEmpty();
            }
            else {
                this.empty = empty(formControl.value);
            }
            this.invalid = formControl.invalid && (formControl.touched || formControl.dirty);
        }
        else {
            this.empty = isFunction(this.kendoInput.isEmpty) ?
                this.kendoInput.isEmpty() : empty(this.kendoInput.value);
        }
        if (this.empty) {
            this.renderer.addClass(this.elementRef.nativeElement, 'k-state-empty');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'k-state-empty');
        }
        this.changeDetectorRef.markForCheck();
    };
    tslib_1.__decorate([
        HostBinding('class.k-textbox-container'),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [])
    ], TextBoxContainerComponent.prototype, "hostClasses", null);
    tslib_1.__decorate([
        HostBinding('class.k-textarea-wrapper'),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [])
    ], TextBoxContainerComponent.prototype, "textareaElementClass", null);
    tslib_1.__decorate([
        HostBinding('class.k-state-focused'),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [])
    ], TextBoxContainerComponent.prototype, "focusedClass", null);
    tslib_1.__decorate([
        HostBinding('class.k-state-invalid'),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [])
    ], TextBoxContainerComponent.prototype, "invalidClass", null);
    tslib_1.__decorate([
        HostBinding('attr.dir'),
        tslib_1.__metadata("design:type", String)
    ], TextBoxContainerComponent.prototype, "direction", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], TextBoxContainerComponent.prototype, "id", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], TextBoxContainerComponent.prototype, "floatingLabel", void 0);
    tslib_1.__decorate([
        ContentChild(KendoInput, { static: false }),
        tslib_1.__metadata("design:type", Object)
    ], TextBoxContainerComponent.prototype, "kendoInput", void 0);
    tslib_1.__decorate([
        ContentChild(TextAreaDirective, { static: false }),
        tslib_1.__metadata("design:type", TextAreaDirective)
    ], TextBoxContainerComponent.prototype, "textarea", void 0);
    tslib_1.__decorate([
        ContentChild(NgControl, { static: false }),
        tslib_1.__metadata("design:type", NgControl)
    ], TextBoxContainerComponent.prototype, "formControl", void 0);
    TextBoxContainerComponent = tslib_1.__decorate([
        tslib_1.__param(3, Optional()), tslib_1.__param(3, Inject(RTL)),
        tslib_1.__metadata("design:paramtypes", [ElementRef,
            Renderer2,
            ChangeDetectorRef, Boolean])
    ], TextBoxContainerComponent);
TextBoxContainerComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: TextBoxContainerComponent, selectors: [["kendo-textbox-container"]], factory: function TextBoxContainerComponent_Factory(t) { return new (t || TextBoxContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(RTL, 8)); }, contentQueries: function TextBoxContainerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, KendoInput, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, TextAreaDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgControl, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.kendoInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.textarea = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.formControl = _t.first);
    } }, hostBindings: function TextBoxContainerComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(5);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-textbox-container", ctx.hostClasses);
        ɵngcc0.ɵɵclassProp("k-textarea-wrapper", ctx.textareaElementClass);
        ɵngcc0.ɵɵclassProp("k-state-focused", ctx.focusedClass);
        ɵngcc0.ɵɵclassProp("k-state-invalid", ctx.invalidClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { id: "id", floatingLabel: "floatingLabel" }, ngContentSelectors: _c2, consts: 2, vars: 1, template: function TextBoxContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, TextBoxContainerComponent_label_1_Template, 2, 2, "label", _c0);
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.floatingLabel);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextBoxContainerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-textbox-container',
                template: "\n        <ng-content></ng-content>\n        <label *ngIf=\"floatingLabel\" [for]=\"id\" class=\"k-label\">{{ floatingLabel }}</label>\n    "
            }]
    }], function () { return [{ type: ElementRef }, { type: Renderer2 }, { type: ChangeDetectorRef }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [RTL]
            }] }]; }, { elementRef: [], renderer: [], changeDetectorRef: [], focused: [], empty: [], invalid: [], _subscriptions: [], autoFillStarted: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-textbox-container']
        }], textareaElementClass: [{
            type: HostBinding,
            args: ['class.k-textarea-wrapper']
        }], focusedClass: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], invalidClass: [{
            type: HostBinding,
            args: ['class.k-state-invalid']
        }], ngAfterContentInit: [], id: [{
            type: Input
        }], ngOnDestroy: [], subscribe: [], updateState: [], floatingLabel: [{
            type: Input
        }], kendoInput: [{
            type: ContentChild,
            args: [KendoInput, { static: false }]
        }], textarea: [{
            type: ContentChild,
            args: [TextAreaDirective, { static: false }]
        }], formControl: [{
            type: ContentChild,
            args: [NgControl, { static: false }]
        }] });
    return TextBoxContainerComponent;
}());
export { TextBoxContainerComponent };
export { ɵ0 };

//# sourceMappingURL=textbox-container.component.js.map