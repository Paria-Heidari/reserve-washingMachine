/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Directive, ElementRef, EventEmitter, HostBinding, Renderer2, Optional, Inject, Input, NgZone, forwardRef, Output, ChangeDetectorRef, Injector } from '@angular/core';
import { NG_VALUE_ACCESSOR, NgControl } from '@angular/forms';
import { hasObservers, KendoInput, isDocumentAvailable } from '@progress/kendo-angular-common';
import { requiresZoneOnBlur } from '../common/utils';
import { RTL } from '@progress/kendo-angular-l10n';
import { fromEvent } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
/**
 * Represents the [Kendo UI TextArea directive for the Inputs components for Angular]({% slug overview_textarea %}).
 * Provides floating labels to `textarea` elements.
 *
 * @example
 * ```ts-no-run
 * <textarea kendoTextArea></textarea>
 * ```
 */
import * as ɵngcc0 from '@angular/core';
var TextAreaDirective = /** @class */ (function () {
    function TextAreaDirective(renderer, element, zone, changeDetector, injector, rtl) {
        this.renderer = renderer;
        this.element = element;
        this.zone = zone;
        this.changeDetector = changeDetector;
        this.injector = injector;
        this.elementClass = true;
        this.autofillClass = true;
        /**
         * Fires each time the textarea value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Specifies if the `textarea` element will resize its height automatically
         * ([see example]({% slug overview_textarea %}#toc-auto-resizing)).
         *
         * @default false
         */
        this.autoSize = false;
        /**
         * @hidden
         */
        this.onFocus = new EventEmitter();
        /**
         * @hidden
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         */
        this.onValueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillStart = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillEnd = new EventEmitter();
        this.listeners = [];
        this.ngChange = function (_) { };
        this.ngTouched = function () { };
        this.direction = rtl ? 'rtl' : 'ltr';
    }
    TextAreaDirective_1 = TextAreaDirective;
    Object.defineProperty(TextAreaDirective.prototype, "id", {
        get: function () {
            return this.element.nativeElement.id;
        },
        set: function (id) {
            this.renderer.setAttribute(this.element.nativeElement, 'id', id);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    TextAreaDirective.prototype.writeValue = function (value) {
        this.elementValue = value;
        this.resize();
    };
    /**
     * @hidden
     */
    TextAreaDirective.prototype.registerOnChange = function (fn) {
        this.ngChange = fn;
    };
    /**
     * @hidden
     */
    TextAreaDirective.prototype.registerOnTouched = function (fn) {
        this.ngTouched = fn;
    };
    /**
     * @hidden
     */
    TextAreaDirective.prototype.setDisabledState = function (isDisabled) {
        this.setElementProperty('disabled', isDisabled);
    };
    TextAreaDirective.prototype.ngOnInit = function () {
        var _this = this;
        var element = this.element.nativeElement;
        this.zone.runOutsideAngular(function () {
            _this.listeners = [
                _this.renderer.listen(element, 'focus', _this.handleFocus.bind(_this)),
                _this.renderer.listen(element, 'blur', _this.handleBlur.bind(_this)),
                _this.renderer.listen(element, 'animationstart', function (e) {
                    if (e.animationName === 'autoFillStart') {
                        _this.autoFillStart.emit();
                    }
                    else if (e.animationName === 'autoFillEnd') {
                        _this.autoFillEnd.emit();
                    }
                })
            ];
            if (isDocumentAvailable() && _this.autoSize) {
                _this.resizeSubscription = fromEvent(window, 'resize')
                    .pipe((debounceTime(50)))
                    .subscribe(function () { return _this.resize(); });
            }
            _this.inputSubscription = fromEvent(element, 'input')
                .subscribe(_this.handleInput.bind(_this));
        });
        this.control = this.injector.get(NgControl, null);
    };
    TextAreaDirective.prototype.ngOnChanges = function (changes) {
        var element = this.element.nativeElement;
        if (changes.value) {
            this.elementValue = this.value;
        }
        if (changes.autoSize) {
            if (this.autoSize) {
                this.initialHeight = element.offsetHeight;
                this.renderer.setStyle(element, 'resize', 'none');
            }
            else {
                this.renderer.setStyle(element, 'overflow-y', 'auto');
                this.renderer.setStyle(element, 'resize', 'both');
                element.style.height = this.initialHeight + "px";
            }
        }
        this.resize();
    };
    TextAreaDirective.prototype.ngOnDestroy = function () {
        this.listeners.forEach(function (listener) { return listener(); });
        if (this.inputSubscription) {
            this.inputSubscription.unsubscribe();
        }
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    };
    Object.defineProperty(TextAreaDirective.prototype, "elementValue", {
        get: function () {
            if (this.element) {
                return this.element.nativeElement.value;
            }
            return '';
        },
        set: function (value) {
            this.setElementProperty('value', (value === undefined || value === null) ? '' : value);
        },
        enumerable: true,
        configurable: true
    });
    TextAreaDirective.prototype.setElementProperty = function (name, value) {
        if (this.element) {
            this.renderer.setProperty(this.element.nativeElement, name, value);
        }
    };
    TextAreaDirective.prototype.resize = function () {
        if (!this.autoSize) {
            return;
        }
        var element = this.element.nativeElement;
        this.renderer.setStyle(element, 'overflow-y', 'hidden');
        element.style.height = this.initialHeight + "px";
        var scrollHeight = element.scrollHeight;
        if (scrollHeight > this.initialHeight) {
            element.style.height = scrollHeight + "px";
        }
    };
    TextAreaDirective.prototype.handleInput = function () {
        var _this = this;
        var value = this.elementValue;
        this.value = value;
        if (this.control || hasObservers(this.onValueChange) || hasObservers(this.valueChange)) {
            this.zone.run(function () {
                _this.ngChange(value);
                _this.onValueChange.emit(value);
                _this.valueChange.emit(value);
                _this.changeDetector.markForCheck();
            });
        }
        this.resize();
    };
    TextAreaDirective.prototype.handleFocus = function () {
        var _this = this;
        if (hasObservers(this.onFocus)) {
            this.zone.run(function () {
                _this.onFocus.emit();
            });
        }
    };
    TextAreaDirective.prototype.handleBlur = function () {
        var _this = this;
        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
            this.zone.run(function () {
                _this.ngTouched();
                _this.onBlur.emit();
                _this.changeDetector.markForCheck();
            });
        }
    };
    var TextAreaDirective_1;
    tslib_1.__decorate([
        HostBinding('class.k-textarea'),
        tslib_1.__metadata("design:type", Boolean)
    ], TextAreaDirective.prototype, "elementClass", void 0);
    tslib_1.__decorate([
        HostBinding('class.k-autofill'),
        tslib_1.__metadata("design:type", Boolean)
    ], TextAreaDirective.prototype, "autofillClass", void 0);
    tslib_1.__decorate([
        HostBinding('attr.dir'),
        tslib_1.__metadata("design:type", String)
    ], TextAreaDirective.prototype, "direction", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], TextAreaDirective.prototype, "valueChange", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], TextAreaDirective.prototype, "autoSize", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], TextAreaDirective.prototype, "value", void 0);
    TextAreaDirective = TextAreaDirective_1 = tslib_1.__decorate([
        tslib_1.__param(5, Optional()), tslib_1.__param(5, Inject(RTL)),
        tslib_1.__metadata("design:paramtypes", [Renderer2,
            ElementRef,
            NgZone,
            ChangeDetectorRef,
            Injector, Boolean])
    ], TextAreaDirective);
TextAreaDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: TextAreaDirective, selectors: [["textarea", "kendoTextArea", ""]], factory: function TextAreaDirective_Factory(t) { return new (t || TextAreaDirective)(ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(Injector), ɵngcc0.ɵɵdirectiveInject(RTL, 8)); }, hostBindings: function TextAreaDirective_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(3);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-textarea", ctx.elementClass);
        ɵngcc0.ɵɵclassProp("k-autofill", ctx.autofillClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { autoSize: "autoSize", value: "value" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(function () { return TextAreaDirective_1; }),
                multi: true
            }, {
                provide: KendoInput,
                useExisting: forwardRef(function () { return TextAreaDirective_1; })
            }]), ɵngcc0.ɵɵNgOnChangesFeature()] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextAreaDirective, [{
        type: Directive,
        args: [{
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(function () { return TextAreaDirective_1; }),
                        multi: true
                    }, {
                        provide: KendoInput,
                        useExisting: forwardRef(function () { return TextAreaDirective_1; })
                    }],
                selector: 'textarea[kendoTextArea]'
            }]
    }], function () { return [{ type: Renderer2 }, { type: ElementRef }, { type: NgZone }, { type: ChangeDetectorRef }, { type: Injector }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [RTL]
            }] }]; }, { renderer: [], element: [], zone: [], changeDetector: [], injector: [], elementClass: [{
            type: HostBinding,
            args: ['class.k-textarea']
        }], autofillClass: [{
            type: HostBinding,
            args: ['class.k-autofill']
        }], valueChange: [{
            type: Output
        }], autoSize: [{
            type: Input
        }], onFocus: [], onBlur: [], onValueChange: [], autoFillStart: [], autoFillEnd: [], listeners: [], ngChange: [], ngTouched: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], id: [], id: [], writeValue: [], elementValue: [], registerOnChange: [], registerOnTouched: [], setDisabledState: [], ngOnInit: [], control: [], ngOnChanges: [], initialHeight: [], ngOnDestroy: [], setElementProperty: [], resize: [], handleInput: [], value: [{
            type: Input
        }], handleFocus: [], handleBlur: [] });
    return TextAreaDirective;
}());
export { TextAreaDirective };

//# sourceMappingURL=textarea.directive.js.map