{"version":3,"file":"slider.component.js","sources":["/Users/paria/workspace/washIt/client/node_modules/@progress/kendo-angular-inputs/dist/es/slider/slider.component.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as tslib_1 from \"tslib\";\nimport { Renderer2, Component, ElementRef, Input, ViewChild, forwardRef, NgZone, Injector, ChangeDetectorRef } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { fromEvent, interval, merge } from 'rxjs';\nimport { filter, concatMap, startWith, takeUntil, take } from 'rxjs/operators';\nimport { trimValue } from '../sliders-common/sliders-util';\nimport { SliderModel } from './slider-model';\nimport { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';\nimport { areSame, isPresent, requiresZoneOnBlur } from '../common/utils';\nimport { isButton, eventValue, decreaseValueToStep, increaseValueToStep } from '../sliders-common/sliders-util';\nimport { invokeElementMethod } from '../common/dom-utils';\nimport { guid, isDocumentAvailable, hasObservers, KendoInput, anyChanged, Keys } from '@progress/kendo-angular-common';\nimport { SliderBase } from '../sliders-common/slider-base';\nvar PRESSED = 'k-pressed';\n/**\n * Represents the [Kendo UI Slider component for Angular]({% slug overview_slider %}).\n */\nvar SliderComponent = /** @class */ (function (_super) {\n    tslib_1.__extends(SliderComponent, _super);\n    function SliderComponent(localization, injector, renderer, ngZone, changeDetector, hostElement) {\n        var _this = _super.call(this, localization, injector, renderer, ngZone, changeDetector, hostElement) || this;\n        _this.localization = localization;\n        _this.injector = injector;\n        _this.renderer = renderer;\n        _this.ngZone = ngZone;\n        _this.changeDetector = changeDetector;\n        _this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        _this.focusableId = \"k-\" + guid();\n        /**\n         * Determines if the animation will be played on value change.\n         * Regardless of this setting, no animation will be played during the initial rendering.\n         */\n        _this.animate = true;\n        /**\n         * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).\n         * When `showButtons` is set to `false`, the buttons are not displayed.\n         */\n        _this.showButtons = true;\n        /**\n         * The current value of the Slider when it is initially displayed.\n         * The component can use either NgModel or the `value` binding but not both of them at the same time.\n         */\n        _this.value = _this.min;\n        _this.focusChangedProgrammatically = false;\n        /**\n         * @hidden\n         */\n        _this.onWrapClick = function (args) {\n            var target = args.target;\n            if (!_this.isDisabled && !(isButton(target) || isButton(target.parentNode))) {\n                var value = eventValue(args, _this.track.nativeElement, _this.getProps());\n                _this.changeValue(value);\n            }\n            invokeElementMethod(_this.draghandle, 'focus');\n        };\n        /**\n         * @hidden\n         */\n        _this.onKeyDown = function (e) {\n            var options = _this.getProps();\n            var max = options.max, min = options.min;\n            var handler = _this.keyBinding[e.keyCode];\n            if (_this.isDisabled || !handler) {\n                return;\n            }\n            var value = handler(options);\n            _this.changeValue(trimValue(max, min, value));\n            e.preventDefault();\n        };\n        _this.ngChange = function (_) { };\n        _this.ngTouched = function () { };\n        _this.decreaseValue = function () {\n            _this.changeValue(decreaseValueToStep(_this.value, _this.getProps()));\n        };\n        _this.increaseValue = function () {\n            _this.changeValue(increaseValueToStep(_this.value, _this.getProps()));\n        };\n        _this.handleBlur = function () {\n            _this.changeDetector.markForCheck();\n            _this.focused = false;\n            if (hasObservers(_this.onBlur) || requiresZoneOnBlur(_this.control)) {\n                _this.ngZone.run(function () {\n                    _this.ngTouched();\n                    if (!_this.focusChangedProgrammatically) {\n                        _this.onBlur.emit();\n                    }\n                });\n            }\n        };\n        return _this;\n    }\n    SliderComponent_1 = SliderComponent;\n    Object.defineProperty(SliderComponent.prototype, \"tabIndex\", {\n        get: function () {\n            return this.tabindex;\n        },\n        /**\n         * @hidden\n         */\n        set: function (tabIndex) {\n            this.tabindex = tabIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"currentValue\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return isPresent(this.value) ? this.value.toString() : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Focuses the Slider.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"slider.focus()\">Focus</button>\n     *  <kendo-slider #slider></kendo-slider>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    SliderComponent.prototype.focus = function () {\n        if (!this.disabled) {\n            this.focusChangedProgrammatically = true;\n            invokeElementMethod(this.draghandle, 'focus');\n            this.focusChangedProgrammatically = false;\n        }\n    };\n    /**\n     * Blurs the Slider.\n     */\n    SliderComponent.prototype.blur = function () {\n        this.focusChangedProgrammatically = true;\n        invokeElementMethod(this.draghandle, 'blur');\n        this.handleBlur();\n        this.focusChangedProgrammatically = false;\n    };\n    SliderComponent.prototype.ngOnChanges = function (changes) {\n        var _this = this;\n        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {\n            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n                _this.sizeComponent(false);\n            });\n        }\n    };\n    SliderComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        if (this.showButtons) {\n            this.setValueChangeInterval(this.increaseButton.nativeElement, function () { return _this.increaseValue(); });\n            this.setValueChangeInterval(this.decreaseButton.nativeElement, function () { return _this.decreaseValue(); });\n        }\n        this.sizeComponent(false);\n        if (this.ticks) {\n            this.ticks.tickElements\n                .changes\n                .subscribe(function () { return _this.sizeComponent(false); });\n        }\n        this.attachElementEventHandlers();\n    };\n    SliderComponent.prototype.ngOnDestroy = function () {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n    };\n    Object.defineProperty(SliderComponent.prototype, \"incrementMessage\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this.incrementTitle || this.localizationService.get('increment');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"decrementMessage\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this.decrementTitle || this.localizationService.get('decrement');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"dragHandleMessage\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this.dragHandleTitle || this.localizationService.get('dragHandle');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.handleDragPress = function (args) {\n        if (args.originalEvent) {\n            args.originalEvent.preventDefault();\n        }\n        this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    };\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.onHandleDrag = function (args) {\n        this.dragging = true;\n        this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));\n    };\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.onHandleRelease = function () {\n        this.dragging = false; //needed for animation\n        this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    };\n    //ngModel binding\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.writeValue = function (value) {\n        this.changeDetector.markForCheck();\n        this.value = value;\n        this.sizeComponent(this.animate);\n    };\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.registerOnChange = function (fn) {\n        this.ngChange = fn;\n    };\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.registerOnTouched = function (fn) {\n        this.ngTouched = fn;\n    };\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.changeValue = function (value) {\n        var _this = this;\n        if (!areSame(this.value, value)) {\n            this.ngZone.run(function () {\n                _this.value = value;\n                _this.ngChange(value);\n                _this.valueChange.emit(value);\n                _this.sizeComponent(_this.animate);\n                _this.changeDetector.markForCheck();\n            });\n        }\n    };\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.sizeComponent = function (animate) {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        var wrapper = this.wrapper.nativeElement;\n        var track = this.track.nativeElement;\n        var selectionEl = this.sliderSelection.nativeElement;\n        var dragHandleEl = this.draghandle.nativeElement;\n        var ticks = this.ticks ? this.ticksContainer.nativeElement : null;\n        if (!animate) {\n            this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n        }\n        this.resetStyles([track, selectionEl, dragHandleEl, ticks, this.hostElement.nativeElement]);\n        var props = this.getProps();\n        var model = new SliderModel(props, wrapper, track, this.renderer);\n        model.resizeTrack();\n        if (this.ticks) { //for case when tickPlacement: none\n            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(function (element) { return element.nativeElement; }));\n        }\n        model.positionHandle(dragHandleEl);\n        model.positionSelection(dragHandleEl, selectionEl);\n        if (!animate) {\n            this.hostElement.nativeElement.getBoundingClientRect();\n            this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n        }\n        if (this.fixedTickWidth) {\n            model.resizeWrapper();\n        }\n    };\n    Object.defineProperty(SliderComponent.prototype, \"focused\", {\n        set: function (value) {\n            if (this.isFocused !== value && this.hostElement) {\n                this.isFocused = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"dragging\", {\n        set: function (value) {\n            if (this.isDragged !== value && this.sliderSelection && this.draghandle) {\n                var sliderSelection = this.sliderSelection.nativeElement;\n                var draghandle = this.draghandle.nativeElement;\n                if (value) {\n                    this.renderer.addClass(sliderSelection, PRESSED);\n                    this.renderer.addClass(draghandle, PRESSED);\n                }\n                else {\n                    this.renderer.removeClass(sliderSelection, PRESSED);\n                    this.renderer.removeClass(draghandle, PRESSED);\n                }\n                this.isDragged = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SliderComponent.prototype.setValueChangeInterval = function (element, callback) {\n        var _this = this;\n        this.ngZone.runOutsideAngular(function () {\n            var mousedown = fromEvent(element, 'mousedown');\n            var mouseup = fromEvent(element, 'mouseup');\n            var mouseout = fromEvent(element, 'mouseout');\n            var subscription = mousedown.pipe(filter(function (e) { return e.button === 0 && !_this.isDisabled; }), concatMap(function () {\n                return interval(150).pipe(startWith(-1), takeUntil(merge(mouseup, mouseout)));\n            })).subscribe(function () {\n                if (!_this.isFocused) {\n                    invokeElementMethod(_this.draghandle, 'focus');\n                }\n                callback();\n            });\n            _this.subscriptions.add(subscription);\n        });\n    };\n    SliderComponent.prototype.getProps = function () {\n        return {\n            buttons: this.showButtons,\n            disabled: this.disabled,\n            fixedTickWidth: this.fixedTickWidth,\n            largeStep: this.largeStep,\n            max: this.max,\n            min: this.min,\n            readonly: this.readonly,\n            reverse: this.reverse,\n            rtl: this.localizationService.rtl,\n            smallStep: this.smallStep,\n            value: trimValue(this.max, this.min, this.value),\n            vertical: this.vertical\n        };\n    };\n    SliderComponent.prototype.attachElementEventHandlers = function () {\n        var _this = this;\n        var hostElement = this.hostElement.nativeElement;\n        var tabbing = false;\n        var cursorInsideWrapper = false;\n        this.ngZone.runOutsideAngular(function () {\n            // focusIn and focusOut are relative to the host element\n            _this.subscriptions.add(_this.renderer.listen(hostElement, 'focusin', function () {\n                if (!_this.isFocused) {\n                    _this.ngZone.run(function () {\n                        if (!_this.focusChangedProgrammatically) {\n                            _this.onFocus.emit();\n                        }\n                        _this.focused = true;\n                    });\n                }\n            }));\n            _this.subscriptions.add(_this.renderer.listen(hostElement, 'focusout', function (args) {\n                if (!_this.isFocused) {\n                    return;\n                }\n                if (tabbing) {\n                    if (args.relatedTarget !== _this.draghandle.nativeElement) {\n                        _this.handleBlur();\n                    }\n                    tabbing = false;\n                }\n                else {\n                    if (!cursorInsideWrapper) {\n                        _this.handleBlur();\n                    }\n                }\n            }));\n            _this.subscriptions.add(_this.renderer.listen(hostElement, 'mouseenter', function () {\n                cursorInsideWrapper = true;\n            }));\n            _this.subscriptions.add(_this.renderer.listen(hostElement, 'mouseleave', function () {\n                cursorInsideWrapper = false;\n            }));\n            _this.subscriptions.add(_this.renderer.listen(hostElement, 'keydown', function (args) {\n                if (args.keyCode === Keys.Tab) {\n                    tabbing = true;\n                }\n                else {\n                    tabbing = false;\n                }\n            }));\n        });\n    };\n    var SliderComponent_1;\n    tslib_1.__decorate([\n        Input(),\n        tslib_1.__metadata(\"design:type\", String)\n    ], SliderComponent.prototype, \"focusableId\", void 0);\n    tslib_1.__decorate([\n        Input(),\n        tslib_1.__metadata(\"design:type\", String)\n    ], SliderComponent.prototype, \"dragHandleTitle\", void 0);\n    tslib_1.__decorate([\n        Input(),\n        tslib_1.__metadata(\"design:type\", String)\n    ], SliderComponent.prototype, \"incrementTitle\", void 0);\n    tslib_1.__decorate([\n        Input(),\n        tslib_1.__metadata(\"design:type\", Boolean)\n    ], SliderComponent.prototype, \"animate\", void 0);\n    tslib_1.__decorate([\n        Input(),\n        tslib_1.__metadata(\"design:type\", String)\n    ], SliderComponent.prototype, \"decrementTitle\", void 0);\n    tslib_1.__decorate([\n        Input(),\n        tslib_1.__metadata(\"design:type\", Boolean)\n    ], SliderComponent.prototype, \"showButtons\", void 0);\n    tslib_1.__decorate([\n        Input(),\n        tslib_1.__metadata(\"design:type\", Number)\n    ], SliderComponent.prototype, \"value\", void 0);\n    tslib_1.__decorate([\n        Input(),\n        tslib_1.__metadata(\"design:type\", Number),\n        tslib_1.__metadata(\"design:paramtypes\", [Number])\n    ], SliderComponent.prototype, \"tabIndex\", null);\n    tslib_1.__decorate([\n        ViewChild('draghandle', { static: true }),\n        tslib_1.__metadata(\"design:type\", ElementRef)\n    ], SliderComponent.prototype, \"draghandle\", void 0);\n    tslib_1.__decorate([\n        ViewChild('decreaseButton', { static: false }),\n        tslib_1.__metadata(\"design:type\", ElementRef)\n    ], SliderComponent.prototype, \"decreaseButton\", void 0);\n    tslib_1.__decorate([\n        ViewChild('increaseButton', { static: false }),\n        tslib_1.__metadata(\"design:type\", ElementRef)\n    ], SliderComponent.prototype, \"increaseButton\", void 0);\n    SliderComponent = SliderComponent_1 = tslib_1.__decorate([\n        Component({\n            exportAs: 'kendoSlider',\n            providers: [\n                LocalizationService,\n                { provide: L10N_PREFIX, useValue: 'kendo.slider' },\n                { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return SliderComponent_1; }) },\n                { provide: KendoInput, useExisting: forwardRef(function () { return SliderComponent_1; }) }\n            ],\n            selector: 'kendo-slider',\n            template: \"\\n        <ng-container kendoSliderLocalizedMessages\\n            i18n-increment=\\\"kendo.slider.increment|The title of the **Increase** button of the Slider.\\\"\\n            increment=\\\"increment\\\"\\n            i18n-decrement=\\\"kendo.slider.decrement|The title of the **Decrease** button of the Slider.\\\"\\n            decrement=\\\"decrement\\\"\\n            i18n-dragHandle=\\\"kendo.slider.dragHandle|The title of the drag handle of the Slider.\\\"\\n            dragHandle=\\\"Drag\\\"\\n        >\\n        <div class=\\\"k-slider-wrap\\\" #wrap\\n            [class.k-slider-buttons]=\\\"showButtons\\\"\\n            [class.k-slider-topleft]=\\\"tickPlacement === 'before'\\\"\\n            [class.k-slider-bottomright]=\\\"tickPlacement === 'after'\\\"\\n            [kendoEventsOutsideAngular]=\\\"{ click: onWrapClick, keydown: onKeyDown }\\\"\\n            >\\n            <span\\n                #decreaseButton\\n                *ngIf=\\\"showButtons\\\"\\n                class=\\\"k-button k-button-decrease\\\"\\n                [title]=\\\"decrementMessage\\\"\\n                role=\\\"presentation\\\"\\n            >\\n                <span class=\\\"k-icon\\\"\\n                    [class.k-i-arrow-w]=\\\"!vertical\\\"\\n                    [class.k-i-arrow-s]=\\\"vertical\\\"\\n                >\\n                </span>\\n            </span>\\n            <span\\n                *ngIf=\\\"showButtons\\\"\\n                #increaseButton\\n                class=\\\"k-button k-button-increase\\\"\\n                [title]=\\\"incrementMessage\\\"\\n                (click)=\\\"$event.preventDefault()\\\"\\n                [attr.aria-label]=\\\"currentValue\\\"\\n            >\\n                <span class=\\\"k-icon\\\"\\n                    [class.k-i-arrow-e]=\\\"!vertical\\\"\\n                    [class.k-i-arrow-n]=\\\"vertical\\\"\\n                >\\n                </span>\\n            </span>\\n            <ul kendoSliderTicks\\n                #ticks\\n                *ngIf=\\\"tickPlacement !== 'none'\\\"\\n                [tickTitle]=\\\"title\\\"\\n                [vertical]=\\\"vertical\\\"\\n                [step]=\\\"smallStep\\\"\\n                [largeStep]=\\\"largeStep\\\"\\n                [min]=\\\"min\\\"\\n                [max]=\\\"max\\\"\\n                [labelTemplate]=\\\"labelTemplate?.templateRef\\\"\\n                [attr.aria-hidden]=\\\"true\\\"\\n            >\\n            </ul>\\n            <div #track class=\\\"k-slider-track\\\">\\n                <div #sliderSelection class=\\\"k-slider-selection\\\">\\n                </div>\\n                <a #draghandle\\n                    role=\\\"slider\\\"\\n                    [attr.aria-valuemin]=\\\"min\\\"\\n                    [attr.aria-valuemax]=\\\"max\\\"\\n                    [attr.aria-valuenow]=\\\"currentValue\\\"\\n                    [attr.aria-valuetext]=\\\"currentValue\\\"\\n                    [attr.aria-disabled]=\\\"disabled ? true : undefined\\\"\\n                    [attr.aria-readonly]=\\\"readonly ? true : undefined\\\"\\n                    [attr.aria-orientation]=\\\"vertical ? 'vertical' : 'horizontal'\\\"\\n                    [style.touch-action]=\\\"isDisabled ? '' : 'none'\\\"\\n                    class=\\\"k-draghandle\\\"\\n                    [title]=\\\"dragHandleMessage\\\"\\n                    [attr.tabindex]=\\\"disabled ? '-1' : tabIndex\\\"\\n                    [id]=\\\"focusableId\\\"\\n                    kendoDraggable\\n                    (kendoPress)=\\\"ifEnabled(handleDragPress, $event)\\\"\\n                    (kendoDrag)=\\\"ifEnabled(onHandleDrag, $event)\\\"\\n                    (kendoRelease)=\\\"ifEnabled(onHandleRelease, $event)\\\"\\n                ></a>\\n            </div>\\n            <kendo-resize-sensor (resize)=\\\"sizeComponent(false)\\\"></kendo-resize-sensor>\\n        </div>\\n  \"\n        }),\n        tslib_1.__metadata(\"design:paramtypes\", [LocalizationService,\n            Injector,\n            Renderer2,\n            NgZone,\n            ChangeDetectorRef,\n            ElementRef])\n    ], SliderComponent);\n    return SliderComponent;\n}(SliderBase));\nexport { SliderComponent };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8DA2b8D,AAWnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAOa;;;;"}