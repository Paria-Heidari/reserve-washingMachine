/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Renderer2, Component, ElementRef, Input, ViewChild, forwardRef, NgZone, Injector, ChangeDetectorRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { take } from 'rxjs/operators';
import { trimValue, isSameRange, trimValueRange, validateValue } from '../sliders-common/sliders-util';
import { RangeSliderModel } from './rangeslider-model';
import { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';
import { eventValue, isStartHandle } from '../sliders-common/sliders-util';
import { invokeElementMethod } from '../common/dom-utils';
import { guid, isDocumentAvailable, Keys, KendoInput, anyChanged, hasObservers } from '@progress/kendo-angular-common';
import { requiresZoneOnBlur } from '../common/utils';
import { SliderBase } from '../sliders-common/slider-base';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './localization/localized-rangeslider-messages.directive';
import * as ɵngcc2 from '@progress/kendo-angular-common';
import * as ɵngcc3 from '@angular/common';
import * as ɵngcc4 from '../sliders-common/slider-ticks.component';

const _c0 = ["draghandleStart"];
const _c1 = ["draghandleEnd"];
const _c2 = ["kendoSliderLocalizedMessages", "", 6, "dragHandleStart", "dragHandleEnd"];
var I18N_3;
if (ngI18nClosureMode) {
    /**
     * @desc The title of the **Start** drag handle of the Slider.
     * @meaning kendo.rangeslider.dragHandleStart
     */ 
    const MSG_EXTERNAL_1512034289801794423$$DIST_ES_RANGESLIDER_RANGESLIDER_COMPONENT_JS_4 = goog.getMsg("Drag");
    I18N_3 = MSG_EXTERNAL_1512034289801794423$$DIST_ES_RANGESLIDER_RANGESLIDER_COMPONENT_JS_4;
}
else {
    I18N_3 = ɵngcc0.ɵɵi18nLocalize("Drag");
}
var I18N_5;
if (ngI18nClosureMode) {
    /**
     * @desc The title of the **End** drag handle of the Slider.
     * @meaning kendo.rangeslider.dragHandleEnd
     */ 
    const MSG_EXTERNAL_6915505327582510906$$DIST_ES_RANGESLIDER_RANGESLIDER_COMPONENT_JS_6 = goog.getMsg("Drag");
    I18N_5 = MSG_EXTERNAL_6915505327582510906$$DIST_ES_RANGESLIDER_RANGESLIDER_COMPONENT_JS_6;
}
else {
    I18N_5 = ɵngcc0.ɵɵi18nLocalize("Drag");
}
const _c7 = ["dragHandleStart", I18N_3, "dragHandleEnd", I18N_5];
const _c8 = [1, "k-slider-wrap", 3, "kendoEventsOutsideAngular"];
const _c9 = ["wrap", ""];
const _c10 = ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate", 4, "ngIf"];
const _c11 = [1, "k-slider-track"];
const _c12 = ["track", ""];
const _c13 = [1, "k-slider-selection"];
const _c14 = ["sliderSelection", ""];
const _c15 = ["role", "slider", "kendoDraggable", "", 1, "k-draghandle", 3, "id", "title", "kendoPress", "kendoDrag", "kendoRelease"];
const _c16 = ["draghandleStart", ""];
const _c17 = ["draghandleEnd", ""];
const _c18 = [3, "resize"];
const _c19 = ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate"];
const _c20 = ["ticks", ""];
function RangeSliderComponent_ul_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", _c19, _c20);
} if (rf & 2) {
    const ctx_r281 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tickTitle", ctx_r281.title)("vertical", ctx_r281.vertical)("step", ctx_r281.smallStep)("largeStep", ctx_r281.largeStep)("min", ctx_r281.min)("max", ctx_r281.max)("labelTemplate", ctx_r281.labelTemplate == null ? null : ctx_r281.labelTemplate.templateRef);
    ɵngcc0.ɵɵattribute("aria-hidden", true);
} }
const _c21 = function (a0, a1) { return { click: a0, keydown: a1 }; };
var PRESSED = 'k-pressed';
/**
 * Represents the [Kendo UI RangeSlider component for Angular]({% slug overview_rangeslider %}).
 */
var RangeSliderComponent = /** @class */ (function (_super) {
    tslib_1.__extends(RangeSliderComponent, _super);
    function RangeSliderComponent(localization, injector, renderer, ngZone, changeDetector, hostElement) {
        var _this = _super.call(this, localization, injector, renderer, ngZone, changeDetector, hostElement) || this;
        _this.localization = localization;
        _this.injector = injector;
        _this.renderer = renderer;
        _this.ngZone = ngZone;
        _this.changeDetector = changeDetector;
        _this.hostElement = hostElement;
        /**
         * @hidden
         */
        _this.startHandleId = "k-start-handle-" + guid();
        /**
         * @hidden
         */
        _this.endHandleId = "k-end-handle-" + guid();
        /**
         * @hidden
         */
        _this.focusableId = _this.startHandleId;
        _this.handleZIndex = 0;
        _this.activeHandle = 'startHandle';
        _this.focusChangedProgrammatically = false;
        /**
         * @hidden
         */
        _this.onWrapClick = function (args) {
            if (!_this.isDisabled) {
                _this.value = _this.value || [_this.min, _this.min];
                var trackValue = eventValue(args, _this.track.nativeElement, _this.getProps());
                var newRangeValue = void 0;
                var _a = newRangeValue = _this.value, startValue = _a[0], endValue = _a[1];
                if (trackValue <= startValue) {
                    newRangeValue = [trackValue, endValue];
                    _this.activeHandle = 'startHandle';
                }
                else if (startValue < trackValue && trackValue < endValue) {
                    if (trackValue < (startValue + endValue) / 2) {
                        newRangeValue = [trackValue, endValue];
                        _this.activeHandle = 'startHandle';
                    }
                    else {
                        newRangeValue = [startValue, trackValue];
                        _this.activeHandle = 'endHandle';
                    }
                }
                else if (trackValue >= endValue) {
                    newRangeValue = [startValue, trackValue];
                    _this.activeHandle = 'endHandle';
                }
                var activeHandle = _this.activeHandle === 'startHandle' ? _this.draghandleStart : _this.draghandleEnd;
                invokeElementMethod(activeHandle, 'focus');
                _this.changeValue(newRangeValue);
            }
        };
        /**
         * @hidden
         */
        _this.onKeyDown = function (e) {
            _this.value = _this.value || [_this.min, _this.min];
            var options = _this.getProps();
            var max = options.max, min = options.min;
            var handler = _this.keyBinding[e.keyCode];
            if (_this.isDisabled || !handler) {
                return;
            }
            _this.renderer.setStyle(e.target, 'zIndex', ++_this.handleZIndex);
            var startHandleIsActive = isStartHandle(e.target);
            var value = handler(tslib_1.__assign({}, options, { value: startHandleIsActive ? _this.value[0] : _this.value[1] }));
            if (startHandleIsActive) {
                if (value > _this.value[1]) {
                    _this.value[1] = value;
                }
            }
            else {
                if (value < _this.value[0]) {
                    _this.value[0] = value;
                }
            }
            var trimmedValue = trimValue(max, min, value);
            var newValue = startHandleIsActive ? [trimmedValue, _this.value[1]]
                : [_this.value[0], trimmedValue];
            _this.changeValue(newValue);
            e.preventDefault();
        };
        _this.ngChange = function (_) { };
        _this.ngTouched = function () { };
        _this.handleBlur = function () {
            _this.changeDetector.markForCheck();
            _this.focused = false;
            if (hasObservers(_this.onBlur) || requiresZoneOnBlur(_this.control)) {
                _this.ngZone.run(function () {
                    _this.ngTouched();
                    if (!_this.focusChangedProgrammatically) {
                        _this.onBlur.emit();
                    }
                });
            }
        };
        return _this;
    }
    RangeSliderComponent_1 = RangeSliderComponent;
    /**
     * Focuses the RangeSlider.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *     <div>
     *         <button class="k-button" (click)="slider.focus()">Focus</button>
     *     </div>
     *     <kendo-rangeslider #slider></kendo-rangeslider>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    RangeSliderComponent.prototype.focus = function () {
        this.focusChangedProgrammatically = true;
        invokeElementMethod(this.draghandleStart, 'focus');
        this.focusChangedProgrammatically = false;
    };
    /**
     * Blurs the RangeSlider.
     */
    RangeSliderComponent.prototype.blur = function () {
        this.focusChangedProgrammatically = true;
        var activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;
        invokeElementMethod(activeHandle, 'blur');
        this.handleBlur();
        this.focusChangedProgrammatically = false;
    };
    RangeSliderComponent.prototype.ngOnInit = function () {
        if (!this.value) {
            this.value = [this.min, this.max];
        }
        _super.prototype.ngOnInit.call(this);
    };
    RangeSliderComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {
            if (changes.value && changes.value.currentValue) {
                validateValue(changes.value.currentValue);
            }
            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {
                _this.sizeComponent();
            });
        }
    };
    RangeSliderComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (!isDocumentAvailable()) {
            return;
        }
        this.sizeComponent();
        if (this.ticks) {
            this.ticks.tickElements
                .changes
                .subscribe(function () { return _this.sizeComponent(); });
        }
        this.attachElementEventHandlers();
    };
    RangeSliderComponent.prototype.ngOnDestroy = function () {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    };
    /**
     * @hidden
     */
    RangeSliderComponent.prototype.textFor = function (key) {
        return this.localization.get(key);
    };
    Object.defineProperty(RangeSliderComponent.prototype, "valueText", {
        /**
         * @hidden
         */
        get: function () {
            return this.value ? this.value[0] + " - " + this.value[1] : '';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    RangeSliderComponent.prototype.handleDragPress = function (args) {
        if (args.originalEvent) {
            args.originalEvent.preventDefault();
        }
        var target = args.originalEvent.target;
        this.draggedHandle = target;
        this.renderer.setStyle(target, 'zIndex', ++this.handleZIndex);
    };
    /**
     * @hidden
     */
    RangeSliderComponent.prototype.onHandleDrag = function (args) {
        var _this = this;
        this.value = this.value || [this.min, this.min];
        var target = args.originalEvent.target;
        var lastCoords = this.draggedHandle.getBoundingClientRect();
        this.lastHandlePosition = { x: lastCoords.left, y: lastCoords.top };
        this.dragging = { value: true, target: target };
        var left = args.pageX < this.lastHandlePosition.x;
        var right = args.pageX > this.lastHandlePosition.x;
        var up = args.pageY > this.lastHandlePosition.y;
        var moveStartHandle = function () { return _this.changeValue([eventValue(args, _this.track.nativeElement, _this.getProps()), _this.value[1]]); };
        var moveEndHandle = function () { return _this.changeValue([_this.value[0], eventValue(args, _this.track.nativeElement, _this.getProps())]); };
        var moveBothHandles = function () { return _this.changeValue([eventValue(args, _this.track.nativeElement, _this.getProps()), eventValue(args, _this.track.nativeElement, _this.getProps())]); };
        var activeStartHandle = isStartHandle(this.draggedHandle);
        var vertical = this.vertical;
        var horizontal = !vertical;
        var forward = (vertical && up) || (this.reverse ? horizontal && right : horizontal && left);
        // const forward = (this.reverse ? (!this.vertical && !left) : (!this.vertical && left)) || (this.vertical && up);
        if (this.value[0] === this.value[1]) {
            if (forward) {
                activeStartHandle ? moveStartHandle() : moveBothHandles();
            }
            else {
                activeStartHandle ? moveBothHandles() : moveEndHandle();
            }
        }
        else {
            activeStartHandle ? moveStartHandle() : moveEndHandle();
        }
    };
    /**
     * @hidden
     */
    RangeSliderComponent.prototype.onHandleRelease = function (args) {
        this.dragging = { value: false, target: args.originalEvent.target }; //needed for animation
        this.draggedHandle = undefined;
    };
    //ngModel binding
    /**
     * @hidden
     */
    RangeSliderComponent.prototype.writeValue = function (value) {
        validateValue(value);
        this.value = value;
        this.sizeComponent();
    };
    /**
     * @hidden
     */
    RangeSliderComponent.prototype.registerOnChange = function (fn) {
        this.ngChange = fn;
    };
    /**
     * @hidden
     */
    RangeSliderComponent.prototype.registerOnTouched = function (fn) {
        this.ngTouched = fn;
    };
    /**
     * @hidden
     */
    RangeSliderComponent.prototype.changeValue = function (value) {
        var _this = this;
        if (!this.value || !isSameRange(this.value, value)) {
            this.ngZone.run(function () {
                _this.value = value;
                _this.ngChange(value);
                if (_this.value) {
                    _this.valueChange.emit(value);
                }
                _this.sizeComponent();
            });
        }
    };
    /**
     * @hidden
     */
    RangeSliderComponent.prototype.sizeComponent = function () {
        if (!isDocumentAvailable()) {
            return;
        }
        var wrapper = this.wrapper.nativeElement;
        var track = this.track.nativeElement;
        var selectionEl = this.sliderSelection.nativeElement;
        var dragHandleStartEl = this.draghandleStart.nativeElement;
        var dragHandleEndEl = this.draghandleEnd.nativeElement;
        var ticks = this.ticks ? this.ticksContainer.nativeElement : null;
        this.resetStyles([track, selectionEl, dragHandleStartEl, dragHandleEndEl, ticks, this.hostElement.nativeElement]);
        var props = this.getProps();
        var model = new RangeSliderModel(props, wrapper, track, this.renderer);
        model.resizeTrack();
        if (this.ticks) { //for case when tickPlacement: none
            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(function (element) { return element.nativeElement; }));
        }
        model.positionHandle(dragHandleStartEl);
        model.positionHandle(dragHandleEndEl);
        model.positionSelection(dragHandleStartEl, selectionEl);
        if (this.fixedTickWidth) {
            model.resizeWrapper();
        }
    };
    Object.defineProperty(RangeSliderComponent.prototype, "isDisabled", {
        /**
         * @hidden
         */
        get: function () {
            return this.disabled || this.readonly;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the component is empty.
     */
    RangeSliderComponent.prototype.isEmpty = function () {
        return false;
    };
    Object.defineProperty(RangeSliderComponent.prototype, "focused", {
        set: function (value) {
            if (this.isFocused !== value && this.hostElement) {
                this.isFocused = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RangeSliderComponent.prototype, "dragging", {
        set: function (data) {
            if (this.isDragged !== data.value && this.sliderSelection && this.draghandleStart && this.draghandleEnd) {
                var sliderSelection = this.sliderSelection.nativeElement;
                var draghandle = data.target;
                if (data.value) {
                    this.renderer.addClass(sliderSelection, PRESSED);
                    this.renderer.addClass(draghandle, PRESSED);
                }
                else {
                    this.renderer.removeClass(sliderSelection, PRESSED);
                    this.renderer.removeClass(draghandle, PRESSED);
                }
                this.isDragged = data.value;
            }
        },
        enumerable: true,
        configurable: true
    });
    RangeSliderComponent.prototype.getProps = function () {
        return {
            disabled: this.disabled,
            fixedTickWidth: this.fixedTickWidth,
            largeStep: this.largeStep,
            max: this.max,
            min: this.min,
            readonly: this.readonly,
            reverse: this.reverse,
            rtl: this.localizationService.rtl,
            smallStep: this.smallStep,
            value: trimValueRange(this.max, this.min, this.value),
            vertical: this.vertical,
            buttons: false
        };
    };
    RangeSliderComponent.prototype.attachElementEventHandlers = function () {
        var _this = this;
        var hostElement = this.hostElement.nativeElement;
        var tabbing = false;
        var cursorInsideWrapper = false;
        this.ngZone.runOutsideAngular(function () {
            // focusIn and focusOut are relative to the host element
            _this.subscriptions.add(_this.renderer.listen(hostElement, 'focusin', function () {
                if (!_this.isFocused) {
                    _this.ngZone.run(function () {
                        if (!_this.focusChangedProgrammatically) {
                            _this.onFocus.emit();
                        }
                        _this.focused = true;
                    });
                }
            }));
            _this.subscriptions.add(_this.renderer.listen(hostElement, 'focusout', function (args) {
                if (!_this.isFocused) {
                    return;
                }
                if (tabbing) {
                    if (args.relatedTarget !== _this.draghandleStart.nativeElement && args.relatedTarget !== _this.draghandleEnd.nativeElement) {
                        _this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper) {
                        _this.handleBlur();
                    }
                }
            }));
            _this.subscriptions.add(_this.renderer.listen(hostElement, 'mouseenter', function () {
                cursorInsideWrapper = true;
            }));
            _this.subscriptions.add(_this.renderer.listen(hostElement, 'mouseleave', function () {
                cursorInsideWrapper = false;
            }));
            _this.subscriptions.add(_this.renderer.listen(hostElement, 'keydown', function (args) {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
        });
    };
    var RangeSliderComponent_1;
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Array)
    ], RangeSliderComponent.prototype, "value", void 0);
    tslib_1.__decorate([
        ViewChild('draghandleStart', { static: true }),
        tslib_1.__metadata("design:type", ElementRef)
    ], RangeSliderComponent.prototype, "draghandleStart", void 0);
    tslib_1.__decorate([
        ViewChild('draghandleEnd', { static: true }),
        tslib_1.__metadata("design:type", ElementRef)
    ], RangeSliderComponent.prototype, "draghandleEnd", void 0);
    RangeSliderComponent = RangeSliderComponent_1 = tslib_1.__decorate([
        tslib_1.__metadata("design:paramtypes", [LocalizationService,
            Injector,
            Renderer2,
            NgZone,
            ChangeDetectorRef,
            ElementRef])
    ], RangeSliderComponent);
RangeSliderComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: RangeSliderComponent, selectors: [["kendo-rangeslider"]], factory: function RangeSliderComponent_Factory(t) { return new (t || RangeSliderComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(Injector), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, viewQuery: function RangeSliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
        ɵngcc0.ɵɵstaticViewQuery(_c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.draghandleStart = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.draghandleEnd = _t.first);
    } }, inputs: { value: "value" }, exportAs: ["kendoRangeSlider"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.rangeslider' },
            { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return RangeSliderComponent_1; }) },
            { provide: KendoInput, useExisting: forwardRef(function () { return RangeSliderComponent_1; }) }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature()], consts: 14, vars: 29, template: function RangeSliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, _c2);
        ɵngcc0.ɵɵi18nAttributes(1, _c7);
        ɵngcc0.ɵɵelementStart(2, "div", _c8, _c9);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵtemplate(4, RangeSliderComponent_ul_4_Template, 2, 8, "ul", _c10);
        ɵngcc0.ɵɵelementStart(5, "div", _c11, _c12);
        ɵngcc0.ɵɵelement(7, "div", _c13, _c14);
        ɵngcc0.ɵɵelementStart(9, "a", _c15, _c16);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵlistener("kendoPress", function RangeSliderComponent_Template_a_kendoPress_9_listener($event) { return ctx.ifEnabled(ctx.handleDragPress, $event); });
        ɵngcc0.ɵɵlistener("kendoDrag", function RangeSliderComponent_Template_a_kendoDrag_9_listener($event) { return ctx.ifEnabled(ctx.onHandleDrag, $event); });
        ɵngcc0.ɵɵlistener("kendoRelease", function RangeSliderComponent_Template_a_kendoRelease_9_listener($event) { return ctx.ifEnabled(ctx.onHandleRelease, $event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "a", _c15, _c17);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵlistener("kendoPress", function RangeSliderComponent_Template_a_kendoPress_11_listener($event) { return ctx.ifEnabled(ctx.handleDragPress, $event); });
        ɵngcc0.ɵɵlistener("kendoDrag", function RangeSliderComponent_Template_a_kendoDrag_11_listener($event) { return ctx.ifEnabled(ctx.onHandleDrag, $event); });
        ɵngcc0.ɵɵlistener("kendoRelease", function RangeSliderComponent_Template_a_kendoRelease_11_listener($event) { return ctx.ifEnabled(ctx.onHandleRelease, $event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(13, "kendo-resize-sensor", _c18);
        ɵngcc0.ɵɵlistener("resize", function RangeSliderComponent_Template_kendo_resize_sensor_resize_13_listener($event) { return ctx.sizeComponent(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵclassProp("k-slider-topleft", ctx.tickPlacement === "before");
        ɵngcc0.ɵɵclassProp("k-slider-bottomright", ctx.tickPlacement === "after");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(26, _c21, ctx.onWrapClick, ctx.onKeyDown));
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tickPlacement !== "none");
        ɵngcc0.ɵɵselect(9);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵproperty("id", ctx.startHandleId)("title", ctx.textFor("dragHandleStart"));
        ɵngcc0.ɵɵattribute("tabindex", ctx.disabled ? undefined : ctx.tabindex)("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value ? ctx.value[0] : null)("aria-valuetext", ctx.valueText)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
        ɵngcc0.ɵɵselect(11);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵproperty("id", ctx.endHandleId)("title", ctx.textFor("dragHandleEnd"));
        ɵngcc0.ɵɵattribute("tabindex", ctx.disabled ? undefined : ctx.tabindex)("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value ? ctx.value[1] : null)("aria-valuetext", ctx.valueText)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
    } }, directives: [ɵngcc1.LocalizedRangeSliderMessagesDirective, ɵngcc2.EventsOutsideAngularDirective, ɵngcc3.NgIf, ɵngcc2.DraggableDirective, ɵngcc2.ResizeSensorComponent, ɵngcc4.SliderTicksComponent], encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(RangeSliderComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoRangeSlider',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.rangeslider' },
                    { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return RangeSliderComponent_1; }) },
                    { provide: KendoInput, useExisting: forwardRef(function () { return RangeSliderComponent_1; }) }
                ],
                selector: 'kendo-rangeslider',
                template: "\n        <ng-container kendoSliderLocalizedMessages\n            i18n-dragHandleStart=\"kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider.\"\n            dragHandleStart=\"Drag\"\n            i18n-dragHandleEnd=\"kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider.\"\n            dragHandleEnd=\"Drag\"\n        >\n\n        <div class=\"k-slider-wrap\" #wrap\n            [class.k-slider-topleft]=\"tickPlacement === 'before'\"\n            [class.k-slider-bottomright]=\"tickPlacement === 'after'\"\n            [kendoEventsOutsideAngular]=\"{ click: onWrapClick, keydown: onKeyDown }\"\n            >\n            <ul kendoSliderTicks\n                #ticks\n                *ngIf=\"tickPlacement !== 'none'\"\n                [tickTitle]=\"title\"\n                [vertical]=\"vertical\"\n                [step]=\"smallStep\"\n                [largeStep]=\"largeStep\"\n                [min]=\"min\"\n                [max]=\"max\"\n                [labelTemplate]=\"labelTemplate?.templateRef\"\n                [attr.aria-hidden]=\"true\"\n            >\n            </ul>\n            <div #track class=\"k-slider-track\">\n                <div #sliderSelection class=\"k-slider-selection\">\n                </div>\n                <a #draghandleStart\n                    role=\"slider\"\n                    [id]=\"startHandleId\"\n                    [attr.tabindex]=\"disabled ? undefined : tabindex\"\n                    [attr.aria-valuemin]=\"min\"\n                    [attr.aria-valuemax]=\"max\"\n                    [attr.aria-valuenow]=\"value ? value[0] : null\"\n                    [attr.aria-valuetext]=\"valueText\"\n                    [attr.aria-disabled]=\"disabled ? true : undefined\"\n                    [attr.aria-readonly]=\"readonly ? true : undefined\"\n                    [attr.aria-orientation]=\"vertical ? 'vertical' : 'horizontal'\"\n                    [style.touch-action]=\"isDisabled ? '' : 'none'\"\n                    class=\"k-draghandle\"\n                    [title]=\"textFor('dragHandleStart')\"\n                    kendoDraggable\n                    (kendoPress)=\"ifEnabled(handleDragPress ,$event)\"\n                    (kendoDrag)=\"ifEnabled(onHandleDrag ,$event)\"\n                    (kendoRelease)=\"ifEnabled(onHandleRelease, $event)\"\n                ></a>\n                <a #draghandleEnd\n                    role=\"slider\"\n                    [id]=\"endHandleId\"\n                    [attr.tabindex]=\"disabled ? undefined : tabindex\"\n                    [attr.aria-valuemin]=\"min\"\n                    [attr.aria-valuemax]=\"max\"\n                    [attr.aria-valuenow]=\"value ? value[1] : null\"\n                    [attr.aria-valuetext]=\"valueText\"\n                    [attr.aria-disabled]=\"disabled ? true : undefined\"\n                    [attr.aria-readonly]=\"readonly ? true : undefined\"\n                    [attr.aria-orientation]=\"vertical ? 'vertical' : 'horizontal'\"\n                    [style.touch-action]=\"isDisabled ? '' : 'none'\"\n                    class=\"k-draghandle\"\n                    [title]=\"textFor('dragHandleEnd')\"\n                    kendoDraggable\n                    (kendoPress)=\"ifEnabled(handleDragPress ,$event)\"\n                    (kendoDrag)=\"ifEnabled(onHandleDrag ,$event)\"\n                    (kendoRelease)=\"ifEnabled(onHandleRelease, $event)\"\n                ></a>\n            </div>\n\n            <kendo-resize-sensor (resize)=\"sizeComponent()\"></kendo-resize-sensor>\n        </div>\n  "
            }]
    }], function () { return [{ type: LocalizationService }, { type: Injector }, { type: Renderer2 }, { type: NgZone }, { type: ChangeDetectorRef }, { type: ElementRef }]; }, { focus: [], focusChangedProgrammatically: [], blur: [], ngOnInit: [], value: [{
            type: Input
        }], ngOnChanges: [], ngAfterViewInit: [], ngOnDestroy: [], textFor: [], valueText: [], handleDragPress: [], draggedHandle: [], onHandleDrag: [], lastHandlePosition: [], dragging: [], onHandleRelease: [], writeValue: [], registerOnChange: [], ngChange: [], registerOnTouched: [], ngTouched: [], changeValue: [], sizeComponent: [], isDisabled: [], isEmpty: [], focused: [], getProps: [], attachElementEventHandlers: [], draghandleStart: [{
            type: ViewChild,
            args: ['draghandleStart', { static: true }]
        }], draghandleEnd: [{
            type: ViewChild,
            args: ['draghandleEnd', { static: true }]
        }] });
    return RangeSliderComponent;
}(SliderBase));
export { RangeSliderComponent };

//# sourceMappingURL=rangeslider.component.js.map