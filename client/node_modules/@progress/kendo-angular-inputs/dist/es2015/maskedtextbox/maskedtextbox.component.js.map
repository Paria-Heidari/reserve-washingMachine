{"version":3,"file":"maskedtextbox.component.js","sources":["/Users/paria/workspace/washIt/client/node_modules/@progress/kendo-angular-inputs/dist/es2015/maskedtextbox/maskedtextbox.component.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as tslib_1 from \"tslib\";\nvar MaskedTextBoxComponent_1;\nimport { Component, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Input, Optional, Output, Renderer2, ViewChild, forwardRef, NgZone, Injector, isDevMode, ChangeDetectorRef } from '@angular/core';\nimport { NG_VALIDATORS, NG_VALUE_ACCESSOR, NgControl } from '@angular/forms';\nimport { RTL } from '@progress/kendo-angular-l10n';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { packageMetadata } from '../package-metadata';\nimport { MaskingService } from './masking.service';\nimport { isChanged, anyChanged, guid, hasObservers, KendoInput } from '@progress/kendo-angular-common';\nimport { invokeElementMethod } from '../common/dom-utils';\nimport { requiresZoneOnBlur, isPresent } from '../common/utils';\nconst resolvedPromise = Promise.resolve(null);\nconst FOCUSED = 'k-state-focused';\n/**\n * Represents the [Kendo UI MaskedTextBox component for Angular]({% slug overview_maskedtextbox %}).\n *\n * @example\n * ```ts-no-run\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *      <kendo-maskedtextbox\n *          [mask]=\"mask\"\n *          [value]=\"value\">\n *      </kendo-maskedtextbox>\n *     `\n * })\n *\n * class AppComponent {\n *  public value: string = \"9580128055807792\";\n *  public mask: string = \"0000-0000-0000-0000\";\n * }\n * ```\n */\nlet MaskedTextBoxComponent = MaskedTextBoxComponent_1 = class MaskedTextBoxComponent {\n    constructor(service, renderer, hostElement, ngZone, injector, changeDetector, rtl) {\n        this.service = service;\n        this.renderer = renderer;\n        this.hostElement = hostElement;\n        this.ngZone = ngZone;\n        this.injector = injector;\n        this.changeDetector = changeDetector;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Determines whether the MaskedTextBox is disabled ([see example]({% slug disabled_maskedtextbox %})).\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the MaskedTextBox is in its read-only state ([see example]({% slug readonly_maskedtextbox %})).\n         */\n        this.readonly = false;\n        this.hostClasses = true;\n        /**\n         * Represents a prompt character for the masked value.\n         * @default `_`\n         */\n        this.prompt = '_';\n        /**\n         * Indicates a character which represents an empty position in the raw value.\n         * @default ' '\n         */\n        this.promptPlaceholder = ' ';\n        /**\n         * Indicates whether to include literals in the raw value  ([see example]({% slug value_maskedtextbox %})).\n         * @default false\n         */\n        this.includeLiterals = false;\n        /**\n         * Specifies if the mask should be shown on focus for empty value.\n         */\n        this.maskOnFocus = false;\n        /**\n         * Determines whether the built-in mask validator is enforced when a form is validated\n         * ([see example]({% slug validation_maskedtextbox %})).\n         * @default true\n         */\n        this.maskValidation = true;\n        /**\n         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Fires each time the user focuses the `input` element.\n         *\n         * > To wire the event programmatically, use the `onFocus` property.\n         *\n         * @example\n         * ```ts-no-run\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-maskedtextbox (focus)=\"handleFocus()\"></kendo-maskedtextbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleFocus(): void {\n         *      console.log(\"Component is focused\");\n         *   }\n         * }\n         * ```\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the `input` element gets blurred.\n         *\n         * > To wire the event programmatically, use the `onBlur` property.\n         *\n         * @example\n         * ```ts-no-run\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-maskedtextbox (blur)=\"handleBlur()\"></kendo-maskedtextbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleBlur(): void {\n         *      console.log(\"Component is blurred\");\n         *   }\n         * }\n         * ```\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the value changes.\n         */\n        this.valueChange = new EventEmitter();\n        this.focusClick = false;\n        this.defaultRules = {\n            \"#\": /[\\d\\s\\+\\-]/,\n            \"&\": /[\\S]/,\n            \"0\": /[\\d]/,\n            \"9\": /[\\d\\s]/,\n            \"?\": /[a-zA-Z\\s]/,\n            \"A\": /[a-zA-Z0-9]/,\n            \"C\": /./,\n            \"L\": /[a-zA-Z]/,\n            \"a\": /[a-zA-Z0-9\\s]/\n        };\n        this.isPasted = false;\n        this.selection = [0, 0];\n        /**\n         * @hidden\n         */\n        this.handleFocus = () => {\n            this.focused = true;\n            if (this.maskOnFocus && this.emptyMask) {\n                this.updateInput(this.service.maskRaw(this.value));\n                this.ngZone.runOutsideAngular(() => {\n                    setTimeout(() => { this.setSelection(0, 0); }, 0);\n                });\n            }\n            if (hasObservers(this.onFocus)) {\n                this.ngZone.run(() => {\n                    this.onFocus.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleClick = () => {\n            if (this.focused && !this.focusClick) {\n                this.focusClick = true;\n                const { selectionStart, selectionEnd } = this.input.nativeElement;\n                if (selectionStart === selectionEnd) {\n                    this.setFocusSelection();\n                }\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleBlur = () => {\n            this.changeDetector.markForCheck();\n            this.focused = false;\n            this.focusClick = false;\n            if (this.maskOnFocus && this.emptyMask) {\n                this.updateInput(this.maskedValue);\n            }\n            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.onTouched();\n                    this.onBlur.emit();\n                });\n            }\n        };\n        this.onChange = (_) => { };\n        this.onTouched = () => { };\n        validatePackage(packageMetadata);\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.updateService();\n    }\n    get hostDisabledClass() {\n        return this.disabled;\n    }\n    /**\n     * Exposes the RegExp-based mask validation array ([see example]({% slug masks_maskedtextbox %})).\n     */\n    get rules() {\n        return this._rules || this.defaultRules;\n    }\n    set rules(value) {\n        this._rules = Object.assign({}, this.defaultRules, value);\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    ngOnInit() {\n        if (this.hostElement) {\n            this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n        }\n        this.control = this.injector.get(NgControl, null);\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the MaskedTextBox is empty.\n     */\n    isEmpty() {\n        if (this.input) {\n            return !Boolean(this.input.nativeElement.value);\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleDragDrop() {\n        return false;\n    }\n    /**\n     * Focuses the MaskedTextBox.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"maskedinput.focus()\">Focus the input</button>\n     *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.input) {\n            return;\n        }\n        this.input.nativeElement.focus();\n        this.setFocusSelection();\n    }\n    /**\n     * Blurs the MaskedTextBox.\n     */\n    blur() {\n        if (!this.input) {\n            return;\n        }\n        this.input.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     */\n    pasteHandler(e) {\n        const { selectionStart, selectionEnd } = e.target;\n        if (selectionEnd === selectionStart) {\n            return;\n        }\n        this.isPasted = true;\n        this.selection = [selectionStart, selectionEnd];\n    }\n    /**\n     * @hidden\n     */\n    inputHandler(e) {\n        const value = e.target.value;\n        const [start, end] = this.selection;\n        if (!this.mask) {\n            this.updateValue(value);\n            this.isPasted = false;\n            return;\n        }\n        let result;\n        if (this.isPasted) {\n            this.isPasted = false;\n            const rightPart = this.maskedValue.length - end;\n            const to = value.length - rightPart;\n            result = this.service.maskInRange(value.slice(start, to), this.maskedValue, start, end);\n        }\n        else {\n            result = this.service.maskInput(value, this.maskedValue, e.target.selectionStart);\n        }\n        this.updateInput(result.value, result.selection);\n        this.updateValue(result.value);\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n        if (changes.value) {\n            this.value = this.normalizeValue();\n        }\n        if (!this.mask) {\n            this.updateInput(this.value);\n            return;\n        }\n        const next = this.extractChanges(changes);\n        this.updateService(next);\n        if (isChanged('value', changes)) {\n            const maskedValue = this.service.maskRaw(this.value);\n            if (maskedValue !== this.maskedValue) {\n                this.updateInput(maskedValue);\n            }\n        }\n        else if (anyChanged(['promptPlaceholder', 'includeLiterals'], changes)) {\n            resolvedPromise.then(() => {\n                this.updateValue(this.maskedValue);\n            });\n        }\n        else {\n            this.updateInput(this.service.maskRaw(this.value));\n        }\n    }\n    /**\n     * @hidden\n     * Writes a new value to the element.\n     */\n    writeValue(value) {\n        this.value = this.normalizeValue(value);\n        this.updateInput(this.service.maskRaw(this.value));\n    }\n    /**\n     * @hidden\n     * Sets the function that will be called when a `change` event is triggered.\n     */\n    registerOnChange(fn) {\n        this.onChange = fn;\n    }\n    /**\n     * @hidden\n     * Sets the function that will be called when a `touch` event is triggered.\n     */\n    registerOnTouched(fn) {\n        this.onTouched = fn;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n        this.changeDetector.markForCheck();\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    validate(_) {\n        if (this.maskValidation === false || !this.mask) {\n            return null;\n        }\n        if (!this.service.validationValue(this.maskedValue)) {\n            return null;\n        }\n        if (this.maskedValue.indexOf(this.prompt) !== -1) {\n            return {\n                patternError: {\n                    mask: this.mask,\n                    maskedValue: this.maskedValue,\n                    value: this.value\n                }\n            };\n        }\n        return null;\n    }\n    /**\n     * @hidden\n     */\n    updateValue(maskedValue) {\n        if (this.mask && !this.service.validationValue(maskedValue)) {\n            this.value = '';\n        }\n        else {\n            this.value = this.service.rawValue(maskedValue);\n        }\n        this.onChange(this.value);\n        this.valueChange.emit(this.value);\n    }\n    updateInput(maskedValue = '', selection) {\n        this.maskedValue = maskedValue;\n        const value = this.maskOnFocus && !this.focused && this.emptyMask ? '' : maskedValue;\n        this.renderer.setProperty(this.input.nativeElement, \"value\", value);\n        if (selection !== undefined) {\n            this.setSelection(selection, selection);\n        }\n    }\n    extractChanges(changes) {\n        return Object.keys(changes).filter(key => key !== 'rules').reduce((obj, key) => {\n            obj[key] = changes[key].currentValue;\n            return obj;\n        }, {}); // tslint:disable-line:align\n    }\n    updateService(extra) {\n        const config = Object.assign({\n            includeLiterals: this.includeLiterals,\n            mask: this.mask,\n            prompt: this.prompt,\n            promptPlaceholder: this.promptPlaceholder,\n            rules: this.rules\n        }, extra); // tslint:disable-line:align\n        this.service.update(config);\n    }\n    setSelection(start = this.selection[0], end = this.selection[1]) {\n        if (this.focused) {\n            invokeElementMethod(this.input, 'setSelectionRange', start, end);\n        }\n    }\n    get emptyMask() {\n        return this.service.maskRaw() === this.maskedValue;\n    }\n    setFocusSelection() {\n        const selectionStart = this.input.nativeElement.selectionStart;\n        const index = this.maskedValue ? this.maskedValue.indexOf(this.prompt) : 0;\n        if (index >= 0 && index < selectionStart) {\n            this.selection = [index, index];\n            this.setSelection();\n        }\n    }\n    get focused() {\n        return this.isFocused;\n    }\n    set focused(value) {\n        if (this.isFocused !== value && this.hostElement) {\n            const element = this.hostElement.nativeElement;\n            if (value) {\n                this.renderer.addClass(element, FOCUSED);\n            }\n            else {\n                this.renderer.removeClass(element, FOCUSED);\n            }\n            this.isFocused = value;\n        }\n    }\n    normalizeValue(value = this.value) {\n        const present = isPresent(value);\n        if (present && typeof value !== 'string') {\n            if (isDevMode()) {\n                throw new Error('The MaskedTextBox component supports only string values.');\n            }\n            return String(value);\n        }\n        return present ? value : '';\n    }\n};\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"focusableId\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], MaskedTextBoxComponent.prototype, \"disabled\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], MaskedTextBoxComponent.prototype, \"readonly\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"title\", void 0);\ntslib_1.__decorate([\n    HostBinding('attr.dir'),\n    tslib_1.__metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"direction\", void 0);\ntslib_1.__decorate([\n    HostBinding('class.k-widget'),\n    HostBinding('class.k-maskedtextbox'),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], MaskedTextBoxComponent.prototype, \"hostClasses\", void 0);\ntslib_1.__decorate([\n    HostBinding('class.k-state-disabled'),\n    tslib_1.__metadata(\"design:type\", Boolean),\n    tslib_1.__metadata(\"design:paramtypes\", [])\n], MaskedTextBoxComponent.prototype, \"hostDisabledClass\", null);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"mask\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"value\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Object),\n    tslib_1.__metadata(\"design:paramtypes\", [Object])\n], MaskedTextBoxComponent.prototype, \"rules\", null);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"prompt\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"promptPlaceholder\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], MaskedTextBoxComponent.prototype, \"includeLiterals\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], MaskedTextBoxComponent.prototype, \"maskOnFocus\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], MaskedTextBoxComponent.prototype, \"maskValidation\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Number)\n], MaskedTextBoxComponent.prototype, \"tabindex\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Number),\n    tslib_1.__metadata(\"design:paramtypes\", [Number])\n], MaskedTextBoxComponent.prototype, \"tabIndex\", null);\ntslib_1.__decorate([\n    Output('focus'),\n    tslib_1.__metadata(\"design:type\", EventEmitter)\n], MaskedTextBoxComponent.prototype, \"onFocus\", void 0);\ntslib_1.__decorate([\n    Output('blur'),\n    tslib_1.__metadata(\"design:type\", EventEmitter)\n], MaskedTextBoxComponent.prototype, \"onBlur\", void 0);\ntslib_1.__decorate([\n    Output(),\n    tslib_1.__metadata(\"design:type\", EventEmitter)\n], MaskedTextBoxComponent.prototype, \"valueChange\", void 0);\ntslib_1.__decorate([\n    ViewChild('input', { static: true }),\n    tslib_1.__metadata(\"design:type\", ElementRef)\n], MaskedTextBoxComponent.prototype, \"input\", void 0);\ntslib_1.__decorate([\n    HostListener('paste', ['$event']),\n    tslib_1.__metadata(\"design:type\", Function),\n    tslib_1.__metadata(\"design:paramtypes\", [Object]),\n    tslib_1.__metadata(\"design:returntype\", void 0)\n], MaskedTextBoxComponent.prototype, \"pasteHandler\", null);\ntslib_1.__decorate([\n    HostListener('input', ['$event']),\n    tslib_1.__metadata(\"design:type\", Function),\n    tslib_1.__metadata(\"design:paramtypes\", [Object]),\n    tslib_1.__metadata(\"design:returntype\", void 0)\n], MaskedTextBoxComponent.prototype, \"inputHandler\", null);\nMaskedTextBoxComponent = MaskedTextBoxComponent_1 = tslib_1.__decorate([\n    Component({\n        exportAs: 'kendoMaskedTextBox',\n        providers: [\n            MaskingService,\n            {\n                multi: true,\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => MaskedTextBoxComponent_1) /* tslint:disable-line */\n            },\n            {\n                multi: true,\n                provide: NG_VALIDATORS,\n                useExisting: forwardRef(() => MaskedTextBoxComponent_1) /* tslint:disable-line */\n            },\n            {\n                provide: KendoInput,\n                useExisting: forwardRef(() => MaskedTextBoxComponent_1)\n            }\n        ],\n        selector: 'kendo-maskedtextbox',\n        template: `\n        <input type=\"text\"\n            #input\n            autocomplete=\"off\"\n            autocorrect=\"off\"\n            autocapitalize=\"off\"\n            spellcheck=\"false\"\n            class=\"k-textbox\"\n            [id]=\"focusableId\"\n            [tabindex]=\"tabIndex\"\n            [attr.title]=\"title\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [kendoEventsOutsideAngular]=\"{\n                focus: handleFocus,\n                blur: handleBlur,\n                click: handleClick,\n                dragstart: handleDragDrop,\n                drop: handleDragDrop\n            }\"\n        />\n    `\n    }),\n    tslib_1.__param(6, Optional()), tslib_1.__param(6, Inject(RTL)),\n    tslib_1.__metadata(\"design:paramtypes\", [MaskingService,\n        Renderer2,\n        ElementRef,\n        NgZone,\n        Injector,\n        ChangeDetectorRef, Boolean])\n], MaskedTextBoxComponent);\nexport { MaskedTextBoxComponent };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAgdC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wEAqGuE,AA2CjE;;;;;;;;;;"}