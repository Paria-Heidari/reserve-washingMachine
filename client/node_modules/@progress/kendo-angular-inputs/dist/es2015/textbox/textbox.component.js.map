{"version":3,"file":"textbox.component.js","sources":["/Users/paria/workspace/washIt/client/node_modules/@progress/kendo-angular-inputs/dist/es2015/textbox/textbox.component.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as tslib_1 from \"tslib\";\nvar TextBoxComponent_1;\nimport { isJapanese } from './../shared/utils';\nimport { closest } from './../common/dom-utils';\nimport { NG_VALUE_ACCESSOR, NgControl } from '@angular/forms';\nimport { Component, ElementRef, forwardRef, Input, Output, EventEmitter, HostBinding, ViewChild, NgZone, ChangeDetectorRef, Injector, ContentChild, Renderer2 } from '@angular/core';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { packageMetadata } from '../package-metadata';\nimport { invokeElementMethod } from '../common/dom-utils';\nimport { areSame, requiresZoneOnBlur } from '../common/utils';\nimport { guid, hasObservers, KendoInput, Keys } from '@progress/kendo-angular-common';\nimport { TextBoxSuffixTemplateDirective } from './textbox-suffix.directive';\nimport { TextBoxPrefixTemplateDirective } from './textbox-prefix.directive';\nimport { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { isSafari } from '../shared/utils';\nconst FOCUSED = 'k-state-focused';\nlet TextBoxComponent = TextBoxComponent_1 = class TextBoxComponent {\n    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {\n        this.localizationService = localizationService;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.renderer = renderer;\n        this.injector = injector;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Sets the `title` attribute of the `input` element of the TextBox.\n         */\n        this.title = '';\n        /**\n         * Sets the disabled state of the component.\n         *\n         * @default false\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the component.\n         *\n         * @default false\n         */\n        this.readonly = false;\n        /**\n         * Specifies the `tabindex` of the TextBox.\n         *\n         * @default 0\n         */\n        this.tabindex = 0;\n        /**\n         * Provides a value for the TextBox.\n         */\n        this.value = null;\n        /**\n         * Determines whether the whole value will be selected when the TextBox is clicked. Defaults to `false`.\n         *\n         * @default false\n         */\n        this.selectOnFocus = false;\n        /**\n         * Specifies when the Success icon will be shown ([see example]({% slug validation_textbox %})).\n         *\n         * The possible values are:\n         *\n         * `boolean`&mdash;The Success icon is displayed, if the condition given by the developer is met.\n         *\n         * `initial`&mdash;The Success icon will be displayed when the component state is neither `invalid` nor `touched` or `dirty`.\n         *\n         * @default false\n         */\n        this.showSuccessIcon = false;\n        /**\n         * Specifies when the Error icon will be shown ([see example]({% slug validation_textbox %})).\n         *\n         * The possible values are:\n         *\n         * * `initial`&mdash;The Error icon will be displayed when the component state is\n         * `invalid` and `touched` or `dirty`.\n         * * `boolean`&mdash;The Error icon is displayed, if the condition given by the developer is met.\n         *\n         * @default false\n         */\n        this.showErrorIcon = false;\n        /**\n         * Specifies whether a Clear button will be rendered.\n         *\n         * @default false\n         */\n        this.clearButton = false;\n        /**\n         * Fires each time the value is changed&mdash;\n         * when the component is blurred or the value is cleared through the **Clear** button\n         * ([see example]({% slug overview_textbox %}#toc-events)).\n         * When the value of the component is programmatically changed to `ngModel` or `formControl`\n         * through its API or form binding, the `valueChange` event is not triggered because it\n         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user focuses the `input` element.\n         */\n        this.inputFocus = new EventEmitter();\n        /**\n         * Fires each time the `input` element gets blurred.\n         */\n        this.inputBlur = new EventEmitter();\n        /**\n         * Fires each time the user focuses the TextBox component.\n         *\n         * > To wire the event programmatically, use the `onFocus` property.\n         *\n         * @example\n         * ```ts-no-run\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-textbox (focus)=\"handleFocus()\"></kendo-textbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleFocus(): void {\n         *      console.log('Component is isFocused');\n         *   }\n         * }\n         * ```\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * Fires each time the TextBox component gets blurred.\n         *\n         * > To wire the event programmatically, use the `onBlur` property.\n         *\n         * @example\n         * ```ts-no-run\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-textbox (blur)=\"handleBlur()\"></kendo-textbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleBlur(): void {\n         *      console.log('Component is blurred');\n         *   }\n         * }\n         * ```\n         */\n        this.onBlur = new EventEmitter();\n        this.hostClass = true;\n        this._isFocused = false;\n        this.focusChangedProgrammatically = false;\n        /**\n         * @hidden\n         */\n        this.handleInputFocus = () => {\n            if (!this.disabled) {\n                if (this.selectOnFocus && this.value) {\n                    this.ngZone.run(() => {\n                        setTimeout(() => { this.selectAll(); });\n                    });\n                }\n                if (hasObservers(this.onFocus)) {\n                    if (!this.isFocused) {\n                        this.ngZone.run(() => {\n                            this.onFocus.emit();\n                        });\n                    }\n                }\n                if (hasObservers(this.inputFocus)) {\n                    if (!this.focusChangedProgrammatically || (this.focusChangedProgrammatically && this.clearButtonClicked)) {\n                        this.ngZone.run(() => {\n                            this.inputFocus.emit();\n                        });\n                    }\n                }\n                this.ngZone.run(() => {\n                    this.isFocused = true;\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleInputBlur = () => {\n            this.changeDetector.markForCheck();\n            if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.ngTouched();\n                    this.inputBlur.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleInput = (ev) => {\n            let incomingValue = isSafari(navigator.userAgent) && isJapanese(ev.target.value) ? ev.data : ev.target.value;\n            this.updateValue(incomingValue);\n        };\n        this.ngChange = (_) => { };\n        this.ngTouched = () => { };\n        validatePackage(packageMetadata);\n        this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    get disabledClass() {\n        return this.disabled;\n    }\n    ngOnInit() {\n        this.control = this.injector.get(NgControl, null);\n        this.checkClearButton();\n        this.subscriptions = this.localizationService.changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n    }\n    ngAfterViewInit() {\n        const hostElement = this.hostElement.nativeElement;\n        let cursorInsideWrapper = false;\n        let tabbing = false;\n        this.ngZone.runOutsideAngular(() => {\n            // focusIn and focusOut are relative to the host element\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n                if (!this.isFocused) {\n                    this.ngZone.run(() => {\n                        this.onFocus.emit();\n                        this.isFocused = true;\n                    });\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {\n                if (!this.isFocused) {\n                    return;\n                }\n                if (tabbing) {\n                    const closestTextbox = closest(args.relatedTarget, (element) => element === this.hostElement.nativeElement);\n                    if (!closestTextbox) {\n                        this.handleBlur();\n                    }\n                    tabbing = false;\n                }\n                else {\n                    if (!cursorInsideWrapper && !this.clearButtonClicked) {\n                        this.handleBlur();\n                    }\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n                cursorInsideWrapper = true;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n                cursorInsideWrapper = false;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {\n                if (args.keyCode === Keys.Tab) {\n                    tabbing = true;\n                }\n                else {\n                    tabbing = false;\n                }\n            }));\n        });\n    }\n    ngOnChanges(changes) {\n        if (changes.disabled || changes.readonly || changes.value) {\n            this.checkClearButton();\n        }\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n    }\n    /**\n     * Focuses the TextBox.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"input.focus()\">Focus the input</button>\n     *  <kendo-textbox #input></kendo-textbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.input) {\n            return;\n        }\n        this.focusChangedProgrammatically = true;\n        this.isFocused = true;\n        this.input.nativeElement.focus();\n        this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the TextBox.\n     */\n    blur() {\n        this.focusChangedProgrammatically = true;\n        const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');\n        if (isFocusedElement) {\n            isFocusedElement.blur();\n        }\n        this.isFocused = false;\n        this.focusChangedProgrammatically = false;\n    }\n    /**\n     * @hidden\n     */\n    clearTitle() {\n        return this.localizationService.get('clear');\n    }\n    /**\n     * @hidden\n     */\n    checkClearButton() {\n        this.showClearButton =\n            !this.disabled &&\n                !this.readonly &&\n                this.clearButton &&\n                !!this.value;\n    }\n    /**\n     * @hidden\n     */\n    clearValue(ev) {\n        if (ev) {\n            ev.preventDefault();\n        }\n        this.clearButtonClicked = true;\n        this.input.nativeElement.value = '';\n        this.input.nativeElement.focus();\n        this.updateValue('');\n        this.checkClearButton();\n        this.clearButtonClicked = false;\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.value = value;\n        this.checkClearButton();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n        this.changeDetector.markForCheck();\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    showErrorsInitial() {\n        if (!this.control) {\n            return false;\n        }\n        const { invalid, dirty, touched } = this.control;\n        return invalid && (dirty || touched);\n    }\n    /**\n     * @hidden\n     */\n    showSuccessInitial() {\n        if (!this.control) {\n            return false;\n        }\n        const { valid, dirty, touched } = this.control;\n        return valid && (dirty || touched);\n    }\n    /**\n     * @hidden\n     */\n    get successIconClasses() {\n        return this.successIcon\n            ? `k-text-success ${this.successIcon}`\n            : `k-text-success k-icon k-i-check-outline`;\n    }\n    /**\n     * @hidden\n     */\n    get errorIconClasses() {\n        return this.errorIcon\n            ? `k-text-error ${this.errorIcon}`\n            : `k-text-error k-icon k-i-warning`;\n    }\n    /**\n     * @hidden\n     */\n    get clearButtonClasses() {\n        return this.clearButtonIcon\n            ? this.clearButtonIcon\n            : `k-icon k-i-close-circle`;\n    }\n    /**\n     * @hidden\n     */\n    get hasErrors() {\n        return this.showErrorIcon === 'initial'\n            ? this.showErrorsInitial()\n            : this.showErrorIcon;\n    }\n    /**\n     * @hidden\n     */\n    get isSuccessful() {\n        return this.showSuccessIcon === 'initial'\n            ? this.showSuccessInitial()\n            : this.showSuccessIcon;\n    }\n    setSelection(start, end) {\n        if (this.isFocused) {\n            invokeElementMethod(this.input, 'setSelectionRange', start, end);\n        }\n    }\n    selectAll() {\n        if (this.value) {\n            this.setSelection(0, this.value.length);\n        }\n    }\n    updateValue(value) {\n        if (!areSame(this.value, value)) {\n            this.ngZone.run(() => {\n                this.value = value;\n                this.ngChange(value);\n                this.valueChange.emit(value);\n                this.checkClearButton();\n                this.changeDetector.markForCheck();\n            });\n        }\n    }\n    get isFocused() {\n        return this._isFocused;\n    }\n    set isFocused(value) {\n        if (this._isFocused !== value && this.hostElement) {\n            const element = this.hostElement.nativeElement;\n            if (value && !this.disabled) {\n                this.renderer.addClass(element, FOCUSED);\n            }\n            else {\n                this.renderer.removeClass(element, FOCUSED);\n            }\n            this._isFocused = value;\n        }\n    }\n    handleBlur() {\n        this.ngZone.run(() => {\n            if (!this.focusChangedProgrammatically) {\n                this.onBlur.emit();\n            }\n            this.isFocused = false;\n        });\n    }\n};\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"focusableId\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"title\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], TextBoxComponent.prototype, \"disabled\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], TextBoxComponent.prototype, \"readonly\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Number)\n], TextBoxComponent.prototype, \"tabindex\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"value\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], TextBoxComponent.prototype, \"selectOnFocus\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Object)\n], TextBoxComponent.prototype, \"showSuccessIcon\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Object)\n], TextBoxComponent.prototype, \"showErrorIcon\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], TextBoxComponent.prototype, \"clearButton\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"successIcon\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"errorIcon\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"clearButtonIcon\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Number),\n    tslib_1.__metadata(\"design:paramtypes\", [Number])\n], TextBoxComponent.prototype, \"tabIndex\", null);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"placeholder\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Number)\n], TextBoxComponent.prototype, \"maxlength\", void 0);\ntslib_1.__decorate([\n    Output(),\n    tslib_1.__metadata(\"design:type\", EventEmitter)\n], TextBoxComponent.prototype, \"valueChange\", void 0);\ntslib_1.__decorate([\n    Output(),\n    tslib_1.__metadata(\"design:type\", EventEmitter)\n], TextBoxComponent.prototype, \"inputFocus\", void 0);\ntslib_1.__decorate([\n    Output(),\n    tslib_1.__metadata(\"design:type\", EventEmitter)\n], TextBoxComponent.prototype, \"inputBlur\", void 0);\ntslib_1.__decorate([\n    Output('focus'),\n    tslib_1.__metadata(\"design:type\", EventEmitter)\n], TextBoxComponent.prototype, \"onFocus\", void 0);\ntslib_1.__decorate([\n    Output('blur'),\n    tslib_1.__metadata(\"design:type\", EventEmitter)\n], TextBoxComponent.prototype, \"onBlur\", void 0);\ntslib_1.__decorate([\n    ViewChild('input', { static: true }),\n    tslib_1.__metadata(\"design:type\", ElementRef)\n], TextBoxComponent.prototype, \"input\", void 0);\ntslib_1.__decorate([\n    ContentChild(TextBoxSuffixTemplateDirective, { static: false }),\n    tslib_1.__metadata(\"design:type\", TextBoxSuffixTemplateDirective)\n], TextBoxComponent.prototype, \"suffixTemplate\", void 0);\ntslib_1.__decorate([\n    ContentChild(TextBoxPrefixTemplateDirective, { static: false }),\n    tslib_1.__metadata(\"design:type\", TextBoxPrefixTemplateDirective)\n], TextBoxComponent.prototype, \"prefixTemplate\", void 0);\ntslib_1.__decorate([\n    HostBinding('class.k-state-disabled'),\n    tslib_1.__metadata(\"design:type\", Boolean),\n    tslib_1.__metadata(\"design:paramtypes\", [])\n], TextBoxComponent.prototype, \"disabledClass\", null);\ntslib_1.__decorate([\n    HostBinding('class.k-textbox'),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], TextBoxComponent.prototype, \"hostClass\", void 0);\ntslib_1.__decorate([\n    HostBinding('attr.dir'),\n    tslib_1.__metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"direction\", void 0);\nTextBoxComponent = TextBoxComponent_1 = tslib_1.__decorate([\n    Component({\n        exportAs: 'kendoTextBox',\n        providers: [\n            LocalizationService,\n            { provide: L10N_PREFIX, useValue: 'kendo.textbox' },\n            {\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => TextBoxComponent_1),\n                multi: true\n            },\n            { provide: KendoInput, useExisting: forwardRef(() => TextBoxComponent_1) }\n        ],\n        selector: 'kendo-textbox',\n        template: `\n        <ng-container kendoTextBoxLocalizedMessages\n            i18n-clear=\"kendo.textbox.clear|The title for the **Clear** button in the TextBox.\"\n            clear=\"Clear\">\n        </ng-container>\n        <span class=\"k-input-prefix\">\n            <ng-template\n                *ngIf=\"prefixTemplate\"\n                [ngTemplateOutlet]=\"prefixTemplate?.templateRef\">\n            </ng-template>\n        </span>\n        <input\n            class=\"k-input\"\n            #input\n            [id]=\"focusableId\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [attr.tabindex]=\"disabled ? undefined : tabindex\"\n            [value]=\"value\"\n            [attr.placeholder]=\"placeholder\"\n            [attr.title]=\"title\"\n            [attr.maxlength]=\"maxlength\"\n            [kendoEventsOutsideAngular]=\"{\n                focus: handleInputFocus,\n                blur: handleInputBlur,\n                input: handleInput}\"/>\n        <span class=\"k-input-suffix\">\n            <span *ngIf=\"hasErrors\" [ngClass]=\"errorIconClasses\"></span>\n            <span *ngIf=\"isSuccessful\" [ngClass]=\"successIconClasses\"></span>\n            <span\n                role=\"button\"\n                class=\"k-clear-value\"\n                *ngIf=\"showClearButton\"\n                (click)=\"clearValue()\"\n                (mousedown)=\"$event.preventDefault()\"\n                [tabindex]=\"tabIndex\"\n                [attr.aria-label]=\"clearTitle()\"\n                [title]=\"clearTitle()\"\n                (keydown.enter)=\"clearValue($event)\"\n                (keydown.space)=\"clearValue($event)\"\n                >\n                <span [ngClass]=\"clearButtonClasses\"></span>\n            </span>\n            <ng-template\n                *ngIf=\"suffixTemplate\"\n                [ngTemplateOutlet]=\"suffixTemplate?.templateRef\">\n            </ng-template>\n        </span>\n    `\n    }),\n    tslib_1.__metadata(\"design:paramtypes\", [LocalizationService,\n        NgZone,\n        ChangeDetectorRef,\n        Renderer2,\n        Injector,\n        ElementRef])\n], TextBoxComponent);\nexport { TextBoxComponent };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAgeC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4DA+G2D,AA+DrD;;;;;;;;;"}