{"version":3,"file":"rangeslider.component.js","sources":["/Users/paria/workspace/washIt/client/node_modules/@progress/kendo-angular-inputs/dist/es2015/rangeslider/rangeslider.component.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as tslib_1 from \"tslib\";\nvar RangeSliderComponent_1;\nimport { Renderer2, Component, ElementRef, Input, ViewChild, forwardRef, NgZone, Injector, ChangeDetectorRef } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { take } from 'rxjs/operators';\nimport { trimValue, isSameRange, trimValueRange, validateValue } from '../sliders-common/sliders-util';\nimport { RangeSliderModel } from './rangeslider-model';\nimport { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';\nimport { eventValue, isStartHandle } from '../sliders-common/sliders-util';\nimport { invokeElementMethod } from '../common/dom-utils';\nimport { guid, isDocumentAvailable, Keys, KendoInput, anyChanged, hasObservers } from '@progress/kendo-angular-common';\nimport { requiresZoneOnBlur } from '../common/utils';\nimport { SliderBase } from '../sliders-common/slider-base';\nconst PRESSED = 'k-pressed';\n/**\n * Represents the [Kendo UI RangeSlider component for Angular]({% slug overview_rangeslider %}).\n */\nlet RangeSliderComponent = RangeSliderComponent_1 = class RangeSliderComponent extends SliderBase {\n    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {\n        super(localization, injector, renderer, ngZone, changeDetector, hostElement);\n        this.localization = localization;\n        this.injector = injector;\n        this.renderer = renderer;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.startHandleId = `k-start-handle-${guid()}`;\n        /**\n         * @hidden\n         */\n        this.endHandleId = `k-end-handle-${guid()}`;\n        /**\n         * @hidden\n         */\n        this.focusableId = this.startHandleId;\n        this.handleZIndex = 0;\n        this.activeHandle = 'startHandle';\n        this.focusChangedProgrammatically = false;\n        /**\n         * @hidden\n         */\n        this.onWrapClick = (args) => {\n            if (!this.isDisabled) {\n                this.value = this.value || [this.min, this.min];\n                const trackValue = eventValue(args, this.track.nativeElement, this.getProps());\n                let newRangeValue;\n                const [startValue, endValue] = newRangeValue = this.value;\n                if (trackValue <= startValue) {\n                    newRangeValue = [trackValue, endValue];\n                    this.activeHandle = 'startHandle';\n                }\n                else if (startValue < trackValue && trackValue < endValue) {\n                    if (trackValue < (startValue + endValue) / 2) {\n                        newRangeValue = [trackValue, endValue];\n                        this.activeHandle = 'startHandle';\n                    }\n                    else {\n                        newRangeValue = [startValue, trackValue];\n                        this.activeHandle = 'endHandle';\n                    }\n                }\n                else if (trackValue >= endValue) {\n                    newRangeValue = [startValue, trackValue];\n                    this.activeHandle = 'endHandle';\n                }\n                const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;\n                invokeElementMethod(activeHandle, 'focus');\n                this.changeValue(newRangeValue);\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.onKeyDown = (e) => {\n            this.value = this.value || [this.min, this.min];\n            const options = this.getProps();\n            const { max, min } = options;\n            const handler = this.keyBinding[e.keyCode];\n            if (this.isDisabled || !handler) {\n                return;\n            }\n            this.renderer.setStyle(e.target, 'zIndex', ++this.handleZIndex);\n            const startHandleIsActive = isStartHandle(e.target);\n            const value = handler(Object.assign({}, options, { value: startHandleIsActive ? this.value[0] : this.value[1] }));\n            if (startHandleIsActive) {\n                if (value > this.value[1]) {\n                    this.value[1] = value;\n                }\n            }\n            else {\n                if (value < this.value[0]) {\n                    this.value[0] = value;\n                }\n            }\n            const trimmedValue = trimValue(max, min, value);\n            const newValue = startHandleIsActive ? [trimmedValue, this.value[1]]\n                : [this.value[0], trimmedValue];\n            this.changeValue(newValue);\n            e.preventDefault();\n        };\n        this.ngChange = (_) => { };\n        this.ngTouched = () => { };\n        this.handleBlur = () => {\n            this.changeDetector.markForCheck();\n            this.focused = false;\n            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.ngTouched();\n                    if (!this.focusChangedProgrammatically) {\n                        this.onBlur.emit();\n                    }\n                });\n            }\n        };\n    }\n    /**\n     * Focuses the RangeSlider.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *     <div>\n     *         <button class=\"k-button\" (click)=\"slider.focus()\">Focus</button>\n     *     </div>\n     *     <kendo-rangeslider #slider></kendo-rangeslider>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        this.focusChangedProgrammatically = true;\n        invokeElementMethod(this.draghandleStart, 'focus');\n        this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the RangeSlider.\n     */\n    blur() {\n        this.focusChangedProgrammatically = true;\n        const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;\n        invokeElementMethod(activeHandle, 'blur');\n        this.handleBlur();\n        this.focusChangedProgrammatically = false;\n    }\n    ngOnInit() {\n        if (!this.value) {\n            this.value = [this.min, this.max];\n        }\n        super.ngOnInit();\n    }\n    ngOnChanges(changes) {\n        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {\n            if (changes.value && changes.value.currentValue) {\n                validateValue(changes.value.currentValue);\n            }\n            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n                this.sizeComponent();\n            });\n        }\n    }\n    ngAfterViewInit() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.sizeComponent();\n        if (this.ticks) {\n            this.ticks.tickElements\n                .changes\n                .subscribe(() => this.sizeComponent());\n        }\n        this.attachElementEventHandlers();\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    textFor(key) {\n        return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n    get valueText() {\n        return this.value ? `${this.value[0]} - ${this.value[1]}` : '';\n    }\n    /**\n     * @hidden\n     */\n    handleDragPress(args) {\n        if (args.originalEvent) {\n            args.originalEvent.preventDefault();\n        }\n        const target = args.originalEvent.target;\n        this.draggedHandle = target;\n        this.renderer.setStyle(target, 'zIndex', ++this.handleZIndex);\n    }\n    /**\n     * @hidden\n     */\n    onHandleDrag(args) {\n        this.value = this.value || [this.min, this.min];\n        const target = args.originalEvent.target;\n        const lastCoords = this.draggedHandle.getBoundingClientRect();\n        this.lastHandlePosition = { x: lastCoords.left, y: lastCoords.top };\n        this.dragging = { value: true, target };\n        const left = args.pageX < this.lastHandlePosition.x;\n        const right = args.pageX > this.lastHandlePosition.x;\n        const up = args.pageY > this.lastHandlePosition.y;\n        const moveStartHandle = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), this.value[1]]);\n        const moveEndHandle = () => this.changeValue([this.value[0], eventValue(args, this.track.nativeElement, this.getProps())]);\n        const moveBothHandles = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), eventValue(args, this.track.nativeElement, this.getProps())]);\n        const activeStartHandle = isStartHandle(this.draggedHandle);\n        const vertical = this.vertical;\n        const horizontal = !vertical;\n        const forward = (vertical && up) || (this.reverse ? horizontal && right : horizontal && left);\n        // const forward = (this.reverse ? (!this.vertical && !left) : (!this.vertical && left)) || (this.vertical && up);\n        if (this.value[0] === this.value[1]) {\n            if (forward) {\n                activeStartHandle ? moveStartHandle() : moveBothHandles();\n            }\n            else {\n                activeStartHandle ? moveBothHandles() : moveEndHandle();\n            }\n        }\n        else {\n            activeStartHandle ? moveStartHandle() : moveEndHandle();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onHandleRelease(args) {\n        this.dragging = { value: false, target: args.originalEvent.target }; //needed for animation\n        this.draggedHandle = undefined;\n    }\n    //ngModel binding\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        validateValue(value);\n        this.value = value;\n        this.sizeComponent();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    changeValue(value) {\n        if (!this.value || !isSameRange(this.value, value)) {\n            this.ngZone.run(() => {\n                this.value = value;\n                this.ngChange(value);\n                if (this.value) {\n                    this.valueChange.emit(value);\n                }\n                this.sizeComponent();\n            });\n        }\n    }\n    /**\n     * @hidden\n     */\n    sizeComponent() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        const wrapper = this.wrapper.nativeElement;\n        const track = this.track.nativeElement;\n        const selectionEl = this.sliderSelection.nativeElement;\n        const dragHandleStartEl = this.draghandleStart.nativeElement;\n        const dragHandleEndEl = this.draghandleEnd.nativeElement;\n        const ticks = this.ticks ? this.ticksContainer.nativeElement : null;\n        this.resetStyles([track, selectionEl, dragHandleStartEl, dragHandleEndEl, ticks, this.hostElement.nativeElement]);\n        const props = this.getProps();\n        const model = new RangeSliderModel(props, wrapper, track, this.renderer);\n        model.resizeTrack();\n        if (this.ticks) { //for case when tickPlacement: none\n            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));\n        }\n        model.positionHandle(dragHandleStartEl);\n        model.positionHandle(dragHandleEndEl);\n        model.positionSelection(dragHandleStartEl, selectionEl);\n        if (this.fixedTickWidth) {\n            model.resizeWrapper();\n        }\n    }\n    /**\n     * @hidden\n     */\n    get isDisabled() {\n        return this.disabled || this.readonly;\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    set focused(value) {\n        if (this.isFocused !== value && this.hostElement) {\n            this.isFocused = value;\n        }\n    }\n    set dragging(data) {\n        if (this.isDragged !== data.value && this.sliderSelection && this.draghandleStart && this.draghandleEnd) {\n            const sliderSelection = this.sliderSelection.nativeElement;\n            const draghandle = data.target;\n            if (data.value) {\n                this.renderer.addClass(sliderSelection, PRESSED);\n                this.renderer.addClass(draghandle, PRESSED);\n            }\n            else {\n                this.renderer.removeClass(sliderSelection, PRESSED);\n                this.renderer.removeClass(draghandle, PRESSED);\n            }\n            this.isDragged = data.value;\n        }\n    }\n    getProps() {\n        return {\n            disabled: this.disabled,\n            fixedTickWidth: this.fixedTickWidth,\n            largeStep: this.largeStep,\n            max: this.max,\n            min: this.min,\n            readonly: this.readonly,\n            reverse: this.reverse,\n            rtl: this.localizationService.rtl,\n            smallStep: this.smallStep,\n            value: trimValueRange(this.max, this.min, this.value),\n            vertical: this.vertical,\n            buttons: false\n        };\n    }\n    attachElementEventHandlers() {\n        const hostElement = this.hostElement.nativeElement;\n        let tabbing = false;\n        let cursorInsideWrapper = false;\n        this.ngZone.runOutsideAngular(() => {\n            // focusIn and focusOut are relative to the host element\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n                if (!this.isFocused) {\n                    this.ngZone.run(() => {\n                        if (!this.focusChangedProgrammatically) {\n                            this.onFocus.emit();\n                        }\n                        this.focused = true;\n                    });\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {\n                if (!this.isFocused) {\n                    return;\n                }\n                if (tabbing) {\n                    if (args.relatedTarget !== this.draghandleStart.nativeElement && args.relatedTarget !== this.draghandleEnd.nativeElement) {\n                        this.handleBlur();\n                    }\n                    tabbing = false;\n                }\n                else {\n                    if (!cursorInsideWrapper) {\n                        this.handleBlur();\n                    }\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n                cursorInsideWrapper = true;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n                cursorInsideWrapper = false;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {\n                if (args.keyCode === Keys.Tab) {\n                    tabbing = true;\n                }\n                else {\n                    tabbing = false;\n                }\n            }));\n        });\n    }\n};\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Array)\n], RangeSliderComponent.prototype, \"value\", void 0);\ntslib_1.__decorate([\n    ViewChild('draghandleStart', { static: true }),\n    tslib_1.__metadata(\"design:type\", ElementRef)\n], RangeSliderComponent.prototype, \"draghandleStart\", void 0);\ntslib_1.__decorate([\n    ViewChild('draghandleEnd', { static: true }),\n    tslib_1.__metadata(\"design:type\", ElementRef)\n], RangeSliderComponent.prototype, \"draghandleEnd\", void 0);\nRangeSliderComponent = RangeSliderComponent_1 = tslib_1.__decorate([\n    Component({\n        exportAs: 'kendoRangeSlider',\n        providers: [\n            LocalizationService,\n            { provide: L10N_PREFIX, useValue: 'kendo.rangeslider' },\n            { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => RangeSliderComponent_1) },\n            { provide: KendoInput, useExisting: forwardRef(() => RangeSliderComponent_1) }\n        ],\n        selector: 'kendo-rangeslider',\n        template: `\n        <ng-container kendoSliderLocalizedMessages\n            i18n-dragHandleStart=\"kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider.\"\n            dragHandleStart=\"Drag\"\n            i18n-dragHandleEnd=\"kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider.\"\n            dragHandleEnd=\"Drag\"\n        >\n\n        <div class=\"k-slider-wrap\" #wrap\n            [class.k-slider-topleft]=\"tickPlacement === 'before'\"\n            [class.k-slider-bottomright]=\"tickPlacement === 'after'\"\n            [kendoEventsOutsideAngular]=\"{ click: onWrapClick, keydown: onKeyDown }\"\n            >\n            <ul kendoSliderTicks\n                #ticks\n                *ngIf=\"tickPlacement !== 'none'\"\n                [tickTitle]=\"title\"\n                [vertical]=\"vertical\"\n                [step]=\"smallStep\"\n                [largeStep]=\"largeStep\"\n                [min]=\"min\"\n                [max]=\"max\"\n                [labelTemplate]=\"labelTemplate?.templateRef\"\n                [attr.aria-hidden]=\"true\"\n            >\n            </ul>\n            <div #track class=\"k-slider-track\">\n                <div #sliderSelection class=\"k-slider-selection\">\n                </div>\n                <a #draghandleStart\n                    role=\"slider\"\n                    [id]=\"startHandleId\"\n                    [attr.tabindex]=\"disabled ? undefined : tabindex\"\n                    [attr.aria-valuemin]=\"min\"\n                    [attr.aria-valuemax]=\"max\"\n                    [attr.aria-valuenow]=\"value ? value[0] : null\"\n                    [attr.aria-valuetext]=\"valueText\"\n                    [attr.aria-disabled]=\"disabled ? true : undefined\"\n                    [attr.aria-readonly]=\"readonly ? true : undefined\"\n                    [attr.aria-orientation]=\"vertical ? 'vertical' : 'horizontal'\"\n                    [style.touch-action]=\"isDisabled ? '' : 'none'\"\n                    class=\"k-draghandle\"\n                    [title]=\"textFor('dragHandleStart')\"\n                    kendoDraggable\n                    (kendoPress)=\"ifEnabled(handleDragPress ,$event)\"\n                    (kendoDrag)=\"ifEnabled(onHandleDrag ,$event)\"\n                    (kendoRelease)=\"ifEnabled(onHandleRelease, $event)\"\n                ></a>\n                <a #draghandleEnd\n                    role=\"slider\"\n                    [id]=\"endHandleId\"\n                    [attr.tabindex]=\"disabled ? undefined : tabindex\"\n                    [attr.aria-valuemin]=\"min\"\n                    [attr.aria-valuemax]=\"max\"\n                    [attr.aria-valuenow]=\"value ? value[1] : null\"\n                    [attr.aria-valuetext]=\"valueText\"\n                    [attr.aria-disabled]=\"disabled ? true : undefined\"\n                    [attr.aria-readonly]=\"readonly ? true : undefined\"\n                    [attr.aria-orientation]=\"vertical ? 'vertical' : 'horizontal'\"\n                    [style.touch-action]=\"isDisabled ? '' : 'none'\"\n                    class=\"k-draghandle\"\n                    [title]=\"textFor('dragHandleEnd')\"\n                    kendoDraggable\n                    (kendoPress)=\"ifEnabled(handleDragPress ,$event)\"\n                    (kendoDrag)=\"ifEnabled(onHandleDrag ,$event)\"\n                    (kendoRelease)=\"ifEnabled(onHandleRelease, $event)\"\n                ></a>\n            </div>\n\n            <kendo-resize-sensor (resize)=\"sizeComponent()\"></kendo-resize-sensor>\n        </div>\n  `\n    }),\n    tslib_1.__metadata(\"design:paramtypes\", [LocalizationService,\n        Injector,\n        Renderer2,\n        NgZone,\n        ChangeDetectorRef,\n        ElementRef])\n], RangeSliderComponent);\nexport { RangeSliderComponent };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAoZC;;;;;;;;;;;;;oEAamE,AAkF7D;;;;;;;;;"}