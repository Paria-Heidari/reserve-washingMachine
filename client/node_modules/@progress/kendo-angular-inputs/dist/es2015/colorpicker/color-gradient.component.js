/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import * as ɵngcc0 from '@angular/core';

const _c0 = ["gradientDragHandle"];
const _c1 = ["inputs"];
const _c2 = ["alphaSlider"];
const _c3 = ["gradientWrapper"];
const _c4 = ["kendoColorGradientLocalizedMessages", "", 6, "colorGradientNoColor", "colorGradientHandle", "clearButton", "hueSliderHandle", "opacitySliderHandle", "hexInputPlaceholder", "redInputPlaceholder", "greenInputPlaceholder", "blueInputPlaceholder", "alphaInputPlaceholder", "passContrast", "failContrast", "contrastRatio"];
var I18N_5;
if (ngI18nClosureMode) {
    /**
     * @desc The aria-label applied to the ColorGradient component when the value is empty.
     * @meaning kendo.colorgradient.colorGradientNoColor
     */ 
    const MSG_EXTERNAL_3796155240301823948$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_6 = goog.getMsg("Colorgradient no color chosen");
    I18N_5 = MSG_EXTERNAL_3796155240301823948$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_6;
}
else {
    I18N_5 = ɵngcc0.ɵɵi18nLocalize("Colorgradient no color chosen");
}
var I18N_7;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the gradient color drag handle chooser.
     * @meaning kendo.colorgradient.colorGradientHandle
     */ 
    const MSG_EXTERNAL_8537406358423916512$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_8 = goog.getMsg("Choose color");
    I18N_7 = MSG_EXTERNAL_8537406358423916512$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_8;
}
else {
    I18N_7 = ɵngcc0.ɵɵi18nLocalize("Choose color");
}
var I18N_9;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the clear button.
     * @meaning kendo.colorgradient.clearButton
     */ 
    const MSG_EXTERNAL_7605097752673642325$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_10 = goog.getMsg("Clear value");
    I18N_9 = MSG_EXTERNAL_7605097752673642325$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_10;
}
else {
    I18N_9 = ɵngcc0.ɵɵi18nLocalize("Clear value");
}
var I18N_11;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the hue slider handle.
     * @meaning kendo.colorgradient.hueSliderHandle
     */ 
    const MSG_EXTERNAL_8568799441668530127$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_12 = goog.getMsg("Set hue");
    I18N_11 = MSG_EXTERNAL_8568799441668530127$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_12;
}
else {
    I18N_11 = ɵngcc0.ɵɵi18nLocalize("Set hue");
}
var I18N_13;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the opacity slider handle.
     * @meaning kendo.colorgradient.opacitySliderHandle
     */ 
    const MSG_EXTERNAL_2665102430468067218$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_14 = goog.getMsg("Set opacity");
    I18N_13 = MSG_EXTERNAL_2665102430468067218$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_14;
}
else {
    I18N_13 = ɵngcc0.ɵɵi18nLocalize("Set opacity");
}
var I18N_15;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the HEX color input.
     * @meaning kendo.colorgradient.hexInputPlaceholder
     */ 
    const MSG_EXTERNAL_1551996638068326100$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_16 = goog.getMsg("HEX Color");
    I18N_15 = MSG_EXTERNAL_1551996638068326100$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_16;
}
else {
    I18N_15 = ɵngcc0.ɵɵi18nLocalize("HEX Color");
}
var I18N_17;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the red color input.
     * @meaning kendo.colorgradient.redInputPlaceholder
     */ 
    const MSG_EXTERNAL_865798719701025148$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_18 = goog.getMsg("Red");
    I18N_17 = MSG_EXTERNAL_865798719701025148$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_18;
}
else {
    I18N_17 = ɵngcc0.ɵɵi18nLocalize("Red");
}
var I18N_19;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the green color input.
     * @meaning kendo.colorgradient.greenInputPlaceholder
     */ 
    const MSG_EXTERNAL_7119549617208224702$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_20 = goog.getMsg("Green");
    I18N_19 = MSG_EXTERNAL_7119549617208224702$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_20;
}
else {
    I18N_19 = ɵngcc0.ɵɵi18nLocalize("Green");
}
var I18N_21;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the blue color input.
     * @meaning kendo.colorgradient.blueInputPlaceholder
     */ 
    const MSG_EXTERNAL_8925567330503382499$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_22 = goog.getMsg("Blue");
    I18N_21 = MSG_EXTERNAL_8925567330503382499$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_22;
}
else {
    I18N_21 = ɵngcc0.ɵɵi18nLocalize("Blue");
}
var I18N_23;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the alpha input.
     * @meaning kendo.colorgradient.alphaInputPlaceholder
     */ 
    const MSG_EXTERNAL_6303797935938211585$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_24 = goog.getMsg("Alpha");
    I18N_23 = MSG_EXTERNAL_6303797935938211585$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_24;
}
else {
    I18N_23 = ɵngcc0.ɵɵi18nLocalize("Alpha");
}
var I18N_25;
if (ngI18nClosureMode) {
    /**
     * @desc The pass message for the contrast tool.
     * @meaning kendo.colorgradient.passContrast
     */ 
    const MSG_EXTERNAL_200461871469242251$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_26 = goog.getMsg("Pass");
    I18N_25 = MSG_EXTERNAL_200461871469242251$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_26;
}
else {
    I18N_25 = ɵngcc0.ɵɵi18nLocalize("Pass");
}
var I18N_27;
if (ngI18nClosureMode) {
    /**
     * @desc The fail message for the contrast tool.
     * @meaning kendo.colorgradient.failContrast
     */ 
    const MSG_EXTERNAL_2780397365913372676$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_28 = goog.getMsg("Fail");
    I18N_27 = MSG_EXTERNAL_2780397365913372676$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_28;
}
else {
    I18N_27 = ɵngcc0.ɵɵi18nLocalize("Fail");
}
var I18N_29;
if (ngI18nClosureMode) {
    /**
     * @desc The contrast ratio message for the contrast tool.
     * @meaning kendo.colorgradient.contrastRatio
     */ 
    const MSG_EXTERNAL_713630549826115578$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_30 = goog.getMsg("Contrast ratio");
    I18N_29 = MSG_EXTERNAL_713630549826115578$$DIST_ES2015_COLORPICKER_COLOR_GRADIENT_COMPONENT_JS_30;
}
else {
    I18N_29 = ɵngcc0.ɵɵi18nLocalize("Contrast ratio");
}
const _c31 = ["colorGradientNoColor", I18N_5, "colorGradientHandle", I18N_7, "clearButton", I18N_9, "hueSliderHandle", I18N_11, "opacitySliderHandle", I18N_13, "hexInputPlaceholder", I18N_15, "redInputPlaceholder", I18N_17, "greenInputPlaceholder", I18N_19, "blueInputPlaceholder", I18N_21, "alphaInputPlaceholder", I18N_23, "passContrast", I18N_25, "failContrast", I18N_27, "contrastRatio", I18N_29];
const _c32 = [1, "k-colorgradient-canvas", "k-hstack"];
const _c33 = [1, "k-hsv-rectangle"];
const _c34 = ["kendoDraggable", "", 1, "k-hsv-gradient", 3, "click", "kendoPress", "kendoDrag", "kendoRelease"];
const _c35 = ["gradientWrapper", ""];
const _c36 = ["tabindex", "0", 1, "k-hsv-draghandle", "k-draghandle"];
const _c37 = ["gradientDragHandle", ""];
const _c38 = ["class", "k-clear-color k-button k-flat k-button-icon", "tabindex", "0", 3, "click", "keydown.enter", "keydown.space", 4, "ngIf"];
const _c39 = [1, "k-hue-slider", "k-colorgradient-slider", 3, "ngClass", "dragHandleTitle", "disabled", "readonly", "showButtons", "tickPlacement", "vertical", "min", "max", "smallStep", "largeStep", "value", "valueChange"];
const _c40 = ["class", "k-alpha-slider k-colorgradient-slider", 3, "ngClass", "dragHandleTitle", "disabled", "readonly", "showButtons", "tickPlacement", "vertical", "min", "max", "smallStep", "largeStep", "value", "valueChange", 4, "ngIf"];
const _c41 = [3, "opacity", "formatView", "value", "disabled", "readonly", "valueChange"];
const _c42 = ["inputs", ""];
const _c43 = ["class", "k-colorgradient-color-contrast k-vbox", "kendoContrastTool", "", 3, "value", "ratio", 4, "ngIf"];
const _c44 = ["tabindex", "0", 1, "k-clear-color", "k-button", "k-flat", "k-button-icon", 3, "click", "keydown.enter", "keydown.space"];
const _c45 = [1, "k-icon", "k-i-reset-color"];
function ColorGradientComponent_span_9_Template(rf, ctx) { if (rf & 1) {
    const _r221 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", _c44);
    ɵngcc0.ɵɵlistener("click", function ColorGradientComponent_span_9_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r221); const ctx_r220 = ɵngcc0.ɵɵnextContext(); return ctx_r220.reset(); });
    ɵngcc0.ɵɵlistener("keydown.enter", function ColorGradientComponent_span_9_Template_span_keydown_enter_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r221); const ctx_r222 = ɵngcc0.ɵɵnextContext(); return ctx_r222.reset(); });
    ɵngcc0.ɵɵlistener("keydown.space", function ColorGradientComponent_span_9_Template_span_keydown_space_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r221); const ctx_r223 = ɵngcc0.ɵɵnextContext(); return ctx_r223.reset(); });
    ɵngcc0.ɵɵelement(1, "span", _c45);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r216 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r216.clearButtonTitle)("title", ctx_r216.clearButtonTitle);
} }
const _c46 = [1, "k-alpha-slider", "k-colorgradient-slider", 3, "ngClass", "dragHandleTitle", "disabled", "readonly", "showButtons", "tickPlacement", "vertical", "min", "max", "smallStep", "largeStep", "value", "valueChange"];
const _c47 = ["alphaSlider", ""];
const _c48 = function (a0) { return { "k-align-self-end": a0 }; };
function ColorGradientComponent_kendo_slider_11_Template(rf, ctx) { if (rf & 1) {
    const _r226 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-slider", _c46, _c47);
    ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_kendo_slider_11_Template_kendo_slider_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r226); const ctx_r225 = ɵngcc0.ɵɵnextContext(); return ctx_r225.handleAlphaSliderChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r217 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(12, _c48, ctx_r217.clearButton))("dragHandleTitle", ctx_r217.opacitySliderTitle)("disabled", ctx_r217.disabled)("readonly", ctx_r217.readonly)("showButtons", false)("tickPlacement", "none")("vertical", true)("min", 0)("max", 100)("smallStep", 1)("largeStep", 10)("value", ctx_r217.alphaSliderValue);
} }
const _c49 = ["kendoContrastTool", "", 1, "k-colorgradient-color-contrast", "k-vbox", 3, "value", "ratio"];
function ColorGradientComponent_div_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", _c49);
} if (rf & 2) {
    const ctx_r219 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", ctx_r219.value)("ratio", ctx_r219.contrastTool);
} }
var ColorGradientComponent_1;
import { Component, Input, ViewChild, ElementRef, Renderer2, NgZone, Output, EventEmitter, HostBinding, forwardRef, ChangeDetectorRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { parseColor, getHSV, getColorFromHSV, getColorFromHue } from './utils';
import { isPresent, fitIntoBounds } from '../common/utils';
import { isChanged, isDocumentAvailable, KendoInput } from '@progress/kendo-angular-common';
import { containsFocus, isUntouched } from '../common/dom-utils';
import { SliderComponent } from '../slider/slider.component';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { Subject } from 'rxjs';
import { ColorGradientLocalizationService } from './localization/colorgradient-localization.service';
import { ColorInputComponent } from './color-input.component';
import { throttleTime } from 'rxjs/operators';
import { DEFAULT_GRADIENT_BACKGROUND_COLOR, DEFAULT_OUTPUT_FORMAT, DRAGHANDLE_MOVE_SPEED } from './constants';
let serial = 0;
/**
 * The ColorGradient component enables smooth color transitions and provides options for selecting specific colors over the drag handle.
 * The ColorGradient is independently used by `kendo-colorpicker` and can be directly added to the page.
 */
let ColorGradientComponent = ColorGradientComponent_1 = class ColorGradientComponent {
    constructor(host, ngZone, renderer, cdr, localizationService) {
        this.host = host;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.cdr = cdr;
        this.localizationService = localizationService;
        /**
         * @hidden
         */
        this.hostClasses = true;
        /**
         * @hidden
         */
        this.id = `k-colorgradient-${serial++}`;
        /**
         * Defines whether the alpha slider will be displayed.
         */
        this.opacity = true;
        /**
         * Sets the disabled state of the ColorGradient.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorGradient.
         */
        this.readonly = false;
        /**
         * Specifies whether the ColorGradient should display a 'Clear color' button.
         */
        this.clearButton = false;
        /**
         * Determines the delay time (in milliseconds) before the value is changed on handle drag. A value of 0 indicates no delay.
         *
         * @default 0
         */
        this.delay = 0;
        /**
         * Fires each time the user selects a new color.
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.backgroundColor = DEFAULT_GRADIENT_BACKGROUND_COLOR;
        /**
         * @hidden
         *
         * Represents the currently selected `hue`, `saturation`, `value`, and `alpha` values.
         * The values are initially set in `ngOnInit` or in `ngOnChanges` and are
         * updated on moving the drag handle or the sliders.
         */
        this.hsva = {};
        /**
         * Specifies the output format of the ColorGradientComponent.
         * The input value may be in a different format. However, it will be parsed into the output `format`
         * after the component processes it.
         *
         * The supported values are:
         * * (Default) `rgba`
         * * `hex`
         */
        this.format = DEFAULT_OUTPUT_FORMAT;
        this._tabindex = 0;
        this.listeners = [];
        this.updateValues = new Subject();
        this.notifyNgChanged = () => { };
        this.notifyNgTouched = () => { };
        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    /**
     * @hidden
     */
    get readonlyAttribute() {
        return this.readonly;
    }
    /**
     * @hidden
     */
    get disabledClass() {
        return this.disabled;
    }
    /**
     * @hidden
     */
    get hostTabindex() {
        return this.tabindex;
    }
    /**
     * @hidden
     */
    get gradientId() {
        return this.id;
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor(value, this.format);
    }
    get value() {
        return this._value;
    }
    /**
     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * Indicates whether the ColorGradient or any of its content is focused.
     */
    get isFocused() {
        if (!(isDocumentAvailable() && isPresent(this.host))) {
            return false;
        }
        return this.host.nativeElement === document.activeElement || this.host.nativeElement.contains(document.activeElement);
    }
    /**
     * @hidden
     */
    get alphaSliderValue() {
        // setting the initial value to undefined to force the slider to recalculate the height of the slider track on the next cdr run
        if (!(isPresent(this.hsva) && isPresent(this.hsva.a))) {
            return;
        }
        return this.hsva.a * 100;
    }
    get gradientRect() {
        return this.gradientWrapper.nativeElement.getBoundingClientRect();
    }
    /**
     * @hidden
     */
    get contrastToolVisible() {
        return typeof this.contrastTool === 'string' && this.contrastTool !== '';
    }
    ngAfterViewInit() {
        this.updateUI();
        this.cdr.detectChanges();
        this.addEventListeners();
        this.subscribeChanges();
    }
    ngOnChanges(changes) {
        if (isChanged('value', changes) && !this.isFocused) {
            this.updateUI();
        }
        if (isChanged('delay', changes)) {
            this.unsubscribeChanges();
            this.subscribeChanges();
        }
    }
    ngOnDestroy() {
        this.listeners.forEach(removeListener => removeListener());
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
        this.unsubscribeChanges();
    }
    /**
     * Focuses the component.
     */
    focus() {
        if (this.disabled) {
            return;
        }
        this.host.nativeElement.focus();
    }
    /**
     * @hidden
     */
    reset() {
        this.handleValueChange(undefined);
        this.updateUI();
        this.host.nativeElement.focus();
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (this.disabled || this.readonly || !isPresent(args.originalEvent)) {
            return;
        }
        this.focus();
        args.originalEvent.preventDefault();
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');
        this.changePosition(args);
    }
    /**
     * @hidden
     */
    onHandleRelease() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');
        this.handleValueChange(getColorFromHSV(this.hsva));
    }
    /**
     * @hidden
     */
    onKeyboardAction(args) {
        if (this.disabled || this.readonly) {
            return;
        }
        if (args.key && args.key.indexOf('Arrow') !== -1) {
            args.preventDefault();
            const dragHandleElement = this.gradientDragHandle.nativeElement;
            this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');
            let keyboardMoveX = 0;
            let keyboardMoveY = 0;
            switch (args.key) {
                case 'ArrowRight':
                    keyboardMoveX = DRAGHANDLE_MOVE_SPEED;
                    break;
                case 'ArrowLeft':
                    keyboardMoveX = -DRAGHANDLE_MOVE_SPEED;
                    break;
                case 'ArrowUp':
                    keyboardMoveY = -DRAGHANDLE_MOVE_SPEED;
                    break;
                case 'ArrowDown':
                    keyboardMoveY = DRAGHANDLE_MOVE_SPEED;
                    break;
                default: break;
            }
            const newY = parseInt(dragHandleElement.style.top, 10) + keyboardMoveY;
            const newX = parseInt(dragHandleElement.style.left, 10) + keyboardMoveX;
            this.renderer.setStyle(dragHandleElement, 'top', `${newY}px`);
            this.renderer.setStyle(dragHandleElement, 'left', `${newX}px`);
            this.ngZone.run(() => this.moveDragHandle(newX, newY));
        }
    }
    /**
     * @hidden
     */
    changePosition(position) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.gradientDragHandle.nativeElement.focus();
        const newX = position.clientX - this.gradientRect.left;
        const newY = position.clientY - this.gradientRect.top;
        this.ngZone.run(() => this.moveDragHandle(newX, newY));
    }
    /**
     * @hidden
     */
    handleHueSliderChange(hue) {
        this.handleValueChange(getColorFromHSV(this.hsva));
        this.backgroundColor = getColorFromHue(hue);
        this.setAlphaSliderBackground(this.backgroundColor);
    }
    /**
     * @hidden
     */
    handleAlphaSliderChange(alpha) {
        this.hsva.a = alpha / 100;
        this.handleValueChange(getColorFromHSV(this.hsva));
    }
    /**
     * @hidden
     */
    handleInputsValueChange(color) {
        const parsed = parseColor(color, this.format);
        if (this.value !== parsed) {
            this.handleValueChange(parsed);
            this.updateUI();
        }
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        if (isPresent(this.gradientWrapper)) {
            this.updateUI();
        }
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.cdr.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    get colorGradientHandleTitle() {
        return this.localizationService.get('colorGradientHandle');
    }
    /**
     * @hidden
     */
    get colorGradientHandleAriaLabel() {
        const parsed = parseColor(this.value, this.format);
        return `${this.value ? parsed : this.localizationService.get('colorGradientHandle')}`;
    }
    /**
     * @hidden
     */
    get hueSliderTitle() {
        return this.localizationService.get('hueSliderHandle');
    }
    /**
     * @hidden
     */
    get opacitySliderTitle() {
        return this.localizationService.get('opacitySliderHandle');
    }
    /**
     * @hidden
     */
    get clearButtonTitle() {
        return this.localizationService.get('clearButton');
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    moveDragHandle(positionX, positionY) {
        const top = fitIntoBounds(positionY, 0, this.gradientRect.height);
        const left = fitIntoBounds(positionX, 0, this.gradientRect.width);
        this.setDragHandleElementPosition(top, left);
        this.hsva.s = left / this.gradientRect.width;
        this.hsva.v = 1 - top / this.gradientRect.height;
        this.updateValues.next(getColorFromHSV(this.hsva));
        this.setAlphaSliderBackground(getColorFromHSV(Object.assign({}, this.hsva, { a: 1 })));
    }
    updateUI() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.hsva = this.value ? getHSV(this.value) : { h: 0, s: 0, v: 1, a: 1 };
        const top = (1 - this.hsva.v) * this.gradientRect.height;
        const left = this.hsva.s * this.gradientRect.width;
        this.setDragHandleElementPosition(top, left);
        this.backgroundColor = getColorFromHue(this.hsva.h);
        this.setAlphaSliderBackground(this.backgroundColor);
        this.setHostElementAriaLabel();
    }
    handleValueChange(color) {
        if (this.value === color) {
            return;
        }
        this.value = color;
        this.valueChange.emit(color);
        this.notifyNgChanged(color);
        this.setHostElementAriaLabel();
    }
    setDragHandleElementPosition(top, left) {
        const dragHandle = this.gradientDragHandle.nativeElement;
        this.renderer.setStyle(dragHandle, 'top', `${top}px`);
        this.renderer.setStyle(dragHandle, 'left', `${left}px`);
    }
    setAlphaSliderBackground(backgroundColor) {
        if (!isPresent(this.alphaSlider)) {
            return;
        }
        const sliderTrack = this.alphaSlider.track.nativeElement;
        this.renderer.setStyle(sliderTrack, 'background', `linear-gradient(to top, transparent, ${backgroundColor})`);
    }
    setHostElementAriaLabel() {
        const parsed = parseColor(this.value, this.format);
        this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorGradientNoColor')}`);
    }
    addEventListeners() {
        this.ngZone.runOutsideAngular(() => {
            const focusOutListener = this.renderer.listen(this.host.nativeElement, 'focusout', (event) => {
                if (!containsFocus(this.host.nativeElement, event.relatedTarget) && isUntouched(this.host)) {
                    this.ngZone.run(() => this.notifyNgTouched());
                }
            });
            const keydownListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keydown', (event) => {
                this.onKeyboardAction(event);
            });
            const keyupListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keyup', () => {
                this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');
                if (!this.readonly && !this.disabled) {
                    this.ngZone.run(() => this.handleValueChange(getColorFromHSV(this.hsva)));
                }
            });
            const dragHandleFocusInListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusin', () => {
                this.renderer.addClass(this.gradientDragHandle.nativeElement, 'k-state-focus');
            });
            const dragHandleFocusOutListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusout', () => {
                this.renderer.removeClass(this.gradientDragHandle.nativeElement, 'k-state-focus');
            });
            this.listeners.push(focusOutListener, keydownListener, keyupListener, dragHandleFocusInListener, dragHandleFocusOutListener);
        });
    }
    subscribeChanges() {
        this.changeRequestsSubscription = this.updateValues.pipe(throttleTime(this.delay)).subscribe(value => {
            this.handleValueChange(value);
        });
    }
    unsubscribeChanges() {
        if (this.changeRequestsSubscription) {
            this.changeRequestsSubscription.unsubscribe();
        }
    }
}
ColorGradientComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: ColorGradientComponent, selectors: [["kendo-colorgradient"]], factory: function ColorGradientComponent_Factory(t) { return new (t || ColorGradientComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, viewQuery: function ColorGradientComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c1, true);
        ɵngcc0.ɵɵviewQuery(_c2, true);
        ɵngcc0.ɵɵviewQuery(_c3, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.gradientDragHandle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.inputs = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.alphaSlider = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.gradientWrapper = _t.first);
    } }, hostBindings: function ColorGradientComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(6);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction)("aria-readonly", ctx.readonlyAttribute)("tabindex", ctx.hostTabindex)("id", ctx.gradientId);
        ɵngcc0.ɵɵclassProp("k-colorgradient", ctx.hostClasses);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabledClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { id: "id", opacity: "opacity", disabled: "disabled", readonly: "readonly", clearButton: "clearButton", delay: "delay", format: "format", value: "value", tabindex: "tabindex", contrastTool: "contrastTool" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorGradientComponent_1)
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorGradientComponent_1)
            },
            ColorGradientLocalizationService,
            {
                provide: LocalizationService,
                useExisting: ColorGradientLocalizationService
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorgradient'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], consts: 15, vars: 27, template: function ColorGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, _c4);
        ɵngcc0.ɵɵi18nAttributes(1, _c31);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "div", _c32);
        ɵngcc0.ɵɵelementStart(3, "div", _c33);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵelementStart(4, "div", _c34, _c35);
        ɵngcc0.ɵɵlistener("click", function ColorGradientComponent_Template_div_click_4_listener($event) { return ctx.changePosition($event); });
        ɵngcc0.ɵɵlistener("kendoPress", function ColorGradientComponent_Template_div_kendoPress_4_listener($event) { return ctx.handleDragPress($event); });
        ɵngcc0.ɵɵlistener("kendoDrag", function ColorGradientComponent_Template_div_kendoDrag_4_listener($event) { return ctx.onHandleDrag($event); });
        ɵngcc0.ɵɵlistener("kendoRelease", function ColorGradientComponent_Template_div_kendoRelease_4_listener($event) { return ctx.onHandleRelease(); });
        ɵngcc0.ɵɵelement(6, "div", _c36, _c37);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div");
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵtemplate(9, ColorGradientComponent_span_9_Template, 2, 2, "span", _c38);
        ɵngcc0.ɵɵelementStart(10, "kendo-slider", _c39);
        ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_slider_valueChange_10_listener($event) { return ctx.hsva.h = $event; });
        ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_slider_valueChange_10_listener($event) { return ctx.handleHueSliderChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, ColorGradientComponent_kendo_slider_11_Template, 2, 14, "kendo-slider", _c40);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "kendo-colorinput", _c41, _c42);
        ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_colorinput_valueChange_12_listener($event) { return ctx.handleInputsValueChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(14, ColorGradientComponent_div_14_Template, 1, 2, "div", _c43);
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(3);
        ɵngcc0.ɵɵstyleSanitizer(ɵngcc0.ɵɵdefaultStyleSanitizer);
        ɵngcc0.ɵɵstyleProp("background", ctx.backgroundColor);
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵselect(6);
        ɵngcc0.ɵɵattribute("title", ctx.colorGradientHandleTitle)("aria-label", ctx.colorGradientHandleAriaLabel);
        ɵngcc0.ɵɵselect(8);
        ɵngcc0.ɵɵclassMapInterpolate1("k-hsv-controls k-hstack ", ctx.clearButton ? "k-sliders-wrap-clearable" : "", "");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵselect(9);
        ɵngcc0.ɵɵproperty("ngIf", ctx.clearButton);
        ɵngcc0.ɵɵselect(10);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(25, _c48, ctx.clearButton))("dragHandleTitle", ctx.hueSliderTitle)("disabled", ctx.disabled)("readonly", ctx.readonly)("showButtons", false)("tickPlacement", "none")("vertical", true)("min", 0)("max", 360)("smallStep", 5)("largeStep", 10)("value", ctx.hsva.h);
        ɵngcc0.ɵɵselect(11);
        ɵngcc0.ɵɵproperty("ngIf", ctx.opacity && ctx.format === "rgba");
        ɵngcc0.ɵɵselect(12);
        ɵngcc0.ɵɵproperty("opacity", ctx.opacity)("formatView", ctx.format)("value", ctx.value)("disabled", ctx.disabled)("readonly", ctx.readonly);
        ɵngcc0.ɵɵselect(14);
        ɵngcc0.ɵɵproperty("ngIf", ctx.contrastToolVisible);
    } }, styles: [".k-clear-color[_ngcontent-%COMP%] {\n            position: absolute;\n            left: 50%;\n            transform: translateX(-50%);\n        }\n        .k-align-self-end[_ngcontent-%COMP%] {\n            height: 140px;\n        }"] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ColorGradientComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-colorgradient',
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ColorGradientComponent_1)
                    },
                    {
                        provide: KendoInput,
                        useExisting: forwardRef(() => ColorGradientComponent_1)
                    },
                    ColorGradientLocalizationService,
                    {
                        provide: LocalizationService,
                        useExisting: ColorGradientLocalizationService
                    },
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.colorgradient'
                    }
                ],
                template: `
        <ng-container kendoColorGradientLocalizedMessages
            i18n-colorGradientNoColor="kendo.colorgradient.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorGradientHandle="kendo.colorgradient.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.colorgradient.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.colorgradient.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.colorgradient.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-hexInputPlaceholder="kendo.colorgradient.hexInputPlaceholder|The placeholder for the HEX color input."
            hexInputPlaceholder="HEX Color"
            i18n-redInputPlaceholder="kendo.colorgradient.redInputPlaceholder|The placeholder for the red color input."
            redInputPlaceholder="Red"
            i18n-greenInputPlaceholder="kendo.colorgradient.greenInputPlaceholder|The placeholder for the green color input."
            greenInputPlaceholder="Green"
            i18n-blueInputPlaceholder="kendo.colorgradient.blueInputPlaceholder|The placeholder for the blue color input."
            blueInputPlaceholder="Blue"
            i18n-alphaInputPlaceholder="kendo.colorgradient.alphaInputPlaceholder|The placeholder for the alpha input."
            alphaInputPlaceholder="Alpha"
            i18n-passContrast="kendo.colorgradient.passContrast|The pass message for the contrast tool."
            passContrast="Pass"
            i18n-failContrast="kendo.colorgradient.failContrast|The fail message for the contrast tool."
            failContrast="Fail"
            i18n-contrastRatio="kendo.colorgradient.contrastRatio|The contrast ratio message for the contrast tool."
            contrastRatio="Contrast ratio">
        </ng-container>
        <div class="k-colorgradient-canvas k-hstack">
            <div class="k-hsv-rectangle" [style.background]="backgroundColor">
                <div
                    #gradientWrapper
                    kendoDraggable
                    class="k-hsv-gradient"
                    (click)="changePosition($event)"
                    (kendoPress)="handleDragPress($event)"
                    (kendoDrag)="onHandleDrag($event)"
                    (kendoRelease)="onHandleRelease()">
                    <div
                        #gradientDragHandle
                        class="k-hsv-draghandle k-draghandle"
                        tabindex="0"
                        [attr.title]="colorGradientHandleTitle"
                        [attr.aria-label]="colorGradientHandleAriaLabel"
                    >
                    </div>
                </div>
            </div>
            <div class="k-hsv-controls k-hstack {{ clearButton ? 'k-sliders-wrap-clearable' : '' }}">
                <span class="k-clear-color k-button k-flat k-button-icon"
                    *ngIf="clearButton"
                    (click)="reset()"
                    (keydown.enter)="reset()"
                    (keydown.space)="reset()"
                    [attr.aria-label]="clearButtonTitle"
                    [attr.title]="clearButtonTitle"
                    tabindex="0">
                    <span class="k-icon k-i-reset-color"></span>
                </span>
                <kendo-slider
                    [ngClass]="{'k-align-self-end': clearButton}"
                    class="k-hue-slider k-colorgradient-slider"
                    [dragHandleTitle]="hueSliderTitle"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    [tickPlacement]="'none'"
                    [vertical]="true"
                    [min]="0"
                    [max]="360"
                    [smallStep]="5"
                    [largeStep]="10"
                    [(value)]="hsva.h"
                    (valueChange)="handleHueSliderChange($event)"
                >
                </kendo-slider>
                <kendo-slider
                    *ngIf="opacity && format === 'rgba'"
                    #alphaSlider
                    [ngClass]="{'k-align-self-end': clearButton}"
                    class="k-alpha-slider k-colorgradient-slider"
                    [dragHandleTitle]="opacitySliderTitle"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    [tickPlacement]="'none'"
                    [vertical]="true"
                    [min]="0"
                    [max]="100"
                    [smallStep]="1"
                    [largeStep]="10"
                    [value]="alphaSliderValue"
                    (valueChange)="handleAlphaSliderChange($event)"
                >
                </kendo-slider>
            </div>
        </div>
        <kendo-colorinput  #inputs
            [opacity]="opacity"
            [formatView]="format"
            [value]="value"
            [disabled]="disabled"
            [readonly]="readonly"
            (valueChange)="handleInputsValueChange($event)"
        >
        </kendo-colorinput>
        <div class="k-colorgradient-color-contrast k-vbox" *ngIf="contrastToolVisible"
            kendoContrastTool
            [value]="value"
            [ratio]="contrastTool">
        </div>
    `,
                styles: [`
        .k-clear-color {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }
        .k-align-self-end {
            height: 140px;
        }
    `]
            }]
    }], function () { return [{ type: ElementRef }, { type: NgZone }, { type: Renderer2 }, { type: ChangeDetectorRef }, { type: LocalizationService }]; }, { constructor: [], host: [], ngZone: [], renderer: [], cdr: [], localizationService: [], hostClasses: [{
            type: HostBinding,
            args: ['class.k-colorgradient']
        }], id: [{
            type: Input
        }], opacity: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], delay: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], backgroundColor: [], hsva: [], format: [{
            type: Input
        }], _tabindex: [], listeners: [], updateValues: [], notifyNgChanged: [], notifyNgTouched: [], dynamicRTLSubscription: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], readonlyAttribute: [{
            type: HostBinding,
            args: ['attr.aria-readonly']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], hostTabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], gradientId: [{
            type: HostBinding,
            args: ['attr.id']
        }], value: [{
            type: Input
        }], value: [], _value: [], tabindex: [{
            type: Input
        }], tabindex: [], isFocused: [], alphaSliderValue: [], gradientRect: [], contrastToolVisible: [], ngAfterViewInit: [], ngOnChanges: [], ngOnDestroy: [], focus: [], reset: [], handleDragPress: [], onHandleDrag: [], onHandleRelease: [], onKeyboardAction: [], changePosition: [], handleHueSliderChange: [], handleAlphaSliderChange: [], handleInputsValueChange: [], writeValue: [], registerOnChange: [], registerOnTouched: [], setDisabledState: [], colorGradientHandleTitle: [], colorGradientHandleAriaLabel: [], hueSliderTitle: [], opacitySliderTitle: [], clearButtonTitle: [], isEmpty: [], moveDragHandle: [], updateUI: [], handleValueChange: [], setDragHandleElementPosition: [], setAlphaSliderBackground: [], setHostElementAriaLabel: [], addEventListeners: [], subscribeChanges: [], changeRequestsSubscription: [], unsubscribeChanges: [], contrastTool: [{
            type: Input
        }], gradientDragHandle: [{
            type: ViewChild,
            args: ['gradientDragHandle', { read: ElementRef, static: false }]
        }], inputs: [{
            type: ViewChild,
            args: ['inputs', { static: false }]
        }], alphaSlider: [{
            type: ViewChild,
            args: ['alphaSlider', { static: false }]
        }], gradientWrapper: [{
            type: ViewChild,
            args: ['gradientWrapper', { static: false }]
        }] });;
tslib_1.__decorate([
    HostBinding('class.k-colorgradient'),
    tslib_1.__metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "hostClasses", void 0);
tslib_1.__decorate([
    HostBinding('attr.aria-readonly'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "readonlyAttribute", null);
tslib_1.__decorate([
    HostBinding('class.k-state-disabled'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "disabledClass", null);
tslib_1.__decorate([
    HostBinding('attr.tabindex'),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "hostTabindex", null);
tslib_1.__decorate([
    HostBinding('attr.id'),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "gradientId", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorGradientComponent.prototype, "id", void 0);
tslib_1.__decorate([
    HostBinding('attr.dir'),
    tslib_1.__metadata("design:type", String)
], ColorGradientComponent.prototype, "direction", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "opacity", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "disabled", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "readonly", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "clearButton", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], ColorGradientComponent.prototype, "delay", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], ColorGradientComponent.prototype, "value", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorGradientComponent.prototype, "contrastTool", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], ColorGradientComponent.prototype, "tabindex", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorGradientComponent.prototype, "valueChange", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorGradientComponent.prototype, "format", void 0);
tslib_1.__decorate([
    ViewChild('gradientDragHandle', { read: ElementRef, static: false }),
    tslib_1.__metadata("design:type", ElementRef)
], ColorGradientComponent.prototype, "gradientDragHandle", void 0);
tslib_1.__decorate([
    ViewChild('inputs', { static: false }),
    tslib_1.__metadata("design:type", ColorInputComponent)
], ColorGradientComponent.prototype, "inputs", void 0);
tslib_1.__decorate([
    ViewChild('alphaSlider', { static: false }),
    tslib_1.__metadata("design:type", SliderComponent)
], ColorGradientComponent.prototype, "alphaSlider", void 0);
tslib_1.__decorate([
    ViewChild('gradientWrapper', { static: false }),
    tslib_1.__metadata("design:type", ElementRef)
], ColorGradientComponent.prototype, "gradientWrapper", void 0);
ColorGradientComponent = ColorGradientComponent_1 = tslib_1.__decorate([
    tslib_1.__metadata("design:paramtypes", [ElementRef,
        NgZone,
        Renderer2,
        ChangeDetectorRef,
        LocalizationService])
], ColorGradientComponent);
export { ColorGradientComponent };

//# sourceMappingURL=color-gradient.component.js.map