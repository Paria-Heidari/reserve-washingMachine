/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import * as ɵngcc0 from '@angular/core';

const _c0 = ["kendoColorPaletteLocalizedMessages", "", 6, "colorPaletteNoColor"];
var I18N_1;
if (ngI18nClosureMode) {
    /**
     * @desc The aria-label applied to the ColorPalette component when the value is empty.
     * @meaning kendo.colorpalette.colorPaletteNoColor
     */ 
    const MSG_EXTERNAL_4885193165402402447$$DIST_ES2015_COLORPICKER_COLOR_PALETTE_COMPONENT_JS_2 = goog.getMsg("Colorpalette no color chosen");
    I18N_1 = MSG_EXTERNAL_4885193165402402447$$DIST_ES2015_COLORPICKER_COLOR_PALETTE_COMPONENT_JS_2;
}
else {
    I18N_1 = ɵngcc0.ɵɵi18nLocalize("Colorpalette no color chosen");
}
const _c3 = ["colorPaletteNoColor", I18N_1];
const _c4 = ["role", "listbox", 1, "k-colorpalette-table-wrap"];
const _c5 = [1, "k-colorpalette-table", "k-palette"];
const _c6 = [4, "ngFor", "ngForOf"];
const _c7 = ["role", "option", "class", "k-colorpalette-tile", 3, "k-state-selected", "k-state-focus", "id", "ngStyle", "click", 4, "ngFor", "ngForOf"];
const _c8 = ["role", "option", 1, "k-colorpalette-tile", 3, "id", "ngStyle", "click"];
const _c9 = function (a0, a1, a2, a3) { return { backgroundColor: a0, width: a1, height: a2, minWidth: a3 }; };
function ColorPaletteComponent_tr_5_td_1_Template(rf, ctx) { if (rf & 1) {
    const _r259 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", _c8);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵlistener("click", function ColorPaletteComponent_tr_5_td_1_Template_td_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r259); const color_r255 = ctx.$implicit; const colIndex_r256 = ctx.index; const rowIndex_r253 = ɵngcc0.ɵɵnextContext().index; const ctx_r257 = ɵngcc0.ɵɵnextContext(); return ctx_r257.handleCellSelection(color_r255, { row: rowIndex_r253, col: colIndex_r256 }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const color_r255 = ctx.$implicit;
    const colIndex_r256 = ctx.index;
    const rowIndex_r253 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r254 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-state-selected", (ctx_r254.selectedCell == null ? null : ctx_r254.selectedCell.row) === rowIndex_r253 && (ctx_r254.selectedCell == null ? null : ctx_r254.selectedCell.col) === colIndex_r256);
    ɵngcc0.ɵɵclassProp("k-state-focus", ctx_r254.focusInComponent && (ctx_r254.focusedCell == null ? null : ctx_r254.focusedCell.row) === rowIndex_r253 && (ctx_r254.focusedCell == null ? null : ctx_r254.focusedCell.col) === colIndex_r256);
    ɵngcc0.ɵɵstylingApply();
    ɵngcc0.ɵɵproperty("id", rowIndex_r253 + "-" + colIndex_r256)("ngStyle", ɵngcc0.ɵɵpureFunction4(7, _c9, color_r255, ctx_r254.tileLayout.width + "px", ctx_r254.tileLayout.height + "px", ctx_r254.tileLayout.width + "px"));
    ɵngcc0.ɵɵattribute("aria-selected", (ctx_r254.selectedCell == null ? null : ctx_r254.selectedCell.row) === rowIndex_r253 && (ctx_r254.selectedCell == null ? null : ctx_r254.selectedCell.col) === colIndex_r256)("aria-label", color_r255)("value", color_r255);
} }
function ColorPaletteComponent_tr_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵtemplate(1, ColorPaletteComponent_tr_5_td_1_Template, 1, 12, "td", _c7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const row_r252 = ctx.$implicit;
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵproperty("ngForOf", row_r252);
} }
var ColorPaletteComponent_1;
import { Component, Input, EventEmitter, Output, HostBinding, HostListener, forwardRef, ChangeDetectorRef, Renderer2, ElementRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { PALETTEPRESETS, parseColor } from './utils';
import { isPresent } from '../common/utils';
import { ColorPaletteService } from './services/color-palette.service';
import { Keys, KendoInput } from '@progress/kendo-angular-common';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { ColorPaletteLocalizationService } from './localization/colorpalette-localization.service';
const DEFAULT_TILE_SIZE = 24;
const DEFAULT_COLUMNS_COUNT = 10;
const DEFAULT_PRESET = 'office';
const DEFAULT_ACCESSIBLE_PRESET = 'accessible';
let serial = 0;
/**
 * The ColorPalette component provides a set of predefined palette presets and enables you to implement a custom color palette.
 * The ColorPalette is independently used by `kendo-colorpicker` and can be directly added to the page.
 */
let ColorPaletteComponent = ColorPaletteComponent_1 = class ColorPaletteComponent {
    constructor(host, service, cdr, renderer, localizationService) {
        this.host = host;
        this.service = service;
        this.cdr = cdr;
        this.renderer = renderer;
        this.localizationService = localizationService;
        /**
         * @hidden
         */
        this.id = `k-colorpalette-${serial++}`;
        /**
         * Specifies the output format of the ColorPaletteComponent.
         * The input value may be in a different format. However, it will be parsed into the output `format`
         * after the component processes it.
         *
         * The supported values are:
         * * (Default) `hex`
         * * `rgba`
         * * `name`
         */
        this.format = 'hex';
        /**
         * Sets the disabled state of the ColorPalette.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorPalette.
         */
        this.readonly = false;
        /**
         * Specifies the size of a color cell.
         *
         * The possible values are:
         * * (Default) `tileSize = 24`
         * * `{ width: number, height: number }`
         */
        this.tileSize = { width: DEFAULT_TILE_SIZE, height: DEFAULT_TILE_SIZE };
        /**
         * Fires each time the color selection is changed.
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires each time the value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user selects a cell with the mouse or presses `Enter`.
         *
         * @hidden
         */
        this.cellSelection = new EventEmitter();
        /**
         * @hidden
         */
        this.hostClasses = true;
        this._tabindex = 0;
        this.notifyNgTouched = () => { };
        this.notifyNgChanged = () => { };
        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    /**
     * @hidden
     */
    get paletteId() {
        return this.id;
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor(value, this.format);
    }
    get value() {
        return this._value;
    }
    /**
     * Specifies the number of columns that will be displayed.
     * Defaults to `10`.
     */
    set columns(value) {
        const minColumnsCount = 1;
        this._columns = value > minColumnsCount ? value : minColumnsCount;
    }
    get columns() {
        return this._columns;
    }
    /**
     * The color palette that will be displayed.
     *
     * The supported values are:
     * * The name of the predefined palette preset (for example, `office`, `basic`, and `apex`).
     * * A string with comma-separated colors.
     * * A string array.
     */
    set palette(value) {
        if (!isPresent(value)) {
            value = DEFAULT_PRESET;
        }
        if (typeof value === 'string' && isPresent(PALETTEPRESETS[value])) {
            this.columns = this.columns || PALETTEPRESETS[value].columns;
            value = PALETTEPRESETS[value].colors;
        }
        const colors = (typeof value === 'string') ? value.split(',') : value;
        this._palette = colors.map(color => parseColor(color, this.format, false));
    }
    get palette() {
        return this._palette;
    }
    /**
     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * @hidden
     */
    get tileLayout() {
        if (typeof this.tileSize !== 'number') {
            return this.tileSize;
        }
        return { width: this.tileSize, height: this.tileSize };
    }
    /**
     * @hidden
     */
    get colorRows() {
        return this.service.colorRows;
    }
    /**
     * @hidden
     */
    get hostTabindex() { return this.tabindex; }
    /**
     * @hidden
     */
    get disabledClass() { return this.disabled; }
    /**
     * @hidden
     */
    get readonlyAttribute() { return this.readonly; }
    ngOnInit() {
        if (this.colorRows.length === 0) {
            const defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;
            this.palette = this.palette || defaultPreset;
            this.setRows();
            this.focusedCell = this.service.getCellCoordsFor(this.value);
        }
    }
    ngAfterViewInit() {
        this.setHostElementAriaLabel();
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    ngOnChanges(changes) {
        if (changes.palette || changes.columns) {
            this.setRows();
        }
        if (changes.palette || changes.value || changes.columns) {
            this.focusedCell = this.service.getCellCoordsFor(this.value);
            this.setHostElementAriaLabel();
        }
    }
    /**
     * @hidden
     */
    handleKeydown(event) {
        const isRTL = this.direction === 'rtl';
        switch (event.keyCode) {
            case Keys.ArrowDown:
                this.handleCellNavigation(0, 1);
                break;
            case Keys.ArrowUp:
                this.handleCellNavigation(0, -1);
                break;
            case Keys.ArrowRight:
                this.handleCellNavigation(isRTL ? -1 : 1, 0);
                break;
            case Keys.ArrowLeft:
                this.handleCellNavigation(isRTL ? 1 : -1, 0);
                break;
            case Keys.Enter:
                this.handleEnter();
                break;
            default: return;
        }
        event.preventDefault();
    }
    /**
     * @hidden
     */
    handleHostBlur() {
        this.notifyNgTouched();
        this.handleCellFocusOnBlur();
    }
    /**
     * @hidden
     */
    handleCellSelection(value, cell) {
        if (this.readonly) {
            return;
        }
        this.selectedCell = cell;
        this.focusedCell = this.selectedCell;
        this.focusInComponent = true;
        const parsedColor = parseColor(value, this.format, false);
        this.cellSelection.emit(parsedColor);
        if (this.value !== parsedColor) {
            this.value = parsedColor;
            this.valueChange.emit(parsedColor);
            this.notifyNgChanged(parsedColor);
            this.setHostElementAriaLabel();
        }
        if (this.selection !== parsedColor) {
            this.selection = parsedColor;
            this.selectionChange.emit(parsedColor);
        }
        if (cell) {
            this.activeCellId = `${this.selectedCell.row}-${this.selectedCell.col}`;
        }
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        this.focusedCell = this.service.getCellCoordsFor(this.value);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.cdr.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    /**
     * Clears the color value of the ColorPalette.
     */
    reset() {
        this.focusedCell = null;
        if (isPresent(this.value)) {
            this._value = undefined;
            this.notifyNgChanged(undefined);
        }
    }
    handleCellFocusOnBlur() {
        this.focusInComponent = false;
        this.focusedCell = this.selectedCell;
    }
    setRows() {
        if (!isPresent(this.palette)) {
            return;
        }
        this.columns = this.columns || DEFAULT_COLUMNS_COUNT;
        this.service.setColorMatrix(this.palette, this.columns);
    }
    handleCellNavigation(horizontalStep, verticalStep) {
        if (this.readonly) {
            return;
        }
        this.focusedCell = this.service.getNextCell(this.focusedCell, horizontalStep, verticalStep);
        this.focusInComponent = true;
    }
    setHostElementAriaLabel() {
        const parsed = parseColor(this.value, this.format);
        this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorPaletteNoColor')}`);
    }
    handleEnter() {
        if (!isPresent(this.focusedCell)) {
            return;
        }
        const selectedColor = this.service.getColorAt(this.focusedCell);
        this.handleCellSelection(selectedColor, this.focusedCell);
    }
}
ColorPaletteComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: ColorPaletteComponent, selectors: [["kendo-colorpalette"]], factory: function ColorPaletteComponent_Factory(t) { return new (t || ColorPaletteComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(ColorPaletteService), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, hostBindings: function ColorPaletteComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(7);
        ɵngcc0.ɵɵlistener("keydown", function ColorPaletteComponent_keydown_HostBindingHandler($event) { return ctx.handleKeydown($event); });
        ɵngcc0.ɵɵlistener("blur", function ColorPaletteComponent_blur_HostBindingHandler($event) { return ctx.handleHostBlur(); });
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction)("id", ctx.paletteId)("tabindex", ctx.hostTabindex)("aria-disabled", ctx.disabledClass)("aria-readonly", ctx.readonlyAttribute);
        ɵngcc0.ɵɵclassProp("k-colorpalette", ctx.hostClasses);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabledClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { id: "id", format: "format", disabled: "disabled", readonly: "readonly", tileSize: "tileSize", value: "value", columns: "columns", palette: "palette", tabindex: "tabindex" }, outputs: { selectionChange: "selectionChange", valueChange: "valueChange", cellSelection: "cellSelection" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorPaletteComponent_1) // tslint:disable-line:no-forward-ref
            }, {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorPaletteComponent_1)
            },
            ColorPaletteService,
            ColorPaletteLocalizationService,
            {
                provide: LocalizationService,
                useExisting: ColorPaletteLocalizationService
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorpalette'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], consts: 6, vars: 2, template: function ColorPaletteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, _c0);
        ɵngcc0.ɵɵi18nAttributes(1, _c3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "div", _c4);
        ɵngcc0.ɵɵelementStart(3, "table", _c5);
        ɵngcc0.ɵɵelementStart(4, "tbody");
        ɵngcc0.ɵɵtemplate(5, ColorPaletteComponent_tr_5_Template, 2, 1, "tr", _c6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeCellId);
        ɵngcc0.ɵɵselect(5);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.colorRows);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ColorPaletteComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-colorpalette',
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ColorPaletteComponent_1) // tslint:disable-line:no-forward-ref
                    }, {
                        provide: KendoInput,
                        useExisting: forwardRef(() => ColorPaletteComponent_1)
                    },
                    ColorPaletteService,
                    ColorPaletteLocalizationService,
                    {
                        provide: LocalizationService,
                        useExisting: ColorPaletteLocalizationService
                    },
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.colorpalette'
                    }
                ],
                template: `
        <ng-container kendoColorPaletteLocalizedMessages
            i18n-colorPaletteNoColor="kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen">
        </ng-container>
        <div role="listbox" class="k-colorpalette-table-wrap"
            [attr.aria-activedescendant]="activeCellId">
            <table class="k-colorpalette-table k-palette">
                <tbody>
                    <tr *ngFor="let row of colorRows; let rowIndex = index">
                        <td *ngFor="let color of row; let colIndex = index"
                            role="option"
                            [class.k-state-selected]="selectedCell?.row === rowIndex && selectedCell?.col === colIndex"
                            [class.k-state-focus]="focusInComponent && focusedCell?.row === rowIndex && focusedCell?.col === colIndex"
                            [attr.aria-selected]="selectedCell?.row === rowIndex && selectedCell?.col === colIndex"
                            [attr.aria-label]="color"
                            class="k-colorpalette-tile"
                            [id]="rowIndex + '-' + colIndex"
                            [attr.value]="color"
                            (click)="handleCellSelection(color, { row: rowIndex, col: colIndex })"
                            [ngStyle]="{
                                backgroundColor: color,
                                width: tileLayout.width + 'px',
                                height: tileLayout.height + 'px',
                                minWidth: tileLayout.width + 'px'
                            }">
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    `
            }]
    }], function () { return [{ type: ElementRef }, { type: ColorPaletteService }, { type: ChangeDetectorRef }, { type: Renderer2 }, { type: LocalizationService }]; }, { constructor: [], host: [], service: [], cdr: [], renderer: [], localizationService: [], id: [{
            type: Input
        }], format: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], tileSize: [{
            type: Input
        }], selectionChange: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], cellSelection: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-colorpalette']
        }], _tabindex: [], notifyNgTouched: [], notifyNgChanged: [], dynamicRTLSubscription: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], paletteId: [{
            type: HostBinding,
            args: ['attr.id']
        }], value: [{
            type: Input
        }], value: [], _value: [], columns: [{
            type: Input
        }], columns: [], _columns: [], palette: [{
            type: Input
        }], palette: [], _palette: [], tabindex: [{
            type: Input
        }], tabindex: [], tileLayout: [], colorRows: [], hostTabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], disabledClass: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], readonlyAttribute: [{
            type: HostBinding,
            args: ['attr.aria-readonly']
        }], ngOnInit: [], focusedCell: [], ngAfterViewInit: [], ngOnDestroy: [], ngOnChanges: [], handleKeydown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], handleHostBlur: [{
            type: HostListener,
            args: ['blur']
        }], handleCellSelection: [], selectedCell: [], focusInComponent: [], selection: [], activeCellId: [], writeValue: [], registerOnChange: [], registerOnTouched: [], setDisabledState: [], isEmpty: [], reset: [], handleCellFocusOnBlur: [], setRows: [], handleCellNavigation: [], setHostElementAriaLabel: [], handleEnter: [] });;
tslib_1.__decorate([
    HostBinding('attr.dir'),
    tslib_1.__metadata("design:type", String)
], ColorPaletteComponent.prototype, "direction", void 0);
tslib_1.__decorate([
    HostBinding('attr.id'),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "paletteId", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorPaletteComponent.prototype, "id", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorPaletteComponent.prototype, "format", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], ColorPaletteComponent.prototype, "value", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], ColorPaletteComponent.prototype, "columns", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], ColorPaletteComponent.prototype, "palette", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], ColorPaletteComponent.prototype, "tabindex", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorPaletteComponent.prototype, "disabled", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorPaletteComponent.prototype, "readonly", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], ColorPaletteComponent.prototype, "tileSize", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorPaletteComponent.prototype, "selectionChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorPaletteComponent.prototype, "valueChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorPaletteComponent.prototype, "cellSelection", void 0);
tslib_1.__decorate([
    HostBinding('attr.tabindex'),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "hostTabindex", null);
tslib_1.__decorate([
    HostBinding('class.k-colorpalette'),
    tslib_1.__metadata("design:type", Boolean)
], ColorPaletteComponent.prototype, "hostClasses", void 0);
tslib_1.__decorate([
    HostBinding('attr.aria-disabled'),
    HostBinding('class.k-state-disabled'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "disabledClass", null);
tslib_1.__decorate([
    HostBinding('attr.aria-readonly'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "readonlyAttribute", null);
tslib_1.__decorate([
    HostListener('keydown', ['$event']),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], ColorPaletteComponent.prototype, "handleKeydown", null);
tslib_1.__decorate([
    HostListener('blur'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ColorPaletteComponent.prototype, "handleHostBlur", null);
ColorPaletteComponent = ColorPaletteComponent_1 = tslib_1.__decorate([
    tslib_1.__metadata("design:paramtypes", [ElementRef,
        ColorPaletteService,
        ChangeDetectorRef,
        Renderer2,
        LocalizationService])
], ColorPaletteComponent);
export { ColorPaletteComponent };

//# sourceMappingURL=color-palette.component.js.map