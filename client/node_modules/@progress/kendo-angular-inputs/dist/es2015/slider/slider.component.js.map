{"version":3,"file":"slider.component.js","sources":["/Users/paria/workspace/washIt/client/node_modules/@progress/kendo-angular-inputs/dist/es2015/slider/slider.component.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as tslib_1 from \"tslib\";\nvar SliderComponent_1;\nimport { Renderer2, Component, ElementRef, Input, ViewChild, forwardRef, NgZone, Injector, ChangeDetectorRef } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { fromEvent, interval, merge } from 'rxjs';\nimport { filter, concatMap, startWith, takeUntil, take } from 'rxjs/operators';\nimport { trimValue } from '../sliders-common/sliders-util';\nimport { SliderModel } from './slider-model';\nimport { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';\nimport { areSame, isPresent, requiresZoneOnBlur } from '../common/utils';\nimport { isButton, eventValue, decreaseValueToStep, increaseValueToStep } from '../sliders-common/sliders-util';\nimport { invokeElementMethod } from '../common/dom-utils';\nimport { guid, isDocumentAvailable, hasObservers, KendoInput, anyChanged, Keys } from '@progress/kendo-angular-common';\nimport { SliderBase } from '../sliders-common/slider-base';\nconst PRESSED = 'k-pressed';\n/**\n * Represents the [Kendo UI Slider component for Angular]({% slug overview_slider %}).\n */\nlet SliderComponent = SliderComponent_1 = class SliderComponent extends SliderBase {\n    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {\n        super(localization, injector, renderer, ngZone, changeDetector, hostElement);\n        this.localization = localization;\n        this.injector = injector;\n        this.renderer = renderer;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Determines if the animation will be played on value change.\n         * Regardless of this setting, no animation will be played during the initial rendering.\n         */\n        this.animate = true;\n        /**\n         * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).\n         * When `showButtons` is set to `false`, the buttons are not displayed.\n         */\n        this.showButtons = true;\n        /**\n         * The current value of the Slider when it is initially displayed.\n         * The component can use either NgModel or the `value` binding but not both of them at the same time.\n         */\n        this.value = this.min;\n        this.focusChangedProgrammatically = false;\n        /**\n         * @hidden\n         */\n        this.onWrapClick = (args) => {\n            const target = args.target;\n            if (!this.isDisabled && !(isButton(target) || isButton(target.parentNode))) {\n                const value = eventValue(args, this.track.nativeElement, this.getProps());\n                this.changeValue(value);\n            }\n            invokeElementMethod(this.draghandle, 'focus');\n        };\n        /**\n         * @hidden\n         */\n        this.onKeyDown = (e) => {\n            const options = this.getProps();\n            const { max, min } = options;\n            const handler = this.keyBinding[e.keyCode];\n            if (this.isDisabled || !handler) {\n                return;\n            }\n            const value = handler(options);\n            this.changeValue(trimValue(max, min, value));\n            e.preventDefault();\n        };\n        this.ngChange = (_) => { };\n        this.ngTouched = () => { };\n        this.decreaseValue = () => {\n            this.changeValue(decreaseValueToStep(this.value, this.getProps()));\n        };\n        this.increaseValue = () => {\n            this.changeValue(increaseValueToStep(this.value, this.getProps()));\n        };\n        this.handleBlur = () => {\n            this.changeDetector.markForCheck();\n            this.focused = false;\n            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.ngTouched();\n                    if (!this.focusChangedProgrammatically) {\n                        this.onBlur.emit();\n                    }\n                });\n            }\n        };\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    /**\n     * @hidden\n     */\n    get currentValue() {\n        return isPresent(this.value) ? this.value.toString() : '';\n    }\n    /**\n     * Focuses the Slider.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"slider.focus()\">Focus</button>\n     *  <kendo-slider #slider></kendo-slider>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.disabled) {\n            this.focusChangedProgrammatically = true;\n            invokeElementMethod(this.draghandle, 'focus');\n            this.focusChangedProgrammatically = false;\n        }\n    }\n    /**\n     * Blurs the Slider.\n     */\n    blur() {\n        this.focusChangedProgrammatically = true;\n        invokeElementMethod(this.draghandle, 'blur');\n        this.handleBlur();\n        this.focusChangedProgrammatically = false;\n    }\n    ngOnChanges(changes) {\n        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {\n            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n                this.sizeComponent(false);\n            });\n        }\n    }\n    ngAfterViewInit() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        if (this.showButtons) {\n            this.setValueChangeInterval(this.increaseButton.nativeElement, () => this.increaseValue());\n            this.setValueChangeInterval(this.decreaseButton.nativeElement, () => this.decreaseValue());\n        }\n        this.sizeComponent(false);\n        if (this.ticks) {\n            this.ticks.tickElements\n                .changes\n                .subscribe(() => this.sizeComponent(false));\n        }\n        this.attachElementEventHandlers();\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    get incrementMessage() {\n        return this.incrementTitle || this.localizationService.get('increment');\n    }\n    /**\n     * @hidden\n     */\n    get decrementMessage() {\n        return this.decrementTitle || this.localizationService.get('decrement');\n    }\n    /**\n     * @hidden\n     */\n    get dragHandleMessage() {\n        return this.dragHandleTitle || this.localizationService.get('dragHandle');\n    }\n    /**\n     * @hidden\n     */\n    handleDragPress(args) {\n        if (args.originalEvent) {\n            args.originalEvent.preventDefault();\n        }\n        this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    }\n    /**\n     * @hidden\n     */\n    onHandleDrag(args) {\n        this.dragging = true;\n        this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));\n    }\n    /**\n     * @hidden\n     */\n    onHandleRelease() {\n        this.dragging = false; //needed for animation\n        this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    }\n    //ngModel binding\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.changeDetector.markForCheck();\n        this.value = value;\n        this.sizeComponent(this.animate);\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    changeValue(value) {\n        if (!areSame(this.value, value)) {\n            this.ngZone.run(() => {\n                this.value = value;\n                this.ngChange(value);\n                this.valueChange.emit(value);\n                this.sizeComponent(this.animate);\n                this.changeDetector.markForCheck();\n            });\n        }\n    }\n    /**\n     * @hidden\n     */\n    sizeComponent(animate) {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        const wrapper = this.wrapper.nativeElement;\n        const track = this.track.nativeElement;\n        const selectionEl = this.sliderSelection.nativeElement;\n        const dragHandleEl = this.draghandle.nativeElement;\n        const ticks = this.ticks ? this.ticksContainer.nativeElement : null;\n        if (!animate) {\n            this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n        }\n        this.resetStyles([track, selectionEl, dragHandleEl, ticks, this.hostElement.nativeElement]);\n        const props = this.getProps();\n        const model = new SliderModel(props, wrapper, track, this.renderer);\n        model.resizeTrack();\n        if (this.ticks) { //for case when tickPlacement: none\n            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));\n        }\n        model.positionHandle(dragHandleEl);\n        model.positionSelection(dragHandleEl, selectionEl);\n        if (!animate) {\n            this.hostElement.nativeElement.getBoundingClientRect();\n            this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n        }\n        if (this.fixedTickWidth) {\n            model.resizeWrapper();\n        }\n    }\n    set focused(value) {\n        if (this.isFocused !== value && this.hostElement) {\n            this.isFocused = value;\n        }\n    }\n    set dragging(value) {\n        if (this.isDragged !== value && this.sliderSelection && this.draghandle) {\n            const sliderSelection = this.sliderSelection.nativeElement;\n            const draghandle = this.draghandle.nativeElement;\n            if (value) {\n                this.renderer.addClass(sliderSelection, PRESSED);\n                this.renderer.addClass(draghandle, PRESSED);\n            }\n            else {\n                this.renderer.removeClass(sliderSelection, PRESSED);\n                this.renderer.removeClass(draghandle, PRESSED);\n            }\n            this.isDragged = value;\n        }\n    }\n    setValueChangeInterval(element, callback) {\n        this.ngZone.runOutsideAngular(() => {\n            const mousedown = fromEvent(element, 'mousedown');\n            const mouseup = fromEvent(element, 'mouseup');\n            const mouseout = fromEvent(element, 'mouseout');\n            const subscription = mousedown.pipe(filter((e) => e.button === 0 && !this.isDisabled), concatMap(() => interval(150).pipe(startWith(-1), takeUntil(merge(mouseup, mouseout))))).subscribe(() => {\n                if (!this.isFocused) {\n                    invokeElementMethod(this.draghandle, 'focus');\n                }\n                callback();\n            });\n            this.subscriptions.add(subscription);\n        });\n    }\n    getProps() {\n        return {\n            buttons: this.showButtons,\n            disabled: this.disabled,\n            fixedTickWidth: this.fixedTickWidth,\n            largeStep: this.largeStep,\n            max: this.max,\n            min: this.min,\n            readonly: this.readonly,\n            reverse: this.reverse,\n            rtl: this.localizationService.rtl,\n            smallStep: this.smallStep,\n            value: trimValue(this.max, this.min, this.value),\n            vertical: this.vertical\n        };\n    }\n    attachElementEventHandlers() {\n        const hostElement = this.hostElement.nativeElement;\n        let tabbing = false;\n        let cursorInsideWrapper = false;\n        this.ngZone.runOutsideAngular(() => {\n            // focusIn and focusOut are relative to the host element\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n                if (!this.isFocused) {\n                    this.ngZone.run(() => {\n                        if (!this.focusChangedProgrammatically) {\n                            this.onFocus.emit();\n                        }\n                        this.focused = true;\n                    });\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {\n                if (!this.isFocused) {\n                    return;\n                }\n                if (tabbing) {\n                    if (args.relatedTarget !== this.draghandle.nativeElement) {\n                        this.handleBlur();\n                    }\n                    tabbing = false;\n                }\n                else {\n                    if (!cursorInsideWrapper) {\n                        this.handleBlur();\n                    }\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n                cursorInsideWrapper = true;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n                cursorInsideWrapper = false;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {\n                if (args.keyCode === Keys.Tab) {\n                    tabbing = true;\n                }\n                else {\n                    tabbing = false;\n                }\n            }));\n        });\n    }\n};\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], SliderComponent.prototype, \"focusableId\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], SliderComponent.prototype, \"dragHandleTitle\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], SliderComponent.prototype, \"incrementTitle\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], SliderComponent.prototype, \"animate\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], SliderComponent.prototype, \"decrementTitle\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], SliderComponent.prototype, \"showButtons\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Number)\n], SliderComponent.prototype, \"value\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Number),\n    tslib_1.__metadata(\"design:paramtypes\", [Number])\n], SliderComponent.prototype, \"tabIndex\", null);\ntslib_1.__decorate([\n    ViewChild('draghandle', { static: true }),\n    tslib_1.__metadata(\"design:type\", ElementRef)\n], SliderComponent.prototype, \"draghandle\", void 0);\ntslib_1.__decorate([\n    ViewChild('decreaseButton', { static: false }),\n    tslib_1.__metadata(\"design:type\", ElementRef)\n], SliderComponent.prototype, \"decreaseButton\", void 0);\ntslib_1.__decorate([\n    ViewChild('increaseButton', { static: false }),\n    tslib_1.__metadata(\"design:type\", ElementRef)\n], SliderComponent.prototype, \"increaseButton\", void 0);\nSliderComponent = SliderComponent_1 = tslib_1.__decorate([\n    Component({\n        exportAs: 'kendoSlider',\n        providers: [\n            LocalizationService,\n            { provide: L10N_PREFIX, useValue: 'kendo.slider' },\n            { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => SliderComponent_1) },\n            { provide: KendoInput, useExisting: forwardRef(() => SliderComponent_1) }\n        ],\n        selector: 'kendo-slider',\n        template: `\n        <ng-container kendoSliderLocalizedMessages\n            i18n-increment=\"kendo.slider.increment|The title of the **Increase** button of the Slider.\"\n            increment=\"increment\"\n            i18n-decrement=\"kendo.slider.decrement|The title of the **Decrease** button of the Slider.\"\n            decrement=\"decrement\"\n            i18n-dragHandle=\"kendo.slider.dragHandle|The title of the drag handle of the Slider.\"\n            dragHandle=\"Drag\"\n        >\n        <div class=\"k-slider-wrap\" #wrap\n            [class.k-slider-buttons]=\"showButtons\"\n            [class.k-slider-topleft]=\"tickPlacement === 'before'\"\n            [class.k-slider-bottomright]=\"tickPlacement === 'after'\"\n            [kendoEventsOutsideAngular]=\"{ click: onWrapClick, keydown: onKeyDown }\"\n            >\n            <span\n                #decreaseButton\n                *ngIf=\"showButtons\"\n                class=\"k-button k-button-decrease\"\n                [title]=\"decrementMessage\"\n                role=\"presentation\"\n            >\n                <span class=\"k-icon\"\n                    [class.k-i-arrow-w]=\"!vertical\"\n                    [class.k-i-arrow-s]=\"vertical\"\n                >\n                </span>\n            </span>\n            <span\n                *ngIf=\"showButtons\"\n                #increaseButton\n                class=\"k-button k-button-increase\"\n                [title]=\"incrementMessage\"\n                (click)=\"$event.preventDefault()\"\n                [attr.aria-label]=\"currentValue\"\n            >\n                <span class=\"k-icon\"\n                    [class.k-i-arrow-e]=\"!vertical\"\n                    [class.k-i-arrow-n]=\"vertical\"\n                >\n                </span>\n            </span>\n            <ul kendoSliderTicks\n                #ticks\n                *ngIf=\"tickPlacement !== 'none'\"\n                [tickTitle]=\"title\"\n                [vertical]=\"vertical\"\n                [step]=\"smallStep\"\n                [largeStep]=\"largeStep\"\n                [min]=\"min\"\n                [max]=\"max\"\n                [labelTemplate]=\"labelTemplate?.templateRef\"\n                [attr.aria-hidden]=\"true\"\n            >\n            </ul>\n            <div #track class=\"k-slider-track\">\n                <div #sliderSelection class=\"k-slider-selection\">\n                </div>\n                <a #draghandle\n                    role=\"slider\"\n                    [attr.aria-valuemin]=\"min\"\n                    [attr.aria-valuemax]=\"max\"\n                    [attr.aria-valuenow]=\"currentValue\"\n                    [attr.aria-valuetext]=\"currentValue\"\n                    [attr.aria-disabled]=\"disabled ? true : undefined\"\n                    [attr.aria-readonly]=\"readonly ? true : undefined\"\n                    [attr.aria-orientation]=\"vertical ? 'vertical' : 'horizontal'\"\n                    [style.touch-action]=\"isDisabled ? '' : 'none'\"\n                    class=\"k-draghandle\"\n                    [title]=\"dragHandleMessage\"\n                    [attr.tabindex]=\"disabled ? '-1' : tabIndex\"\n                    [id]=\"focusableId\"\n                    kendoDraggable\n                    (kendoPress)=\"ifEnabled(handleDragPress, $event)\"\n                    (kendoDrag)=\"ifEnabled(onHandleDrag, $event)\"\n                    (kendoRelease)=\"ifEnabled(onHandleRelease, $event)\"\n                ></a>\n            </div>\n            <kendo-resize-sensor (resize)=\"sizeComponent(false)\"></kendo-resize-sensor>\n        </div>\n  `\n    }),\n    tslib_1.__metadata(\"design:paramtypes\", [LocalizationService,\n        Injector,\n        Renderer2,\n        NgZone,\n        ChangeDetectorRef,\n        ElementRef])\n], SliderComponent);\nexport { SliderComponent };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAoXC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0DA8CyD,AA2FnD;;;;;;;;;"}