/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import * as ɵngcc0 from '@angular/core';

const _c0 = ["draghandle"];
const _c1 = ["decreaseButton"];
const _c2 = ["increaseButton"];
const _c3 = ["kendoSliderLocalizedMessages", "", 6, "increment", "decrement", "dragHandle"];
var I18N_4;
if (ngI18nClosureMode) {
    /**
     * @desc The title of the **Increase** button of the Slider.
     * @meaning kendo.slider.increment
     */ 
    const MSG_EXTERNAL_8302125540024939132$$DIST_ES2015_SLIDER_SLIDER_COMPONENT_JS_5 = goog.getMsg("increment");
    I18N_4 = MSG_EXTERNAL_8302125540024939132$$DIST_ES2015_SLIDER_SLIDER_COMPONENT_JS_5;
}
else {
    I18N_4 = ɵngcc0.ɵɵi18nLocalize("increment");
}
var I18N_6;
if (ngI18nClosureMode) {
    /**
     * @desc The title of the **Decrease** button of the Slider.
     * @meaning kendo.slider.decrement
     */ 
    const MSG_EXTERNAL_652458644240352212$$DIST_ES2015_SLIDER_SLIDER_COMPONENT_JS_7 = goog.getMsg("decrement");
    I18N_6 = MSG_EXTERNAL_652458644240352212$$DIST_ES2015_SLIDER_SLIDER_COMPONENT_JS_7;
}
else {
    I18N_6 = ɵngcc0.ɵɵi18nLocalize("decrement");
}
var I18N_8;
if (ngI18nClosureMode) {
    /**
     * @desc The title of the drag handle of the Slider.
     * @meaning kendo.slider.dragHandle
     */ 
    const MSG_EXTERNAL_9117416417579607469$$DIST_ES2015_SLIDER_SLIDER_COMPONENT_JS_9 = goog.getMsg("Drag");
    I18N_8 = MSG_EXTERNAL_9117416417579607469$$DIST_ES2015_SLIDER_SLIDER_COMPONENT_JS_9;
}
else {
    I18N_8 = ɵngcc0.ɵɵi18nLocalize("Drag");
}
const _c10 = ["increment", I18N_4, "decrement", I18N_6, "dragHandle", I18N_8];
const _c11 = [1, "k-slider-wrap", 3, "kendoEventsOutsideAngular"];
const _c12 = ["wrap", ""];
const _c13 = ["class", "k-button k-button-decrease", "role", "presentation", 3, "title", 4, "ngIf"];
const _c14 = ["class", "k-button k-button-increase", 3, "title", "click", 4, "ngIf"];
const _c15 = ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate", 4, "ngIf"];
const _c16 = [1, "k-slider-track"];
const _c17 = ["track", ""];
const _c18 = [1, "k-slider-selection"];
const _c19 = ["sliderSelection", ""];
const _c20 = ["role", "slider", "kendoDraggable", "", 1, "k-draghandle", 3, "title", "id", "kendoPress", "kendoDrag", "kendoRelease"];
const _c21 = ["draghandle", ""];
const _c22 = [3, "resize"];
const _c23 = ["role", "presentation", 1, "k-button", "k-button-decrease", 3, "title"];
const _c24 = ["decreaseButton", ""];
const _c25 = [1, "k-icon"];
function SliderComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", _c23, _c24);
    ɵngcc0.ɵɵelementStart(2, "span", _c25);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r140 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r140.decrementMessage);
    ɵngcc0.ɵɵselect(2);
    ɵngcc0.ɵɵclassProp("k-i-arrow-w", !ctx_r140.vertical);
    ɵngcc0.ɵɵclassProp("k-i-arrow-s", ctx_r140.vertical);
    ɵngcc0.ɵɵstylingApply();
} }
const _c26 = [1, "k-button", "k-button-increase", 3, "title", "click"];
const _c27 = ["increaseButton", ""];
function SliderComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    const _r149 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", _c26, _c27);
    ɵngcc0.ɵɵlistener("click", function SliderComponent_span_5_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r149); return $event.preventDefault(); });
    ɵngcc0.ɵɵelementStart(2, "span", _c25);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r141 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r141.incrementMessage);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r141.currentValue);
    ɵngcc0.ɵɵselect(2);
    ɵngcc0.ɵɵclassProp("k-i-arrow-e", !ctx_r141.vertical);
    ɵngcc0.ɵɵclassProp("k-i-arrow-n", ctx_r141.vertical);
    ɵngcc0.ɵɵstylingApply();
} }
const _c28 = ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate"];
const _c29 = ["ticks", ""];
function SliderComponent_ul_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", _c28, _c29);
} if (rf & 2) {
    const ctx_r142 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tickTitle", ctx_r142.title)("vertical", ctx_r142.vertical)("step", ctx_r142.smallStep)("largeStep", ctx_r142.largeStep)("min", ctx_r142.min)("max", ctx_r142.max)("labelTemplate", ctx_r142.labelTemplate == null ? null : ctx_r142.labelTemplate.templateRef);
    ɵngcc0.ɵɵattribute("aria-hidden", true);
} }
const _c30 = function (a0, a1) { return { click: a0, keydown: a1 }; };
var SliderComponent_1;
import { Renderer2, Component, ElementRef, Input, ViewChild, forwardRef, NgZone, Injector, ChangeDetectorRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { fromEvent, interval, merge } from 'rxjs';
import { filter, concatMap, startWith, takeUntil, take } from 'rxjs/operators';
import { trimValue } from '../sliders-common/sliders-util';
import { SliderModel } from './slider-model';
import { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';
import { areSame, isPresent, requiresZoneOnBlur } from '../common/utils';
import { isButton, eventValue, decreaseValueToStep, increaseValueToStep } from '../sliders-common/sliders-util';
import { invokeElementMethod } from '../common/dom-utils';
import { guid, isDocumentAvailable, hasObservers, KendoInput, anyChanged, Keys } from '@progress/kendo-angular-common';
import { SliderBase } from '../sliders-common/slider-base';
const PRESSED = 'k-pressed';
/**
 * Represents the [Kendo UI Slider component for Angular]({% slug overview_slider %}).
 */
let SliderComponent = SliderComponent_1 = class SliderComponent extends SliderBase {
    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {
        super(localization, injector, renderer, ngZone, changeDetector, hostElement);
        this.localization = localization;
        this.injector = injector;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Determines if the animation will be played on value change.
         * Regardless of this setting, no animation will be played during the initial rendering.
         */
        this.animate = true;
        /**
         * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).
         * When `showButtons` is set to `false`, the buttons are not displayed.
         */
        this.showButtons = true;
        /**
         * The current value of the Slider when it is initially displayed.
         * The component can use either NgModel or the `value` binding but not both of them at the same time.
         */
        this.value = this.min;
        this.focusChangedProgrammatically = false;
        /**
         * @hidden
         */
        this.onWrapClick = (args) => {
            const target = args.target;
            if (!this.isDisabled && !(isButton(target) || isButton(target.parentNode))) {
                const value = eventValue(args, this.track.nativeElement, this.getProps());
                this.changeValue(value);
            }
            invokeElementMethod(this.draghandle, 'focus');
        };
        /**
         * @hidden
         */
        this.onKeyDown = (e) => {
            const options = this.getProps();
            const { max, min } = options;
            const handler = this.keyBinding[e.keyCode];
            if (this.isDisabled || !handler) {
                return;
            }
            const value = handler(options);
            this.changeValue(trimValue(max, min, value));
            e.preventDefault();
        };
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        this.decreaseValue = () => {
            this.changeValue(decreaseValueToStep(this.value, this.getProps()));
        };
        this.increaseValue = () => {
            this.changeValue(increaseValueToStep(this.value, this.getProps()));
        };
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    if (!this.focusChangedProgrammatically) {
                        this.onBlur.emit();
                    }
                });
            }
        };
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * @hidden
     */
    get currentValue() {
        return isPresent(this.value) ? this.value.toString() : '';
    }
    /**
     * Focuses the Slider.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="slider.focus()">Focus</button>
     *  <kendo-slider #slider></kendo-slider>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.disabled) {
            this.focusChangedProgrammatically = true;
            invokeElementMethod(this.draghandle, 'focus');
            this.focusChangedProgrammatically = false;
        }
    }
    /**
     * Blurs the Slider.
     */
    blur() {
        this.focusChangedProgrammatically = true;
        invokeElementMethod(this.draghandle, 'blur');
        this.handleBlur();
        this.focusChangedProgrammatically = false;
    }
    ngOnChanges(changes) {
        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {
            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                this.sizeComponent(false);
            });
        }
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.showButtons) {
            this.setValueChangeInterval(this.increaseButton.nativeElement, () => this.increaseValue());
            this.setValueChangeInterval(this.decreaseButton.nativeElement, () => this.decreaseValue());
        }
        this.sizeComponent(false);
        if (this.ticks) {
            this.ticks.tickElements
                .changes
                .subscribe(() => this.sizeComponent(false));
        }
        this.attachElementEventHandlers();
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get incrementMessage() {
        return this.incrementTitle || this.localizationService.get('increment');
    }
    /**
     * @hidden
     */
    get decrementMessage() {
        return this.decrementTitle || this.localizationService.get('decrement');
    }
    /**
     * @hidden
     */
    get dragHandleMessage() {
        return this.dragHandleTitle || this.localizationService.get('dragHandle');
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (args.originalEvent) {
            args.originalEvent.preventDefault();
        }
        this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        this.dragging = true;
        this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));
    }
    /**
     * @hidden
     */
    onHandleRelease() {
        this.dragging = false; //needed for animation
        this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');
    }
    //ngModel binding
    /**
     * @hidden
     */
    writeValue(value) {
        this.changeDetector.markForCheck();
        this.value = value;
        this.sizeComponent(this.animate);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    changeValue(value) {
        if (!areSame(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.sizeComponent(this.animate);
                this.changeDetector.markForCheck();
            });
        }
    }
    /**
     * @hidden
     */
    sizeComponent(animate) {
        if (!isDocumentAvailable()) {
            return;
        }
        const wrapper = this.wrapper.nativeElement;
        const track = this.track.nativeElement;
        const selectionEl = this.sliderSelection.nativeElement;
        const dragHandleEl = this.draghandle.nativeElement;
        const ticks = this.ticks ? this.ticksContainer.nativeElement : null;
        if (!animate) {
            this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');
        }
        this.resetStyles([track, selectionEl, dragHandleEl, ticks, this.hostElement.nativeElement]);
        const props = this.getProps();
        const model = new SliderModel(props, wrapper, track, this.renderer);
        model.resizeTrack();
        if (this.ticks) { //for case when tickPlacement: none
            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));
        }
        model.positionHandle(dragHandleEl);
        model.positionSelection(dragHandleEl, selectionEl);
        if (!animate) {
            this.hostElement.nativeElement.getBoundingClientRect();
            this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');
        }
        if (this.fixedTickWidth) {
            model.resizeWrapper();
        }
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            this.isFocused = value;
        }
    }
    set dragging(value) {
        if (this.isDragged !== value && this.sliderSelection && this.draghandle) {
            const sliderSelection = this.sliderSelection.nativeElement;
            const draghandle = this.draghandle.nativeElement;
            if (value) {
                this.renderer.addClass(sliderSelection, PRESSED);
                this.renderer.addClass(draghandle, PRESSED);
            }
            else {
                this.renderer.removeClass(sliderSelection, PRESSED);
                this.renderer.removeClass(draghandle, PRESSED);
            }
            this.isDragged = value;
        }
    }
    setValueChangeInterval(element, callback) {
        this.ngZone.runOutsideAngular(() => {
            const mousedown = fromEvent(element, 'mousedown');
            const mouseup = fromEvent(element, 'mouseup');
            const mouseout = fromEvent(element, 'mouseout');
            const subscription = mousedown.pipe(filter((e) => e.button === 0 && !this.isDisabled), concatMap(() => interval(150).pipe(startWith(-1), takeUntil(merge(mouseup, mouseout))))).subscribe(() => {
                if (!this.isFocused) {
                    invokeElementMethod(this.draghandle, 'focus');
                }
                callback();
            });
            this.subscriptions.add(subscription);
        });
    }
    getProps() {
        return {
            buttons: this.showButtons,
            disabled: this.disabled,
            fixedTickWidth: this.fixedTickWidth,
            largeStep: this.largeStep,
            max: this.max,
            min: this.min,
            readonly: this.readonly,
            reverse: this.reverse,
            rtl: this.localizationService.rtl,
            smallStep: this.smallStep,
            value: trimValue(this.max, this.min, this.value),
            vertical: this.vertical
        };
    }
    attachElementEventHandlers() {
        const hostElement = this.hostElement.nativeElement;
        let tabbing = false;
        let cursorInsideWrapper = false;
        this.ngZone.runOutsideAngular(() => {
            // focusIn and focusOut are relative to the host element
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {
                if (!this.isFocused) {
                    this.ngZone.run(() => {
                        if (!this.focusChangedProgrammatically) {
                            this.onFocus.emit();
                        }
                        this.focused = true;
                    });
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {
                if (!this.isFocused) {
                    return;
                }
                if (tabbing) {
                    if (args.relatedTarget !== this.draghandle.nativeElement) {
                        this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper) {
                        this.handleBlur();
                    }
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {
                cursorInsideWrapper = true;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {
                cursorInsideWrapper = false;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
        });
    }
}
SliderComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: SliderComponent, selectors: [["kendo-slider"]], factory: function SliderComponent_Factory(t) { return new (t || SliderComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(Injector), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, viewQuery: function SliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
        ɵngcc0.ɵɵviewQuery(_c2, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.draghandle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.decreaseButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.increaseButton = _t.first);
    } }, inputs: { focusableId: "focusableId", animate: "animate", showButtons: "showButtons", value: "value", tabIndex: "tabIndex", dragHandleTitle: "dragHandleTitle", incrementTitle: "incrementTitle", decrementTitle: "decrementTitle" }, exportAs: ["kendoSlider"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.slider' },
            { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => SliderComponent_1) },
            { provide: KendoInput, useExisting: forwardRef(() => SliderComponent_1) }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature()], consts: 14, vars: 21, template: function SliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, _c3);
        ɵngcc0.ɵɵi18nAttributes(1, _c10);
        ɵngcc0.ɵɵelementStart(2, "div", _c11, _c12);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵtemplate(4, SliderComponent_span_4_Template, 3, 3, "span", _c13);
        ɵngcc0.ɵɵtemplate(5, SliderComponent_span_5_Template, 3, 4, "span", _c14);
        ɵngcc0.ɵɵtemplate(6, SliderComponent_ul_6_Template, 2, 8, "ul", _c15);
        ɵngcc0.ɵɵelementStart(7, "div", _c16, _c17);
        ɵngcc0.ɵɵelement(9, "div", _c18, _c19);
        ɵngcc0.ɵɵelementStart(11, "a", _c20, _c21);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵlistener("kendoPress", function SliderComponent_Template_a_kendoPress_11_listener($event) { return ctx.ifEnabled(ctx.handleDragPress, $event); });
        ɵngcc0.ɵɵlistener("kendoDrag", function SliderComponent_Template_a_kendoDrag_11_listener($event) { return ctx.ifEnabled(ctx.onHandleDrag, $event); });
        ɵngcc0.ɵɵlistener("kendoRelease", function SliderComponent_Template_a_kendoRelease_11_listener($event) { return ctx.ifEnabled(ctx.onHandleRelease, $event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(13, "kendo-resize-sensor", _c22);
        ɵngcc0.ɵɵlistener("resize", function SliderComponent_Template_kendo_resize_sensor_resize_13_listener($event) { return ctx.sizeComponent(false); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵclassProp("k-slider-buttons", ctx.showButtons);
        ɵngcc0.ɵɵclassProp("k-slider-topleft", ctx.tickPlacement === "before");
        ɵngcc0.ɵɵclassProp("k-slider-bottomright", ctx.tickPlacement === "after");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(18, _c30, ctx.onWrapClick, ctx.onKeyDown));
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showButtons);
        ɵngcc0.ɵɵselect(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showButtons);
        ɵngcc0.ɵɵselect(6);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tickPlacement !== "none");
        ɵngcc0.ɵɵselect(11);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵproperty("title", ctx.dragHandleMessage)("id", ctx.focusableId);
        ɵngcc0.ɵɵattribute("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.currentValue)("aria-valuetext", ctx.currentValue)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("aria-orientation", ctx.vertical ? "vertical" : "horizontal")("tabindex", ctx.disabled ? "-1" : ctx.tabIndex);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(SliderComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoSlider',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.slider' },
                    { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => SliderComponent_1) },
                    { provide: KendoInput, useExisting: forwardRef(() => SliderComponent_1) }
                ],
                selector: 'kendo-slider',
                template: `
        <ng-container kendoSliderLocalizedMessages
            i18n-increment="kendo.slider.increment|The title of the **Increase** button of the Slider."
            increment="increment"
            i18n-decrement="kendo.slider.decrement|The title of the **Decrease** button of the Slider."
            decrement="decrement"
            i18n-dragHandle="kendo.slider.dragHandle|The title of the drag handle of the Slider."
            dragHandle="Drag"
        >
        <div class="k-slider-wrap" #wrap
            [class.k-slider-buttons]="showButtons"
            [class.k-slider-topleft]="tickPlacement === 'before'"
            [class.k-slider-bottomright]="tickPlacement === 'after'"
            [kendoEventsOutsideAngular]="{ click: onWrapClick, keydown: onKeyDown }"
            >
            <span
                #decreaseButton
                *ngIf="showButtons"
                class="k-button k-button-decrease"
                [title]="decrementMessage"
                role="presentation"
            >
                <span class="k-icon"
                    [class.k-i-arrow-w]="!vertical"
                    [class.k-i-arrow-s]="vertical"
                >
                </span>
            </span>
            <span
                *ngIf="showButtons"
                #increaseButton
                class="k-button k-button-increase"
                [title]="incrementMessage"
                (click)="$event.preventDefault()"
                [attr.aria-label]="currentValue"
            >
                <span class="k-icon"
                    [class.k-i-arrow-e]="!vertical"
                    [class.k-i-arrow-n]="vertical"
                >
                </span>
            </span>
            <ul kendoSliderTicks
                #ticks
                *ngIf="tickPlacement !== 'none'"
                [tickTitle]="title"
                [vertical]="vertical"
                [step]="smallStep"
                [largeStep]="largeStep"
                [min]="min"
                [max]="max"
                [labelTemplate]="labelTemplate?.templateRef"
                [attr.aria-hidden]="true"
            >
            </ul>
            <div #track class="k-slider-track">
                <div #sliderSelection class="k-slider-selection">
                </div>
                <a #draghandle
                    role="slider"
                    [attr.aria-valuemin]="min"
                    [attr.aria-valuemax]="max"
                    [attr.aria-valuenow]="currentValue"
                    [attr.aria-valuetext]="currentValue"
                    [attr.aria-disabled]="disabled ? true : undefined"
                    [attr.aria-readonly]="readonly ? true : undefined"
                    [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                    [style.touch-action]="isDisabled ? '' : 'none'"
                    class="k-draghandle"
                    [title]="dragHandleMessage"
                    [attr.tabindex]="disabled ? '-1' : tabIndex"
                    [id]="focusableId"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress, $event)"
                    (kendoDrag)="ifEnabled(onHandleDrag, $event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                ></a>
            </div>
            <kendo-resize-sensor (resize)="sizeComponent(false)"></kendo-resize-sensor>
        </div>
  `
            }]
    }], function () { return [{ type: LocalizationService }, { type: Injector }, { type: Renderer2 }, { type: NgZone }, { type: ChangeDetectorRef }, { type: ElementRef }]; }, { constructor: [], localization: [], injector: [], renderer: [], ngZone: [], changeDetector: [], hostElement: [], focusableId: [{
            type: Input
        }], animate: [{
            type: Input
        }], showButtons: [{
            type: Input
        }], value: [{
            type: Input
        }], focusChangedProgrammatically: [], onWrapClick: [], onKeyDown: [], ngChange: [], ngTouched: [], decreaseValue: [], increaseValue: [], handleBlur: [], focused: [], tabIndex: [{
            type: Input
        }], tabIndex: [], tabindex: [], currentValue: [], focus: [], blur: [], ngOnChanges: [], ngAfterViewInit: [], ngOnDestroy: [], incrementMessage: [], decrementMessage: [], dragHandleMessage: [], handleDragPress: [], onHandleDrag: [], dragging: [], onHandleRelease: [], writeValue: [], registerOnChange: [], registerOnTouched: [], changeValue: [], sizeComponent: [], isFocused: [], isDragged: [], setValueChangeInterval: [], getProps: [], attachElementEventHandlers: [], dragHandleTitle: [{
            type: Input
        }], incrementTitle: [{
            type: Input
        }], decrementTitle: [{
            type: Input
        }], draghandle: [{
            type: ViewChild,
            args: ['draghandle', { static: true }]
        }], decreaseButton: [{
            type: ViewChild,
            args: ['decreaseButton', { static: false }]
        }], increaseButton: [{
            type: ViewChild,
            args: ['increaseButton', { static: false }]
        }] });;
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], SliderComponent.prototype, "focusableId", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], SliderComponent.prototype, "dragHandleTitle", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], SliderComponent.prototype, "incrementTitle", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], SliderComponent.prototype, "animate", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], SliderComponent.prototype, "decrementTitle", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], SliderComponent.prototype, "showButtons", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], SliderComponent.prototype, "value", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], SliderComponent.prototype, "tabIndex", null);
tslib_1.__decorate([
    ViewChild('draghandle', { static: true }),
    tslib_1.__metadata("design:type", ElementRef)
], SliderComponent.prototype, "draghandle", void 0);
tslib_1.__decorate([
    ViewChild('decreaseButton', { static: false }),
    tslib_1.__metadata("design:type", ElementRef)
], SliderComponent.prototype, "decreaseButton", void 0);
tslib_1.__decorate([
    ViewChild('increaseButton', { static: false }),
    tslib_1.__metadata("design:type", ElementRef)
], SliderComponent.prototype, "increaseButton", void 0);
SliderComponent = SliderComponent_1 = tslib_1.__decorate([
    tslib_1.__metadata("design:paramtypes", [LocalizationService,
        Injector,
        Renderer2,
        NgZone,
        ChangeDetectorRef,
        ElementRef])
], SliderComponent);
export { SliderComponent };

//# sourceMappingURL=slider.component.js.map