{"version":3,"file":"textarea.component.js","sources":["/Users/paria/workspace/washIt/client/node_modules/@progress/kendo-angular-inputs/dist/es2015/textarea/textarea.component.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as tslib_1 from \"tslib\";\nvar TextAreaComponent_1;\nimport { Component, HostBinding, Input, Output, ElementRef, EventEmitter, NgZone, Renderer2, ChangeDetectorRef, Injector, forwardRef } from '@angular/core';\nimport { fromEvent } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\nimport { NG_VALUE_ACCESSOR, NgControl } from '@angular/forms';\nimport { KendoInput, guid, isDocumentAvailable, hasObservers, Keys } from '@progress/kendo-angular-common';\nimport { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { TextFieldsBase } from '../text-fields-common/text-fields-base';\nimport { areSame, isPresent } from '../common/utils';\nimport { invokeElementMethod } from '../common/dom-utils';\nimport { closest } from './../common/dom-utils';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { packageMetadata } from '../package-metadata';\nconst resizeClasses = {\n    'vertical': 'k-resize-vertical',\n    'horizontal': 'k-resize-horizontal',\n    'both': 'k-resize-both',\n    'none': 'k-resize-none',\n    'auto': 'k-resize-none'\n};\nconst FOCUSED = 'k-state-focus';\n/**\n * Represents the [Kendo UI TextArea component for Angular]({% slug overview_textarea %}).\n */\nlet TextAreaComponent = TextAreaComponent_1 = class TextAreaComponent extends TextFieldsBase {\n    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {\n        super(localizationService, ngZone, changeDetector, renderer, injector, hostElement);\n        this.localizationService = localizationService;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.renderer = renderer;\n        this.injector = injector;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        this.hostClass = true;\n        /**\n         * Specifies the flow direction of the TextArea sections. This property is useful when adornments are used, in order to specify\n         * their position in relation to the textarea element.\n         *\n         * The possible values are:\n         * * `vertical`(Default) &mdash;TextArea sections are placed from top to bottom.\n         * * `horizontal`&mdash;TextArea sections are placed from left to right in `ltr`, and from right to left in `rtl` mode.\n         */\n        this.flow = 'vertical';\n        /**\n         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Configures the resize behavior of the TextArea.\n         *\n         * The possible values are:\n         * * `vertical`(Default)&mdash;The TextArea component can be resized only vertically.\n         * * `horizontal`&mdash;The TextArea component can be resized only horizontally.\n         * * `both`&mdash;The TextArea component can be resized in both (horizontal and vertical) directions.\n         * * `auto`&mdash;Specifies whether the TextArea component will adjust its height automatically, based on the content.\n         * * `none`&mdash;The TextArea cannot be resized.\n         *\n         */\n        this.resizable = 'vertical';\n        /**\n         * Fires each time the user focuses the TextArea component.\n         *\n         * > To wire the event programmatically, use the `onFocus` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-textarea (focus)=\"handleFocus()\"></kendo-textarea>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleFocus(): void {\n         *      console.log('Component is focused');\n         *   }\n         * }\n         * ```\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * Fires each time the TextArea component gets blurred.\n         *\n         * > To wire the event programmatically, use the `onBlur` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-textarea (blur)=\"handleBlur()\"></kendo-textarea>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleBlur(): void {\n         *      console.log('Component is blurred');\n         *   }\n         * }\n         * ```\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * Fires each time the value is changed or the component is blurred\n         * ([see example]({% slug overview_textarea %}#toc-events)).\n         * When the component value is changed programmatically or via its form control binding, the valueChange event is not emitted.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.handleInput = (ev) => {\n            let incomingValue = ev.target.value;\n            this.updateValue(incomingValue);\n            this.resize();\n        };\n        /**\n         * @hidden\n         */\n        this.handleInputFocus = () => {\n            if (!this.disabled) {\n                if (this.selectOnFocus && this.value) {\n                    this.ngZone.run(() => {\n                        setTimeout(() => { this.selectAll(); });\n                    });\n                }\n                if (hasObservers(this.onFocus)) {\n                    if (!this.isFocused) {\n                        this.ngZone.run(() => {\n                            this.onFocus.emit();\n                        });\n                    }\n                }\n                if (hasObservers(this.inputFocus)) {\n                    if (!this.focusChangedProgrammatically) {\n                        this.ngZone.run(() => {\n                            this.inputFocus.emit();\n                        });\n                    }\n                }\n                this.ngZone.run(() => {\n                    this.isFocused = true;\n                });\n            }\n        };\n        validatePackage(packageMetadata);\n        this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    get flowCol() {\n        return this.flow === 'vertical';\n    }\n    get flowRow() {\n        return this.flow === 'horizontal';\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    ngAfterViewInit() {\n        const hostElement = this.hostElement.nativeElement;\n        let cursorInsideWrapper = false;\n        let tabbing = false;\n        this.ngZone.runOutsideAngular(() => {\n            // focusIn and focusOut are relative to the host element\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n                if (!this.isFocused) {\n                    this.ngZone.run(() => {\n                        this.onFocus.emit();\n                        this.isFocused = true;\n                    });\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {\n                if (!this.isFocused) {\n                    return;\n                }\n                if (tabbing) {\n                    const closestTextbox = closest(args.relatedTarget, (element) => element === this.hostElement.nativeElement);\n                    if (!closestTextbox) {\n                        this.handleBlur();\n                    }\n                    tabbing = false;\n                }\n                else {\n                    if (!cursorInsideWrapper) {\n                        this.handleBlur();\n                    }\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n                cursorInsideWrapper = true;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n                cursorInsideWrapper = false;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {\n                if (args.keyCode === Keys.Tab) {\n                    tabbing = true;\n                }\n                else {\n                    tabbing = false;\n                }\n            }));\n        });\n    }\n    ngOnInit() {\n        this.control = this.injector.get(NgControl, null);\n        if (isDocumentAvailable() && this.resizable === 'auto') {\n            this.resizeSubscription = fromEvent(window, 'resize')\n                .pipe((debounceTime(50)))\n                .subscribe(() => this.resize());\n        }\n        if (this.hostElement) {\n            this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n        }\n        this.subscriptions = this.localizationService.changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n    }\n    ngOnChanges(changes) {\n        const hostElement = this.hostElement.nativeElement;\n        const element = this.input.nativeElement;\n        if (changes.resizable) {\n            if (this.resizable === 'auto') {\n                this.initialHeight = element.offsetHeight;\n            }\n            else {\n                this.renderer.setStyle(element, 'overflow-y', 'auto');\n                this.renderer.setStyle(element, 'resize', 'both');\n                element.style.height = `${this.initialHeight}px`;\n            }\n        }\n        if (changes.cols) {\n            if (isPresent(changes.cols.currentValue)) {\n                this.renderer.setStyle(hostElement, 'width', 'auto');\n            }\n            else {\n                this.renderer.removeStyle(hostElement, 'width');\n            }\n        }\n    }\n    ngAfterViewChecked() {\n        this.resize();\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.value = value;\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    updateValue(value) {\n        if (!areSame(this.value, value)) {\n            this.ngZone.run(() => {\n                this.value = value;\n                this.ngChange(value);\n                this.valueChange.emit(value);\n                this.changeDetector.markForCheck();\n            });\n        }\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        if (this.resizeSubscription) {\n            this.resizeSubscription.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    get resizableClass() {\n        return resizeClasses[this.resizable];\n    }\n    /**\n     * Focuses the TextArea component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"textarea.focus()\">Focus the textarea</button>\n     *  <kendo-textarea #textarea></kendo-textarea>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.input) {\n            return;\n        }\n        this.focusChangedProgrammatically = true;\n        this.isFocused = true;\n        this.input.nativeElement.focus();\n        this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the TextArea component.\n     */\n    blur() {\n        this.focusChangedProgrammatically = true;\n        const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');\n        if (isFocusedElement) {\n            isFocusedElement.blur();\n        }\n        this.isFocused = false;\n        this.focusChangedProgrammatically = false;\n    }\n    resize() {\n        if (this.resizable !== 'auto') {\n            return;\n        }\n        const element = this.input.nativeElement;\n        this.renderer.setStyle(element, 'overflow-y', 'hidden');\n        this.renderer.setStyle(element, 'height', `${this.initialHeight}px`);\n        const scrollHeight = element.scrollHeight;\n        if (scrollHeight > this.initialHeight) {\n            element.style.height = `${scrollHeight}px`;\n        }\n    }\n    get isFocused() {\n        return this._isFocused;\n    }\n    set isFocused(value) {\n        if (this._isFocused !== value && this.hostElement) {\n            const element = this.hostElement.nativeElement;\n            if (value && !this.disabled) {\n                this.renderer.addClass(element, FOCUSED);\n            }\n            else {\n                this.renderer.removeClass(element, FOCUSED);\n            }\n            this._isFocused = value;\n        }\n    }\n    handleBlur() {\n        this.ngZone.run(() => {\n            if (!this.focusChangedProgrammatically) {\n                this.onBlur.emit();\n            }\n            this.isFocused = false;\n        });\n    }\n    setSelection(start, end) {\n        if (this.isFocused) {\n            invokeElementMethod(this.input, 'setSelectionRange', start, end);\n        }\n    }\n    selectAll() {\n        if (this.value) {\n            this.setSelection(0, this.value.length);\n        }\n    }\n};\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], TextAreaComponent.prototype, \"focusableId\", void 0);\ntslib_1.__decorate([\n    HostBinding('class.k-textarea'),\n    tslib_1.__metadata(\"design:type\", Boolean)\n], TextAreaComponent.prototype, \"hostClass\", void 0);\ntslib_1.__decorate([\n    HostBinding('class.k-flex-col'),\n    tslib_1.__metadata(\"design:type\", Boolean),\n    tslib_1.__metadata(\"design:paramtypes\", [])\n], TextAreaComponent.prototype, \"flowCol\", null);\ntslib_1.__decorate([\n    HostBinding('class.k-flex-row'),\n    tslib_1.__metadata(\"design:type\", Boolean),\n    tslib_1.__metadata(\"design:paramtypes\", [])\n], TextAreaComponent.prototype, \"flowRow\", null);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], TextAreaComponent.prototype, \"flow\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Number)\n], TextAreaComponent.prototype, \"rows\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Number)\n], TextAreaComponent.prototype, \"cols\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Number)\n], TextAreaComponent.prototype, \"maxlength\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Number)\n], TextAreaComponent.prototype, \"tabindex\", void 0);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", Number),\n    tslib_1.__metadata(\"design:paramtypes\", [Number])\n], TextAreaComponent.prototype, \"tabIndex\", null);\ntslib_1.__decorate([\n    Input(),\n    tslib_1.__metadata(\"design:type\", String)\n], TextAreaComponent.prototype, \"resizable\", void 0);\ntslib_1.__decorate([\n    Output('focus'),\n    tslib_1.__metadata(\"design:type\", EventEmitter)\n], TextAreaComponent.prototype, \"onFocus\", void 0);\ntslib_1.__decorate([\n    Output('blur'),\n    tslib_1.__metadata(\"design:type\", EventEmitter)\n], TextAreaComponent.prototype, \"onBlur\", void 0);\ntslib_1.__decorate([\n    Output(),\n    tslib_1.__metadata(\"design:type\", EventEmitter)\n], TextAreaComponent.prototype, \"valueChange\", void 0);\nTextAreaComponent = TextAreaComponent_1 = tslib_1.__decorate([\n    Component({\n        exportAs: 'kendoTextArea',\n        providers: [\n            LocalizationService,\n            { provide: L10N_PREFIX, useValue: 'kendo.textarea' },\n            {\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => TextAreaComponent_1),\n                multi: true\n            },\n            { provide: KendoInput, useExisting: forwardRef(() => TextAreaComponent_1) }\n        ],\n        selector: 'kendo-textarea',\n        template: `\n        <textarea\n            #input\n            [attr.aria-multiline]=\"true\"\n            [attr.aria-disabled]=\"disabled ? true : undefined\"\n            [attr.aria-readonly]=\"readonly ? true : undefined\"\n            class=\"k-input\"\n            [ngClass]=\"resizableClass\"\n            [id]=\"focusableId\"\n            [value]=\"value\"\n            [attr.placeholder]=\"placeholder\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [attr.rows]=\"rows\"\n            [attr.cols]=\"cols\"\n            [attr.tabindex]=\"tabIndex\"\n            [attr.title]=\"title\"\n            [attr.maxlength]=\"maxlength\"\n            [kendoEventsOutsideAngular]=\"{\n                focus: handleInputFocus,\n                blur: handleInputBlur,\n                input: handleInput}\">\n            </textarea>\n            <ng-content select=\"kendo-textarea-suffix\"></ng-content>\n    `\n    }),\n    tslib_1.__metadata(\"design:paramtypes\", [LocalizationService,\n        NgZone,\n        ChangeDetectorRef,\n        Renderer2,\n        Injector,\n        ElementRef])\n], TextAreaComponent);\nexport { TextAreaComponent };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAqXC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8DA4D6D,AAuCvD;;;;;;;;;"}