{"version":3,"file":"index.js","sources":["/Users/paria/workspace/washIt/client/node_modules/@progress/kendo-angular-inputs/dist/fesm2015/index.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { __decorate, __param, __metadata } from 'tslib';\nimport { isDevMode, Directive, Optional, TemplateRef, EventEmitter, Input, Output, HostBinding, ViewChild, ElementRef, ContentChild, Component, forwardRef, Injector, Renderer2, NgZone, ChangeDetectorRef, Inject, Injectable, HostListener, ViewChildren, QueryList, NgModule, ViewContainerRef, ContentChildren } from '@angular/core';\nimport { NgControl, NG_VALUE_ACCESSOR, NG_VALIDATORS, RadioControlValueAccessor } from '@angular/forms';\nimport { Subscription, fromEvent, interval, merge, Observable, Subject } from 'rxjs';\nimport { take, filter, concatMap, startWith, takeUntil, skip, debounceTime, throttleTime } from 'rxjs/operators';\nimport { LocalizationService, L10N_PREFIX, RTL, ComponentMessages, MessageService } from '@progress/kendo-angular-l10n';\nimport { Keys, guid, hasObservers, anyChanged, isDocumentAvailable, KendoInput, isChanged, DraggableModule, EventsModule, ResizeSensorModule } from '@progress/kendo-angular-common';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { browser, mobileOS, detectDesktopBrowser, detectMobileOS } from '@progress/kendo-common';\nimport { IntlService } from '@progress/kendo-angular-intl';\nimport { CommonModule } from '@angular/common';\nimport { PopupService, PopupModule } from '@progress/kendo-angular-popup';\nimport { Color, parseColor, namedColors } from '@progress/kendo-drawing';\n\n/**\n * @hidden\n *\n * Checks if the value is `null` or `undefined`. Falsy values like '', 0, false, NaN, etc. are regarded as present.\n */\nconst isPresent = (value) => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst areSame = (value1, value2) => value1 === value2 || (value1 === null && value2 === undefined) || (value1 === undefined && value2 === null);\n/**\n * @hidden\n */\nconst requiresZoneOnBlur = (ngControl) => ngControl &&\n    (!ngControl.touched || (ngControl.control && ngControl.control.updateOn === 'blur'));\n/**\n * @hidden\n *\n * Fits the contender number into the specified bounds. If the number is NaN or null, the min is returned.\n *\n * @param contender Represents the number you want to fit into specified bounds.\n * @param min The inclusive lower bound number.\n * @param max The inclusive upper bound number.\n */\nconst fitIntoBounds = (contender, min, max) => {\n    if (!isPresent(contender) || isNaN(contender)) {\n        return min;\n    }\n    return contender <= min ? min : contender >= max ? max : contender;\n};\n\n/**\n * @hidden\n */\nconst MAX_PRECISION = 20;\n/**\n * @hidden\n */\nconst limitPrecision = (precision) => Math.min(precision, MAX_PRECISION);\n/**\n * @hidden\n */\nconst fractionLength = (value) => {\n    return (String(value).split('.')[1] || \"\").length;\n};\nconst maxFractionLength = (value1, value2) => {\n    return Math.max(fractionLength(value1), fractionLength(value2));\n};\n/**\n * @hidden\n */\nconst toFixedPrecision = (value, precision) => {\n    const maxPrecision = limitPrecision(precision);\n    return parseFloat(value.toFixed(maxPrecision));\n};\n/**\n * @hidden\n */\nconst add = (value1, value2) => {\n    const maxPrecision = maxFractionLength(value1, value2);\n    return toFixedPrecision(value1 + value2, maxPrecision);\n};\n/**\n * @hidden\n */\nconst subtract = (value1, value2) => {\n    return add(value1, -value2);\n};\n/**\n * @hidden\n */\nconst multiply = (value1, value2) => {\n    const maxPrecision = fractionLength(value1) + fractionLength(value2);\n    return toFixedPrecision(value1 * value2, maxPrecision);\n};\n/**\n * @hidden\n */\nconst divide = (dividend, divisor) => {\n    if (divisor === 0) {\n        return NaN;\n    }\n    const power = maxFractionLength(dividend, divisor);\n    const correctionValue = Math.pow(10, power);\n    return ((correctionValue * dividend) / (correctionValue * divisor));\n};\n/**\n * @hidden\n */\nconst remainder = (dividend, divisor) => {\n    return Math.abs(subtract(dividend, multiply(divisor, Math.floor(divide(dividend, divisor)))));\n};\n\n/**\n * @hidden\n */\nconst calculateFixedTrackSize = ({ max, min, smallStep, fixedTickWidth }) => ((max - min) / smallStep) * fixedTickWidth;\n/**\n * @hidden\n */\nconst calculateTrackSize = (wrapperWidth, offset, showButtons = true) => {\n    const BUTTONS_COUNT = 2;\n    const trackOffset = showButtons ? parseFloat(offset) * BUTTONS_COUNT : 0;\n    const trackWidth = wrapperWidth - trackOffset;\n    return Math.floor(trackWidth);\n};\n/**\n * @hidden\n */\nconst calculateTicksCount = (min = 0, max = 0, smallStep = 1) => {\n    if (smallStep <= 0) {\n        throw new Error('Invalid argument: smallStep must be a positive number');\n    }\n    const adjustedRange = Math.abs(subtract(max, min));\n    const adjustedRatio = Math.floor(divide(adjustedRange, smallStep));\n    const result = add(adjustedRatio, 1);\n    return result;\n};\n/**\n * @hidden\n */\nconst calculateValueFromTick = (index, { max, min, smallStep, reverse, vertical }) => {\n    const value = add(min, multiply(index, smallStep));\n    return vertical || reverse ? Math.abs(subtract(value, max)) : value;\n};\n/**\n * @hidden\n */\nconst calculateHandlePosition = ({ handleWidth, trackWidth, min, max, reverse, value }) => {\n    const halfHandleWidth = Math.floor(handleWidth / 2);\n    const step = trackWidth / Math.abs(max - min);\n    let pos = isPresent(value) ? step * (value - min) : min;\n    if (reverse) {\n        pos = trackWidth - pos;\n    }\n    return Math.floor(pos - halfHandleWidth);\n};\n/**\n * @hidden\n */\nconst decreaseValueToStep = (value, { max, min, smallStep, largeStep }, large = false) => {\n    const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;\n    const stepValue = subtract(value, min);\n    let result;\n    const stepRemainder = remainder(stepValue, step);\n    if (stepRemainder === 0) {\n        result = subtract(stepValue, step);\n    }\n    else {\n        result = subtract(stepValue, stepRemainder);\n    }\n    return limitValue(add(result, min), min, max);\n};\n/**\n * @hidden\n */\nconst increaseValueToStep = (value, { max, min, smallStep, largeStep }, large = false) => {\n    const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;\n    const stepValue = subtract(value, min);\n    const stepRemainder = remainder(stepValue, step);\n    const result = add(subtract(stepValue, stepRemainder), step);\n    return limitValue(add(result, min), min, max);\n};\n/**\n * @hidden\n */\nconst isStartHandle = (dragHandle) => dragHandle.id.indexOf('k-start-handle') > -1;\n/**\n * @hidden\n */\nconst snapValue = (value, options) => {\n    const { smallStep, min, max } = options;\n    const limited = limitValue(value, min, max);\n    if (value !== limited) {\n        return limited;\n    }\n    const left = decreaseValueToStep(value, options);\n    const right = increaseValueToStep(value, options);\n    if ((value - min) % smallStep === 0) {\n        return value;\n    }\n    if (right - value <= (right - left) / 2) {\n        return right;\n    }\n    return left;\n};\n/**\n * @hidden\n */\nconst trimValue = (max, min, value) => {\n    if (value > max) {\n        return max;\n    }\n    if (value < min) {\n        return min;\n    }\n    return value;\n};\n/**\n * @hidden\n */\nconst trimValueRange = (max, min, value) => {\n    return value ? [trimValue(max, min, value[0]), trimValue(max, min, value[1])] : [min, min];\n};\n/**\n * @hidden\n */\nconst identity = (value) => value;\n/**\n * @hidden\n */\nconst isSameRange = (value1, value2) => areSame(value1[0], value2[0]) && areSame(value1[1], value2[1]);\n/**\n * @hidden\n */\nconst elementOffset = (element) => {\n    const box = element.getBoundingClientRect();\n    const documentElement = document.documentElement;\n    return {\n        left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),\n        top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0)\n    };\n};\n/**\n * @hidden\n */\nconst limitValue = (value, min, max) => {\n    return Math.max(Math.min(value, max), min);\n};\n/**\n * @hidden\n */\nconst eventValue = (eventArgs, scaleElement, options) => {\n    const { min, max, vertical, rtl } = options;\n    const trackOffset = elementOffset(scaleElement);\n    const offset = vertical ? eventArgs.pageY - trackOffset.top : eventArgs.pageX - trackOffset.left;\n    const scale = (max - min) / (vertical ? scaleElement.clientHeight : scaleElement.clientWidth);\n    const offsetValue = offset * scale;\n    let value = rtl || vertical ? max - offsetValue : min + offsetValue;\n    const stepFractionLength = fractionLength(options.smallStep);\n    value = toFixedPrecision(value, stepFractionLength + 1);\n    return snapValue(value, options);\n};\n/**\n * @hidden\n */\nconst isButton = (element) => {\n    return element.className.indexOf('k-button-increase') >= 0 || element.className.indexOf('k-button-decrease') >= 0;\n};\n/**\n * @hidden\n */\nconst increment = (options) => {\n    return increaseValueToStep(options.value, options);\n};\n/**\n * @hidden\n */\nconst decrement = (options) => {\n    return decreaseValueToStep(options.value, options);\n};\n/**\n * @hidden\n */\nconst incrementLarge = (options) => {\n    return increaseValueToStep(options.value, options, true);\n};\n/**\n * @hidden\n */\nconst decrementLarge = (options) => {\n    return decreaseValueToStep(options.value, options, true);\n};\n/**\n * @hidden\n */\nconst validateValue = (value) => {\n    if (isDevMode && value && value[0] > value[1]) {\n        throw new Error('[RangeSlider] The start value should not be greater than the end value.');\n    }\n};\n\n/**\n * @hidden\n */\nclass SliderModelBase {\n    constructor(props, wrapper, track, renderer) {\n        this.props = props;\n        this.wrapper = wrapper;\n        this.track = track;\n        this.renderer = renderer;\n        this.props = props;\n        this.wrapper = wrapper;\n        this.track = track;\n        this.tickSizes = this.getTickSizes();\n    }\n    resizeTrack() {\n        const orientation = this.props.vertical ? 'height' : 'width';\n        const trackWidth = this.trackWidth();\n        this.track.style[orientation] = `${trackWidth}px`;\n    }\n    resizeTicks(ticksContainer, ticks) {\n        const dimension = this.props.vertical ? \"height\" : \"width\";\n        [...ticks].map((tick, index) => tick.style[dimension] = `${this.tickSizes[index]}px`);\n        if (this.props.vertical) {\n            this.adjustPadding(ticksContainer);\n        }\n    }\n    resizeWrapper() {\n        const dimension = this.props.vertical ? \"height\" : \"width\";\n        const wrapperSize = this.elementSize(this.wrapper);\n        const trackWidth = calculateTrackSize(wrapperSize, this.elementOffset(this.track));\n        const fixedTrackWidth = calculateFixedTrackSize(this.props);\n        const wrapperParentEl = this.wrapper.parentElement;\n        if (trackWidth > fixedTrackWidth) {\n            wrapperParentEl.style[dimension] = `${wrapperSize - (trackWidth - fixedTrackWidth)}px`;\n        }\n        else {\n            wrapperParentEl.style[dimension] = `${wrapperSize + (fixedTrackWidth - trackWidth)}px`;\n        }\n    }\n    trackWidth() {\n        if (this.props.fixedTickWidth) {\n            return calculateFixedTrackSize(this.props);\n        }\n        return calculateTrackSize(this.elementSize(this.wrapper), this.elementOffset(this.track), this.props.buttons);\n    }\n    getTickSizes() {\n        const { min, max, smallStep } = this.props;\n        const count = calculateTicksCount(min, max, smallStep);\n        const trackSize = this.trackWidth();\n        const distStep = trackSize / subtract(max, min);\n        const result = [];\n        let usedSpace = 0;\n        let endPoint = 0;\n        for (let i = 0; i < count; i++) {\n            if (i === 0 || i === count - 1) {\n                endPoint += (smallStep / 2) * distStep;\n            }\n            else {\n                endPoint += smallStep * distStep;\n            }\n            // ensure that the sum of the tick sizes does not exceed the track width\n            endPoint = +endPoint.toFixed(2) - 0.01;\n            const size = Math.round(endPoint - usedSpace);\n            result.push(size);\n            usedSpace += size;\n        }\n        if (usedSpace >= trackSize) {\n            result[result.length - 1] -= 1;\n        }\n        return result;\n    }\n    adjustPadding(ticksContainer) {\n        const totalTickSize = this.tickSizes.reduce((prev, curr) => prev + curr, 0);\n        const trackWidth = this.trackWidth();\n        const reminder = trackWidth - totalTickSize;\n        if (reminder !== 0) {\n            const padding = reminder + this.elementOffset(this.track);\n            ticksContainer.style.paddingTop = `${padding}px`;\n        }\n    }\n    elementOffset(element) {\n        const { vertical } = this.props;\n        const style = getComputedStyle(element);\n        return parseInt(vertical ? style.bottom : style.left, 10);\n    }\n    elementSize(element) {\n        const { vertical } = this.props;\n        return vertical ? element.clientHeight : element.clientWidth;\n    }\n}\n\n/**\n * @hidden\n */\nclass SliderModel extends SliderModelBase {\n    positionHandle(dragHandle) {\n        const { max, min, reverse, vertical } = this.props;\n        const position = vertical ? 'bottom' : 'left';\n        const trackWidth = this.trackWidth();\n        const value = trimValue(max, min, this.props.value);\n        this.handlePosition = calculateHandlePosition({\n            min,\n            max,\n            reverse,\n            value,\n            trackWidth,\n            handleWidth: dragHandle.offsetWidth\n        });\n        this.renderer.setStyle(dragHandle, position, `${this.handlePosition}px`);\n    }\n    positionSelection(dragHandle, selection) {\n        const { reverse, vertical } = this.props;\n        const dimension = vertical ? 'height' : 'width';\n        const handleWidth = Math.floor(dragHandle.offsetWidth / 2);\n        let size = this.handlePosition + handleWidth;\n        if (reverse) {\n            size = this.trackWidth() - size;\n        }\n        this.renderer.setStyle(selection, dimension, `${size}px`);\n    }\n}\n\nconst UNTOUCHED = 'ng-untouched';\nconst toClassList = (classNames) => String(classNames).trim().split(' ');\n/**\n * @hidden\n */\nconst hasClass = (element, className) => Boolean(toClassList(element.className).find((name) => name === className));\n/**\n * @hidden\n */\nfunction invokeElementMethod(element, name, ...args) {\n    if (element && element.nativeElement) {\n        return element.nativeElement[name].apply(element.nativeElement, args);\n    }\n}\n/**\n * @hidden\n */\nconst isUntouched = (element) => element && element.nativeElement && hasClass(element.nativeElement, UNTOUCHED);\n/**\n * @hidden\n */\nconst containsFocus = (hostElement, contender) => hostElement && contender && (hostElement === contender || hostElement.contains(contender));\n/**\n * @hidden\n */\nconst closest = (node, predicate) => {\n    while (node && !predicate(node)) {\n        node = node.parentNode;\n    }\n    return node;\n};\n\n/**\n * @hidden\n */\nconst packageMetadata = {\n    name: '@progress/kendo-angular-inputs',\n    productName: 'Kendo UI for Angular',\n    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n    publishDate: 1637576485,\n    version: '',\n    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n\n/**\n * Represents the template for the labels of the Slider.\n * To define the labels template, nest an `<ng-template>` tag with the `kendoSliderLabelTemplate` directive inside\n * the `<kendo-slider>` tag. The template context is passed to the `label` value.\n *\n * @example\n * ```ts-no-run\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-slider [largeStep]=\"2\">\n *           <ng-template kendoSliderLabelTemplate let-value=\"value\">\n *             <b>{{value}}</b>\n *           </ng-template>\n *         </kendo-slider>\n *     `\n * })\n *\n * class AppComponent {\n * }\n *\n * ```\n */\nlet LabelTemplateDirective = class LabelTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n};\nLabelTemplateDirective = __decorate([\n    Directive({\n        selector: '[kendoSliderLabelTemplate]'\n    }),\n    __param(0, Optional()),\n    __metadata(\"design:paramtypes\", [TemplateRef])\n], LabelTemplateDirective);\n\n/**\n * @hidden\n */\nclass SliderBase {\n    constructor(localizationService, injector, renderer, ngZone, changeDetector, hostElement) {\n        this.localizationService = localizationService;\n        this.injector = injector;\n        this.renderer = renderer;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.hostElement = hostElement;\n        /**\n         * Defines the title of the ticks ([see example]({% slug ticks_slider %}#toc-titles)). The default title\n         * for each tick is its Slider value. If you use a callback function, the function accepts an argument\n         * that holds the value of the component and returns a string with the new title.\n         */\n        this.title = identity;\n        /**\n         * Denotes the location of the tick marks in the Slider ([see example]({% slug ticks_slider %}#toc-placement)).\n         *\n         * The available options are:\n         * * `before`&mdash;The tick marks are located to the top side of the horizontal track or to the left side of a vertical track.\n         * * `after`&mdash;The tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.\n         * * `both`&mdash; (Default) The tick marks are located on both sides of the track.\n         * * `none`&mdash;The tick marks are not visible. The actual elements are not added to the DOM tree.\n         */\n        this.tickPlacement = 'both';\n        /**\n         * If `vertical` is set to `true`, the orientation of the Slider changes from horizontal to vertical\n         * ([see example]({% slug orientation_slider %})).\n         */\n        this.vertical = false;\n        /**\n         * The minimum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n         * The attribute accepts both integers and floating-point numbers.\n         */\n        this.min = 0;\n        /**\n         * The maximum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n         * The attribute accepts both integers and floating-point numbers.\n         */\n        this.max = 10;\n        /**\n         * The step value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n         * Accepts positive values only. Can be an integer or a floating-point number.\n         */\n        this.smallStep = 1;\n        /**\n         * Specifies that every n<sup>th</sup> tick will be large and will have a label\n         * ([see example]({% slug predefinedsteps_slider %}#toc-large-steps)).\n         * Accepts positive integer values only.\n         */\n        this.largeStep = null;\n        /**\n         * Determines whether the Slider is disabled ([see example]({% slug disabledstate_slider %})).\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the Slider is in its read-only state ([see example]({% slug readonly_slider %})).\n         */\n        this.readonly = false;\n        /**\n         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Slider.\n         */\n        this.tabindex = 0;\n        /**\n         * Fires each time the user focuses the component.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the component is blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the user selects a new value.\n         */\n        this.valueChange = new EventEmitter();\n        this.sliderClass = true;\n        this.widgetClass = true;\n        this.subscriptions = new Subscription();\n        /**\n         * @hidden\n         */\n        this.ifEnabled = (callback, event) => {\n            if (!this.isDisabled) {\n                callback.call(this, event);\n            }\n        };\n        validatePackage(packageMetadata);\n        this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    get horizontalClass() {\n        return !this.vertical;\n    }\n    get verticalClass() {\n        return this.vertical;\n    }\n    get disabledClass() {\n        return this.disabled;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n        this.changeDetector.markForCheck();\n        this.disabled = isDisabled;\n    }\n    ngOnInit() {\n        this.subscriptions.add(this.localizationService\n            .changes\n            .subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n            this.sizeComponent();\n        }));\n        if (this.hostElement) {\n            this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n        }\n        this.control = this.injector.get(NgControl, null);\n    }\n    /**\n     * @hidden\n     */\n    get isDisabled() {\n        return this.disabled || this.readonly;\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    get reverse() {\n        return this.localizationService.rtl && !this.vertical;\n    }\n    get keyBinding() {\n        const reverse = this.reverse;\n        return {\n            [Keys.ArrowLeft]: reverse ? increment : decrement,\n            [Keys.ArrowRight]: reverse ? decrement : increment,\n            [Keys.ArrowDown]: decrement,\n            [Keys.ArrowUp]: increment,\n            [Keys.PageUp]: incrementLarge,\n            [Keys.PageDown]: decrementLarge,\n            [Keys.Home]: ({ min }) => min,\n            [Keys.End]: ({ max }) => max\n        };\n    }\n    resetStyles(elements) {\n        elements.forEach(el => {\n            if (el) {\n                if (this.vertical) {\n                    this.renderer.removeStyle(el, 'width');\n                    this.renderer.removeStyle(el, 'left');\n                    this.renderer.removeStyle(el, 'right');\n                }\n                else {\n                    this.renderer.removeStyle(el, 'height');\n                    this.renderer.removeStyle(el, 'bottom');\n                }\n                this.renderer.removeStyle(el, 'padding-top');\n            }\n        });\n    }\n}\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Function)\n], SliderBase.prototype, \"title\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], SliderBase.prototype, \"tickPlacement\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], SliderBase.prototype, \"vertical\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], SliderBase.prototype, \"min\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], SliderBase.prototype, \"max\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], SliderBase.prototype, \"smallStep\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], SliderBase.prototype, \"largeStep\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], SliderBase.prototype, \"fixedTickWidth\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], SliderBase.prototype, \"disabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], SliderBase.prototype, \"readonly\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], SliderBase.prototype, \"tabindex\", void 0);\n__decorate([\n    Output('focus'),\n    __metadata(\"design:type\", EventEmitter)\n], SliderBase.prototype, \"onFocus\", void 0);\n__decorate([\n    Output('blur'),\n    __metadata(\"design:type\", EventEmitter)\n], SliderBase.prototype, \"onBlur\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], SliderBase.prototype, \"valueChange\", void 0);\n__decorate([\n    HostBinding('attr.dir'),\n    __metadata(\"design:type\", String)\n], SliderBase.prototype, \"direction\", void 0);\n__decorate([\n    HostBinding('class.k-slider-horizontal'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], SliderBase.prototype, \"horizontalClass\", null);\n__decorate([\n    HostBinding('class.k-slider-vertical'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], SliderBase.prototype, \"verticalClass\", null);\n__decorate([\n    HostBinding('class.k-slider'),\n    __metadata(\"design:type\", Boolean)\n], SliderBase.prototype, \"sliderClass\", void 0);\n__decorate([\n    HostBinding('class.k-widget'),\n    __metadata(\"design:type\", Boolean)\n], SliderBase.prototype, \"widgetClass\", void 0);\n__decorate([\n    HostBinding('class.k-state-disabled'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], SliderBase.prototype, \"disabledClass\", null);\n__decorate([\n    ViewChild('wrap', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], SliderBase.prototype, \"wrapper\", void 0);\n__decorate([\n    ViewChild('track', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], SliderBase.prototype, \"track\", void 0);\n__decorate([\n    ViewChild('sliderSelection', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], SliderBase.prototype, \"sliderSelection\", void 0);\n__decorate([\n    ViewChild('ticks', { read: ElementRef, static: false }),\n    __metadata(\"design:type\", ElementRef)\n], SliderBase.prototype, \"ticksContainer\", void 0);\n__decorate([\n    ViewChild('ticks', { static: false }),\n    __metadata(\"design:type\", Object)\n], SliderBase.prototype, \"ticks\", void 0);\n__decorate([\n    ContentChild(LabelTemplateDirective, { static: false }),\n    __metadata(\"design:type\", LabelTemplateDirective)\n], SliderBase.prototype, \"labelTemplate\", void 0);\n\nvar SliderComponent_1;\nconst PRESSED = 'k-pressed';\n/**\n * Represents the [Kendo UI Slider component for Angular]({% slug overview_slider %}).\n */\nlet SliderComponent = SliderComponent_1 = class SliderComponent extends SliderBase {\n    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {\n        super(localization, injector, renderer, ngZone, changeDetector, hostElement);\n        this.localization = localization;\n        this.injector = injector;\n        this.renderer = renderer;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Determines if the animation will be played on value change.\n         * Regardless of this setting, no animation will be played during the initial rendering.\n         */\n        this.animate = true;\n        /**\n         * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).\n         * When `showButtons` is set to `false`, the buttons are not displayed.\n         */\n        this.showButtons = true;\n        /**\n         * The current value of the Slider when it is initially displayed.\n         * The component can use either NgModel or the `value` binding but not both of them at the same time.\n         */\n        this.value = this.min;\n        this.focusChangedProgrammatically = false;\n        /**\n         * @hidden\n         */\n        this.onWrapClick = (args) => {\n            const target = args.target;\n            if (!this.isDisabled && !(isButton(target) || isButton(target.parentNode))) {\n                const value = eventValue(args, this.track.nativeElement, this.getProps());\n                this.changeValue(value);\n            }\n            invokeElementMethod(this.draghandle, 'focus');\n        };\n        /**\n         * @hidden\n         */\n        this.onKeyDown = (e) => {\n            const options = this.getProps();\n            const { max, min } = options;\n            const handler = this.keyBinding[e.keyCode];\n            if (this.isDisabled || !handler) {\n                return;\n            }\n            const value = handler(options);\n            this.changeValue(trimValue(max, min, value));\n            e.preventDefault();\n        };\n        this.ngChange = (_) => { };\n        this.ngTouched = () => { };\n        this.decreaseValue = () => {\n            this.changeValue(decreaseValueToStep(this.value, this.getProps()));\n        };\n        this.increaseValue = () => {\n            this.changeValue(increaseValueToStep(this.value, this.getProps()));\n        };\n        this.handleBlur = () => {\n            this.changeDetector.markForCheck();\n            this.focused = false;\n            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.ngTouched();\n                    if (!this.focusChangedProgrammatically) {\n                        this.onBlur.emit();\n                    }\n                });\n            }\n        };\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    /**\n     * @hidden\n     */\n    get currentValue() {\n        return isPresent(this.value) ? this.value.toString() : '';\n    }\n    /**\n     * Focuses the Slider.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"slider.focus()\">Focus</button>\n     *  <kendo-slider #slider></kendo-slider>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.disabled) {\n            this.focusChangedProgrammatically = true;\n            invokeElementMethod(this.draghandle, 'focus');\n            this.focusChangedProgrammatically = false;\n        }\n    }\n    /**\n     * Blurs the Slider.\n     */\n    blur() {\n        this.focusChangedProgrammatically = true;\n        invokeElementMethod(this.draghandle, 'blur');\n        this.handleBlur();\n        this.focusChangedProgrammatically = false;\n    }\n    ngOnChanges(changes) {\n        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {\n            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n                this.sizeComponent(false);\n            });\n        }\n    }\n    ngAfterViewInit() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        if (this.showButtons) {\n            this.setValueChangeInterval(this.increaseButton.nativeElement, () => this.increaseValue());\n            this.setValueChangeInterval(this.decreaseButton.nativeElement, () => this.decreaseValue());\n        }\n        this.sizeComponent(false);\n        if (this.ticks) {\n            this.ticks.tickElements\n                .changes\n                .subscribe(() => this.sizeComponent(false));\n        }\n        this.attachElementEventHandlers();\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    get incrementMessage() {\n        return this.incrementTitle || this.localizationService.get('increment');\n    }\n    /**\n     * @hidden\n     */\n    get decrementMessage() {\n        return this.decrementTitle || this.localizationService.get('decrement');\n    }\n    /**\n     * @hidden\n     */\n    get dragHandleMessage() {\n        return this.dragHandleTitle || this.localizationService.get('dragHandle');\n    }\n    /**\n     * @hidden\n     */\n    handleDragPress(args) {\n        if (args.originalEvent) {\n            args.originalEvent.preventDefault();\n        }\n        this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    }\n    /**\n     * @hidden\n     */\n    onHandleDrag(args) {\n        this.dragging = true;\n        this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));\n    }\n    /**\n     * @hidden\n     */\n    onHandleRelease() {\n        this.dragging = false; //needed for animation\n        this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    }\n    //ngModel binding\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.changeDetector.markForCheck();\n        this.value = value;\n        this.sizeComponent(this.animate);\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    changeValue(value) {\n        if (!areSame(this.value, value)) {\n            this.ngZone.run(() => {\n                this.value = value;\n                this.ngChange(value);\n                this.valueChange.emit(value);\n                this.sizeComponent(this.animate);\n                this.changeDetector.markForCheck();\n            });\n        }\n    }\n    /**\n     * @hidden\n     */\n    sizeComponent(animate) {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        const wrapper = this.wrapper.nativeElement;\n        const track = this.track.nativeElement;\n        const selectionEl = this.sliderSelection.nativeElement;\n        const dragHandleEl = this.draghandle.nativeElement;\n        const ticks = this.ticks ? this.ticksContainer.nativeElement : null;\n        if (!animate) {\n            this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n        }\n        this.resetStyles([track, selectionEl, dragHandleEl, ticks, this.hostElement.nativeElement]);\n        const props = this.getProps();\n        const model = new SliderModel(props, wrapper, track, this.renderer);\n        model.resizeTrack();\n        if (this.ticks) { //for case when tickPlacement: none\n            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));\n        }\n        model.positionHandle(dragHandleEl);\n        model.positionSelection(dragHandleEl, selectionEl);\n        if (!animate) {\n            this.hostElement.nativeElement.getBoundingClientRect();\n            this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n        }\n        if (this.fixedTickWidth) {\n            model.resizeWrapper();\n        }\n    }\n    set focused(value) {\n        if (this.isFocused !== value && this.hostElement) {\n            this.isFocused = value;\n        }\n    }\n    set dragging(value) {\n        if (this.isDragged !== value && this.sliderSelection && this.draghandle) {\n            const sliderSelection = this.sliderSelection.nativeElement;\n            const draghandle = this.draghandle.nativeElement;\n            if (value) {\n                this.renderer.addClass(sliderSelection, PRESSED);\n                this.renderer.addClass(draghandle, PRESSED);\n            }\n            else {\n                this.renderer.removeClass(sliderSelection, PRESSED);\n                this.renderer.removeClass(draghandle, PRESSED);\n            }\n            this.isDragged = value;\n        }\n    }\n    setValueChangeInterval(element, callback) {\n        this.ngZone.runOutsideAngular(() => {\n            const mousedown = fromEvent(element, 'mousedown');\n            const mouseup = fromEvent(element, 'mouseup');\n            const mouseout = fromEvent(element, 'mouseout');\n            const subscription = mousedown.pipe(filter((e) => e.button === 0 && !this.isDisabled), concatMap(() => interval(150).pipe(startWith(-1), takeUntil(merge(mouseup, mouseout))))).subscribe(() => {\n                if (!this.isFocused) {\n                    invokeElementMethod(this.draghandle, 'focus');\n                }\n                callback();\n            });\n            this.subscriptions.add(subscription);\n        });\n    }\n    getProps() {\n        return {\n            buttons: this.showButtons,\n            disabled: this.disabled,\n            fixedTickWidth: this.fixedTickWidth,\n            largeStep: this.largeStep,\n            max: this.max,\n            min: this.min,\n            readonly: this.readonly,\n            reverse: this.reverse,\n            rtl: this.localizationService.rtl,\n            smallStep: this.smallStep,\n            value: trimValue(this.max, this.min, this.value),\n            vertical: this.vertical\n        };\n    }\n    attachElementEventHandlers() {\n        const hostElement = this.hostElement.nativeElement;\n        let tabbing = false;\n        let cursorInsideWrapper = false;\n        this.ngZone.runOutsideAngular(() => {\n            // focusIn and focusOut are relative to the host element\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n                if (!this.isFocused) {\n                    this.ngZone.run(() => {\n                        if (!this.focusChangedProgrammatically) {\n                            this.onFocus.emit();\n                        }\n                        this.focused = true;\n                    });\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {\n                if (!this.isFocused) {\n                    return;\n                }\n                if (tabbing) {\n                    if (args.relatedTarget !== this.draghandle.nativeElement) {\n                        this.handleBlur();\n                    }\n                    tabbing = false;\n                }\n                else {\n                    if (!cursorInsideWrapper) {\n                        this.handleBlur();\n                    }\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n                cursorInsideWrapper = true;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n                cursorInsideWrapper = false;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {\n                if (args.keyCode === Keys.Tab) {\n                    tabbing = true;\n                }\n                else {\n                    tabbing = false;\n                }\n            }));\n        });\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], SliderComponent.prototype, \"focusableId\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], SliderComponent.prototype, \"dragHandleTitle\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], SliderComponent.prototype, \"incrementTitle\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], SliderComponent.prototype, \"animate\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], SliderComponent.prototype, \"decrementTitle\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], SliderComponent.prototype, \"showButtons\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], SliderComponent.prototype, \"value\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], SliderComponent.prototype, \"tabIndex\", null);\n__decorate([\n    ViewChild('draghandle', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], SliderComponent.prototype, \"draghandle\", void 0);\n__decorate([\n    ViewChild('decreaseButton', { static: false }),\n    __metadata(\"design:type\", ElementRef)\n], SliderComponent.prototype, \"decreaseButton\", void 0);\n__decorate([\n    ViewChild('increaseButton', { static: false }),\n    __metadata(\"design:type\", ElementRef)\n], SliderComponent.prototype, \"increaseButton\", void 0);\nSliderComponent = SliderComponent_1 = __decorate([\n    Component({\n        exportAs: 'kendoSlider',\n        providers: [\n            LocalizationService,\n            { provide: L10N_PREFIX, useValue: 'kendo.slider' },\n            { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => SliderComponent_1) },\n            { provide: KendoInput, useExisting: forwardRef(() => SliderComponent_1) }\n        ],\n        selector: 'kendo-slider',\n        template: `\n        <ng-container kendoSliderLocalizedMessages\n            i18n-increment=\"kendo.slider.increment|The title of the **Increase** button of the Slider.\"\n            increment=\"increment\"\n            i18n-decrement=\"kendo.slider.decrement|The title of the **Decrease** button of the Slider.\"\n            decrement=\"decrement\"\n            i18n-dragHandle=\"kendo.slider.dragHandle|The title of the drag handle of the Slider.\"\n            dragHandle=\"Drag\"\n        >\n        <div class=\"k-slider-wrap\" #wrap\n            [class.k-slider-buttons]=\"showButtons\"\n            [class.k-slider-topleft]=\"tickPlacement === 'before'\"\n            [class.k-slider-bottomright]=\"tickPlacement === 'after'\"\n            [kendoEventsOutsideAngular]=\"{ click: onWrapClick, keydown: onKeyDown }\"\n            >\n            <span\n                #decreaseButton\n                *ngIf=\"showButtons\"\n                class=\"k-button k-button-decrease\"\n                [title]=\"decrementMessage\"\n                role=\"presentation\"\n            >\n                <span class=\"k-icon\"\n                    [class.k-i-arrow-w]=\"!vertical\"\n                    [class.k-i-arrow-s]=\"vertical\"\n                >\n                </span>\n            </span>\n            <span\n                *ngIf=\"showButtons\"\n                #increaseButton\n                class=\"k-button k-button-increase\"\n                [title]=\"incrementMessage\"\n                (click)=\"$event.preventDefault()\"\n                [attr.aria-label]=\"currentValue\"\n            >\n                <span class=\"k-icon\"\n                    [class.k-i-arrow-e]=\"!vertical\"\n                    [class.k-i-arrow-n]=\"vertical\"\n                >\n                </span>\n            </span>\n            <ul kendoSliderTicks\n                #ticks\n                *ngIf=\"tickPlacement !== 'none'\"\n                [tickTitle]=\"title\"\n                [vertical]=\"vertical\"\n                [step]=\"smallStep\"\n                [largeStep]=\"largeStep\"\n                [min]=\"min\"\n                [max]=\"max\"\n                [labelTemplate]=\"labelTemplate?.templateRef\"\n                [attr.aria-hidden]=\"true\"\n            >\n            </ul>\n            <div #track class=\"k-slider-track\">\n                <div #sliderSelection class=\"k-slider-selection\">\n                </div>\n                <a #draghandle\n                    role=\"slider\"\n                    [attr.aria-valuemin]=\"min\"\n                    [attr.aria-valuemax]=\"max\"\n                    [attr.aria-valuenow]=\"currentValue\"\n                    [attr.aria-valuetext]=\"currentValue\"\n                    [attr.aria-disabled]=\"disabled ? true : undefined\"\n                    [attr.aria-readonly]=\"readonly ? true : undefined\"\n                    [attr.aria-orientation]=\"vertical ? 'vertical' : 'horizontal'\"\n                    [style.touch-action]=\"isDisabled ? '' : 'none'\"\n                    class=\"k-draghandle\"\n                    [title]=\"dragHandleMessage\"\n                    [attr.tabindex]=\"disabled ? '-1' : tabIndex\"\n                    [id]=\"focusableId\"\n                    kendoDraggable\n                    (kendoPress)=\"ifEnabled(handleDragPress, $event)\"\n                    (kendoDrag)=\"ifEnabled(onHandleDrag, $event)\"\n                    (kendoRelease)=\"ifEnabled(onHandleRelease, $event)\"\n                ></a>\n            </div>\n            <kendo-resize-sensor (resize)=\"sizeComponent(false)\"></kendo-resize-sensor>\n        </div>\n  `\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService,\n        Injector,\n        Renderer2,\n        NgZone,\n        ChangeDetectorRef,\n        ElementRef])\n], SliderComponent);\n\n/**\n * @hidden\n */\nclass RangeSliderModel extends SliderModelBase {\n    positionHandle(dragHandle) {\n        if (!dragHandle.id) {\n            return;\n        }\n        const { max, min, reverse, vertical } = this.props;\n        const position = vertical ? 'bottom' : 'left';\n        const trackWidth = this.trackWidth();\n        const value = isStartHandle(dragHandle) ? trimValueRange(max, min, this.props.value)[0]\n            : trimValueRange(max, min, this.props.value)[1];\n        if (isStartHandle(dragHandle)) {\n            this.startHandlePosition = calculateHandlePosition({\n                min,\n                max,\n                reverse,\n                value,\n                trackWidth,\n                handleWidth: dragHandle.offsetWidth\n            });\n            this.renderer.setStyle(dragHandle, position, `${this.startHandlePosition}px`);\n        }\n        else {\n            this.endHandlePosition = calculateHandlePosition({\n                min,\n                max,\n                reverse,\n                value,\n                trackWidth,\n                handleWidth: dragHandle.offsetWidth\n            });\n            this.renderer.setStyle(dragHandle, position, `${this.endHandlePosition}px`);\n        }\n    }\n    positionSelection(dragHandle, selection) {\n        const { reverse, vertical } = this.props;\n        const dimension = vertical ? 'height' : 'width';\n        const position = vertical ? 'bottom' : reverse ? 'right' : 'left';\n        const handleWidth = Math.floor(dragHandle.offsetWidth / 2);\n        const size = Math.abs(this.endHandlePosition - this.startHandlePosition);\n        const currentSelectionPosition = vertical ? dragHandle.style.bottom : dragHandle.style.left;\n        this.renderer.setStyle(selection, dimension, `${size}px`);\n        this.renderer.setStyle(selection, position, reverse ? this.trackWidth() - parseFloat(currentSelectionPosition) - handleWidth + 'px'\n            : parseFloat(currentSelectionPosition) + handleWidth + 'px');\n    }\n}\n\nvar RangeSliderComponent_1;\nconst PRESSED$1 = 'k-pressed';\n/**\n * Represents the [Kendo UI RangeSlider component for Angular]({% slug overview_rangeslider %}).\n */\nlet RangeSliderComponent = RangeSliderComponent_1 = class RangeSliderComponent extends SliderBase {\n    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {\n        super(localization, injector, renderer, ngZone, changeDetector, hostElement);\n        this.localization = localization;\n        this.injector = injector;\n        this.renderer = renderer;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.startHandleId = `k-start-handle-${guid()}`;\n        /**\n         * @hidden\n         */\n        this.endHandleId = `k-end-handle-${guid()}`;\n        /**\n         * @hidden\n         */\n        this.focusableId = this.startHandleId;\n        this.handleZIndex = 0;\n        this.activeHandle = 'startHandle';\n        this.focusChangedProgrammatically = false;\n        /**\n         * @hidden\n         */\n        this.onWrapClick = (args) => {\n            if (!this.isDisabled) {\n                this.value = this.value || [this.min, this.min];\n                const trackValue = eventValue(args, this.track.nativeElement, this.getProps());\n                let newRangeValue;\n                const [startValue, endValue] = newRangeValue = this.value;\n                if (trackValue <= startValue) {\n                    newRangeValue = [trackValue, endValue];\n                    this.activeHandle = 'startHandle';\n                }\n                else if (startValue < trackValue && trackValue < endValue) {\n                    if (trackValue < (startValue + endValue) / 2) {\n                        newRangeValue = [trackValue, endValue];\n                        this.activeHandle = 'startHandle';\n                    }\n                    else {\n                        newRangeValue = [startValue, trackValue];\n                        this.activeHandle = 'endHandle';\n                    }\n                }\n                else if (trackValue >= endValue) {\n                    newRangeValue = [startValue, trackValue];\n                    this.activeHandle = 'endHandle';\n                }\n                const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;\n                invokeElementMethod(activeHandle, 'focus');\n                this.changeValue(newRangeValue);\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.onKeyDown = (e) => {\n            this.value = this.value || [this.min, this.min];\n            const options = this.getProps();\n            const { max, min } = options;\n            const handler = this.keyBinding[e.keyCode];\n            if (this.isDisabled || !handler) {\n                return;\n            }\n            this.renderer.setStyle(e.target, 'zIndex', ++this.handleZIndex);\n            const startHandleIsActive = isStartHandle(e.target);\n            const value = handler(Object.assign({}, options, { value: startHandleIsActive ? this.value[0] : this.value[1] }));\n            if (startHandleIsActive) {\n                if (value > this.value[1]) {\n                    this.value[1] = value;\n                }\n            }\n            else {\n                if (value < this.value[0]) {\n                    this.value[0] = value;\n                }\n            }\n            const trimmedValue = trimValue(max, min, value);\n            const newValue = startHandleIsActive ? [trimmedValue, this.value[1]]\n                : [this.value[0], trimmedValue];\n            this.changeValue(newValue);\n            e.preventDefault();\n        };\n        this.ngChange = (_) => { };\n        this.ngTouched = () => { };\n        this.handleBlur = () => {\n            this.changeDetector.markForCheck();\n            this.focused = false;\n            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.ngTouched();\n                    if (!this.focusChangedProgrammatically) {\n                        this.onBlur.emit();\n                    }\n                });\n            }\n        };\n    }\n    /**\n     * Focuses the RangeSlider.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *     <div>\n     *         <button class=\"k-button\" (click)=\"slider.focus()\">Focus</button>\n     *     </div>\n     *     <kendo-rangeslider #slider></kendo-rangeslider>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        this.focusChangedProgrammatically = true;\n        invokeElementMethod(this.draghandleStart, 'focus');\n        this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the RangeSlider.\n     */\n    blur() {\n        this.focusChangedProgrammatically = true;\n        const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;\n        invokeElementMethod(activeHandle, 'blur');\n        this.handleBlur();\n        this.focusChangedProgrammatically = false;\n    }\n    ngOnInit() {\n        if (!this.value) {\n            this.value = [this.min, this.max];\n        }\n        super.ngOnInit();\n    }\n    ngOnChanges(changes) {\n        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {\n            if (changes.value && changes.value.currentValue) {\n                validateValue(changes.value.currentValue);\n            }\n            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n                this.sizeComponent();\n            });\n        }\n    }\n    ngAfterViewInit() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.sizeComponent();\n        if (this.ticks) {\n            this.ticks.tickElements\n                .changes\n                .subscribe(() => this.sizeComponent());\n        }\n        this.attachElementEventHandlers();\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    textFor(key) {\n        return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n    get valueText() {\n        return this.value ? `${this.value[0]} - ${this.value[1]}` : '';\n    }\n    /**\n     * @hidden\n     */\n    handleDragPress(args) {\n        if (args.originalEvent) {\n            args.originalEvent.preventDefault();\n        }\n        const target = args.originalEvent.target;\n        this.draggedHandle = target;\n        this.renderer.setStyle(target, 'zIndex', ++this.handleZIndex);\n    }\n    /**\n     * @hidden\n     */\n    onHandleDrag(args) {\n        this.value = this.value || [this.min, this.min];\n        const target = args.originalEvent.target;\n        const lastCoords = this.draggedHandle.getBoundingClientRect();\n        this.lastHandlePosition = { x: lastCoords.left, y: lastCoords.top };\n        this.dragging = { value: true, target };\n        const left = args.pageX < this.lastHandlePosition.x;\n        const right = args.pageX > this.lastHandlePosition.x;\n        const up = args.pageY > this.lastHandlePosition.y;\n        const moveStartHandle = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), this.value[1]]);\n        const moveEndHandle = () => this.changeValue([this.value[0], eventValue(args, this.track.nativeElement, this.getProps())]);\n        const moveBothHandles = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), eventValue(args, this.track.nativeElement, this.getProps())]);\n        const activeStartHandle = isStartHandle(this.draggedHandle);\n        const vertical = this.vertical;\n        const horizontal = !vertical;\n        const forward = (vertical && up) || (this.reverse ? horizontal && right : horizontal && left);\n        // const forward = (this.reverse ? (!this.vertical && !left) : (!this.vertical && left)) || (this.vertical && up);\n        if (this.value[0] === this.value[1]) {\n            if (forward) {\n                activeStartHandle ? moveStartHandle() : moveBothHandles();\n            }\n            else {\n                activeStartHandle ? moveBothHandles() : moveEndHandle();\n            }\n        }\n        else {\n            activeStartHandle ? moveStartHandle() : moveEndHandle();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onHandleRelease(args) {\n        this.dragging = { value: false, target: args.originalEvent.target }; //needed for animation\n        this.draggedHandle = undefined;\n    }\n    //ngModel binding\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        validateValue(value);\n        this.value = value;\n        this.sizeComponent();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    changeValue(value) {\n        if (!this.value || !isSameRange(this.value, value)) {\n            this.ngZone.run(() => {\n                this.value = value;\n                this.ngChange(value);\n                if (this.value) {\n                    this.valueChange.emit(value);\n                }\n                this.sizeComponent();\n            });\n        }\n    }\n    /**\n     * @hidden\n     */\n    sizeComponent() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        const wrapper = this.wrapper.nativeElement;\n        const track = this.track.nativeElement;\n        const selectionEl = this.sliderSelection.nativeElement;\n        const dragHandleStartEl = this.draghandleStart.nativeElement;\n        const dragHandleEndEl = this.draghandleEnd.nativeElement;\n        const ticks = this.ticks ? this.ticksContainer.nativeElement : null;\n        this.resetStyles([track, selectionEl, dragHandleStartEl, dragHandleEndEl, ticks, this.hostElement.nativeElement]);\n        const props = this.getProps();\n        const model = new RangeSliderModel(props, wrapper, track, this.renderer);\n        model.resizeTrack();\n        if (this.ticks) { //for case when tickPlacement: none\n            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));\n        }\n        model.positionHandle(dragHandleStartEl);\n        model.positionHandle(dragHandleEndEl);\n        model.positionSelection(dragHandleStartEl, selectionEl);\n        if (this.fixedTickWidth) {\n            model.resizeWrapper();\n        }\n    }\n    /**\n     * @hidden\n     */\n    get isDisabled() {\n        return this.disabled || this.readonly;\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    set focused(value) {\n        if (this.isFocused !== value && this.hostElement) {\n            this.isFocused = value;\n        }\n    }\n    set dragging(data) {\n        if (this.isDragged !== data.value && this.sliderSelection && this.draghandleStart && this.draghandleEnd) {\n            const sliderSelection = this.sliderSelection.nativeElement;\n            const draghandle = data.target;\n            if (data.value) {\n                this.renderer.addClass(sliderSelection, PRESSED$1);\n                this.renderer.addClass(draghandle, PRESSED$1);\n            }\n            else {\n                this.renderer.removeClass(sliderSelection, PRESSED$1);\n                this.renderer.removeClass(draghandle, PRESSED$1);\n            }\n            this.isDragged = data.value;\n        }\n    }\n    getProps() {\n        return {\n            disabled: this.disabled,\n            fixedTickWidth: this.fixedTickWidth,\n            largeStep: this.largeStep,\n            max: this.max,\n            min: this.min,\n            readonly: this.readonly,\n            reverse: this.reverse,\n            rtl: this.localizationService.rtl,\n            smallStep: this.smallStep,\n            value: trimValueRange(this.max, this.min, this.value),\n            vertical: this.vertical,\n            buttons: false\n        };\n    }\n    attachElementEventHandlers() {\n        const hostElement = this.hostElement.nativeElement;\n        let tabbing = false;\n        let cursorInsideWrapper = false;\n        this.ngZone.runOutsideAngular(() => {\n            // focusIn and focusOut are relative to the host element\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n                if (!this.isFocused) {\n                    this.ngZone.run(() => {\n                        if (!this.focusChangedProgrammatically) {\n                            this.onFocus.emit();\n                        }\n                        this.focused = true;\n                    });\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {\n                if (!this.isFocused) {\n                    return;\n                }\n                if (tabbing) {\n                    if (args.relatedTarget !== this.draghandleStart.nativeElement && args.relatedTarget !== this.draghandleEnd.nativeElement) {\n                        this.handleBlur();\n                    }\n                    tabbing = false;\n                }\n                else {\n                    if (!cursorInsideWrapper) {\n                        this.handleBlur();\n                    }\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n                cursorInsideWrapper = true;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n                cursorInsideWrapper = false;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {\n                if (args.keyCode === Keys.Tab) {\n                    tabbing = true;\n                }\n                else {\n                    tabbing = false;\n                }\n            }));\n        });\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Array)\n], RangeSliderComponent.prototype, \"value\", void 0);\n__decorate([\n    ViewChild('draghandleStart', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], RangeSliderComponent.prototype, \"draghandleStart\", void 0);\n__decorate([\n    ViewChild('draghandleEnd', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], RangeSliderComponent.prototype, \"draghandleEnd\", void 0);\nRangeSliderComponent = RangeSliderComponent_1 = __decorate([\n    Component({\n        exportAs: 'kendoRangeSlider',\n        providers: [\n            LocalizationService,\n            { provide: L10N_PREFIX, useValue: 'kendo.rangeslider' },\n            { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => RangeSliderComponent_1) },\n            { provide: KendoInput, useExisting: forwardRef(() => RangeSliderComponent_1) }\n        ],\n        selector: 'kendo-rangeslider',\n        template: `\n        <ng-container kendoSliderLocalizedMessages\n            i18n-dragHandleStart=\"kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider.\"\n            dragHandleStart=\"Drag\"\n            i18n-dragHandleEnd=\"kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider.\"\n            dragHandleEnd=\"Drag\"\n        >\n\n        <div class=\"k-slider-wrap\" #wrap\n            [class.k-slider-topleft]=\"tickPlacement === 'before'\"\n            [class.k-slider-bottomright]=\"tickPlacement === 'after'\"\n            [kendoEventsOutsideAngular]=\"{ click: onWrapClick, keydown: onKeyDown }\"\n            >\n            <ul kendoSliderTicks\n                #ticks\n                *ngIf=\"tickPlacement !== 'none'\"\n                [tickTitle]=\"title\"\n                [vertical]=\"vertical\"\n                [step]=\"smallStep\"\n                [largeStep]=\"largeStep\"\n                [min]=\"min\"\n                [max]=\"max\"\n                [labelTemplate]=\"labelTemplate?.templateRef\"\n                [attr.aria-hidden]=\"true\"\n            >\n            </ul>\n            <div #track class=\"k-slider-track\">\n                <div #sliderSelection class=\"k-slider-selection\">\n                </div>\n                <a #draghandleStart\n                    role=\"slider\"\n                    [id]=\"startHandleId\"\n                    [attr.tabindex]=\"disabled ? undefined : tabindex\"\n                    [attr.aria-valuemin]=\"min\"\n                    [attr.aria-valuemax]=\"max\"\n                    [attr.aria-valuenow]=\"value ? value[0] : null\"\n                    [attr.aria-valuetext]=\"valueText\"\n                    [attr.aria-disabled]=\"disabled ? true : undefined\"\n                    [attr.aria-readonly]=\"readonly ? true : undefined\"\n                    [attr.aria-orientation]=\"vertical ? 'vertical' : 'horizontal'\"\n                    [style.touch-action]=\"isDisabled ? '' : 'none'\"\n                    class=\"k-draghandle\"\n                    [title]=\"textFor('dragHandleStart')\"\n                    kendoDraggable\n                    (kendoPress)=\"ifEnabled(handleDragPress ,$event)\"\n                    (kendoDrag)=\"ifEnabled(onHandleDrag ,$event)\"\n                    (kendoRelease)=\"ifEnabled(onHandleRelease, $event)\"\n                ></a>\n                <a #draghandleEnd\n                    role=\"slider\"\n                    [id]=\"endHandleId\"\n                    [attr.tabindex]=\"disabled ? undefined : tabindex\"\n                    [attr.aria-valuemin]=\"min\"\n                    [attr.aria-valuemax]=\"max\"\n                    [attr.aria-valuenow]=\"value ? value[1] : null\"\n                    [attr.aria-valuetext]=\"valueText\"\n                    [attr.aria-disabled]=\"disabled ? true : undefined\"\n                    [attr.aria-readonly]=\"readonly ? true : undefined\"\n                    [attr.aria-orientation]=\"vertical ? 'vertical' : 'horizontal'\"\n                    [style.touch-action]=\"isDisabled ? '' : 'none'\"\n                    class=\"k-draghandle\"\n                    [title]=\"textFor('dragHandleEnd')\"\n                    kendoDraggable\n                    (kendoPress)=\"ifEnabled(handleDragPress ,$event)\"\n                    (kendoDrag)=\"ifEnabled(onHandleDrag ,$event)\"\n                    (kendoRelease)=\"ifEnabled(onHandleRelease, $event)\"\n                ></a>\n            </div>\n\n            <kendo-resize-sensor (resize)=\"sizeComponent()\"></kendo-resize-sensor>\n        </div>\n  `\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService,\n        Injector,\n        Renderer2,\n        NgZone,\n        ChangeDetectorRef,\n        ElementRef])\n], RangeSliderComponent);\n\nvar SwitchComponent_1;\nconst FOCUSED = 'k-state-focused';\n/**\n * Represents the [Kendo UI Switch component for Angular]({% slug overview_switch %}).\n */\nlet SwitchComponent = SwitchComponent_1 = class SwitchComponent {\n    constructor(renderer, hostElement, localizationService, injector, changeDetector, ngZone) {\n        this.renderer = renderer;\n        this.hostElement = hostElement;\n        this.localizationService = localizationService;\n        this.injector = injector;\n        this.changeDetector = changeDetector;\n        this.ngZone = ngZone;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Determines whether the Switch is disabled ([see example]({% slug disabled_switch %})).\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the Switch is in its read-only state ([see example]({% slug readonly_switch %})).\n         */\n        this.readonly = false;\n        /**\n         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Switch.\n         */\n        this.tabindex = 0;\n        /**\n         * Fires each time the user focuses the `input` element.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the `input` element gets blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the user selects a new value.\n         */\n        this.valueChange = new EventEmitter();\n        this.hostClasses = true;\n        /**\n         * @hidden\n         */\n        this.initialized = false;\n        this._checked = false;\n        this.ngChange = (_) => { };\n        this.ngTouched = () => { };\n        /**\n         * @hidden\n         */\n        this.handleFocus = () => {\n            this.focused = true;\n            if (hasObservers(this.onFocus)) {\n                this.ngZone.run(() => {\n                    this.onFocus.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleBlur = () => {\n            this.changeDetector.markForCheck();\n            this.focused = false;\n            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.ngTouched();\n                    this.onBlur.emit();\n                });\n            }\n        };\n        validatePackage(packageMetadata);\n        this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n        this.keyDownHandler = this.keyDownHandler.bind(this);\n        this.clickHandler = this.clickHandler.bind(this);\n    }\n    /**\n     * Sets the value of the Switch when it is initially displayed.\n     */\n    set checked(value) {\n        this.setHostClasses(value);\n        this._checked = value;\n    }\n    get checked() {\n        return this._checked;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    get ieClass() {\n        return browser && browser.msie;\n    }\n    get ariaDisabled() {\n        return this.disabled ? true : undefined;\n    }\n    get ariaReadonly() {\n        return this.readonly;\n    }\n    get disabledClass() {\n        return this.disabled;\n    }\n    /**\n     * @hidden\n     */\n    get onLabelMessage() {\n        return this.onLabel || this.localizationService.get('on');\n    }\n    /**\n     * @hidden\n     */\n    get offLabelMessage() {\n        return this.offLabel || this.localizationService.get('off');\n    }\n    get isEnabled() {\n        return !this.disabled && !this.readonly;\n    }\n    ngOnInit() {\n        if (this.hostElement) {\n            const wrapper = this.hostElement.nativeElement;\n            this.renderer.removeAttribute(wrapper, \"tabindex\");\n        }\n        this.localizationChangeSubscription = this.localizationService\n            .changes\n            .pipe(skip(1))\n            .subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n        this.control = this.injector.get(NgControl, null);\n        this.ngZone.onStable.pipe(take(1)).subscribe(() => this.initialized = true);\n    }\n    ngOnDestroy() {\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n    }\n    /**\n     * Focuses the Switch.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"switch.focus()\">Focus</button>\n     *  <kendo-switch #switch></kendo-switch>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.wrapper) {\n            return;\n        }\n        this.wrapper.nativeElement.focus();\n    }\n    /**\n     * Blurs the Switch.\n     */\n    blur() {\n        if (!this.wrapper) {\n            return;\n        }\n        this.wrapper.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n        this.changeDetector.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.checked = value === null ? false : value;\n        this.changeDetector.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    keyDownHandler(e) {\n        const keyCode = e.keyCode;\n        if (this.isEnabled && (keyCode === Keys.Space || keyCode === Keys.Enter)) {\n            this.changeValue(!this.checked);\n            e.preventDefault();\n        }\n    }\n    /**\n     * @hidden\n     */\n    clickHandler() {\n        if (this.isEnabled) {\n            this.changeValue(!this.checked);\n        }\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    changeValue(value) {\n        if (this.checked !== value) {\n            this.ngZone.run(() => {\n                this.checked = value;\n                this.ngChange(value);\n                this.valueChange.emit(value);\n                this.changeDetector.markForCheck();\n            });\n        }\n    }\n    set focused(value) {\n        if (this.isFocused !== value && this.hostElement) {\n            const element = this.hostElement.nativeElement;\n            if (value) {\n                this.renderer.addClass(element, FOCUSED);\n            }\n            else {\n                this.renderer.removeClass(element, FOCUSED);\n            }\n            this.isFocused = value;\n        }\n    }\n    setHostClasses(value) {\n        if (value) {\n            this.renderer.removeClass(this.hostElement.nativeElement, 'k-switch-off');\n            this.renderer.addClass(this.hostElement.nativeElement, 'k-switch-on');\n        }\n        else {\n            this.renderer.removeClass(this.hostElement.nativeElement, 'k-switch-on');\n            this.renderer.addClass(this.hostElement.nativeElement, 'k-switch-off');\n        }\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], SwitchComponent.prototype, \"focusableId\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], SwitchComponent.prototype, \"onLabel\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], SwitchComponent.prototype, \"offLabel\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [Boolean])\n], SwitchComponent.prototype, \"checked\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], SwitchComponent.prototype, \"disabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], SwitchComponent.prototype, \"readonly\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], SwitchComponent.prototype, \"tabindex\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], SwitchComponent.prototype, \"tabIndex\", null);\n__decorate([\n    Output('focus'),\n    __metadata(\"design:type\", EventEmitter)\n], SwitchComponent.prototype, \"onFocus\", void 0);\n__decorate([\n    Output('blur'),\n    __metadata(\"design:type\", EventEmitter)\n], SwitchComponent.prototype, \"onBlur\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], SwitchComponent.prototype, \"valueChange\", void 0);\n__decorate([\n    ViewChild('wrapper', { static: true }),\n    __metadata(\"design:type\", Object)\n], SwitchComponent.prototype, \"wrapper\", void 0);\n__decorate([\n    HostBinding('attr.dir'),\n    __metadata(\"design:type\", String)\n], SwitchComponent.prototype, \"direction\", void 0);\n__decorate([\n    HostBinding('class.k-ie'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], SwitchComponent.prototype, \"ieClass\", null);\n__decorate([\n    HostBinding('attr.aria-disabled'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], SwitchComponent.prototype, \"ariaDisabled\", null);\n__decorate([\n    HostBinding('attr.aria-readonly'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], SwitchComponent.prototype, \"ariaReadonly\", null);\n__decorate([\n    HostBinding('class.k-switch'),\n    __metadata(\"design:type\", Boolean)\n], SwitchComponent.prototype, \"hostClasses\", void 0);\n__decorate([\n    HostBinding('class.k-state-disabled'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], SwitchComponent.prototype, \"disabledClass\", null);\nSwitchComponent = SwitchComponent_1 = __decorate([\n    Component({\n        exportAs: 'kendoSwitch',\n        providers: [\n            LocalizationService,\n            { provide: L10N_PREFIX, useValue: 'kendo.switch' },\n            {\n                multi: true,\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => SwitchComponent_1) /* tslint:disable-line */\n            },\n            {\n                provide: KendoInput,\n                useExisting: forwardRef(() => SwitchComponent_1)\n            }\n        ],\n        selector: 'kendo-switch',\n        template: `\n        <ng-container kendoSwitchLocalizedMessages\n            i18n-on=\"kendo.switch.on|The **On** label of the Switch.\"\n            on=\"ON\"\n            i18n-off=\"kendo.switch.off|The **Off** label of the Switch.\"\n            off=\"OFF\"\n        >\n\n        <span\n            #wrapper\n            class=\"k-switch-container\"\n            [id]=\"focusableId\"\n            role=\"switch\"\n            [style.transitionDuration]=\"initialized ? '200ms' : '0ms'\"\n            [attr.aria-checked]=\"checked\"\n            [attr.tabindex]=\"(disabled ? undefined : tabIndex)\"\n            [kendoEventsOutsideAngular]=\"{ click: clickHandler, keydown: keyDownHandler, focus: handleFocus, blur: handleBlur }\"\n        >\n            <span class=\"k-switch-label-on\" [attr.aria-hidden]=\"true\" >{{onLabelMessage}}</span>\n            <span class=\"k-switch-label-off\" [attr.aria-hidden]=\"true\">{{offLabelMessage}}</span>\n            <span class=\"k-switch-handle\" [style.transitionDuration]=\"initialized ? '200ms' : '0ms'\"></span>\n        </span>\n  `\n    }),\n    __metadata(\"design:paramtypes\", [Renderer2,\n        ElementRef,\n        LocalizationService,\n        Injector,\n        ChangeDetectorRef,\n        NgZone])\n], SwitchComponent);\n\nvar TextAreaDirective_1;\n/**\n * Represents the [Kendo UI TextArea directive for the Inputs components for Angular]({% slug overview_textarea %}).\n * Provides floating labels to `textarea` elements.\n *\n * @example\n * ```ts-no-run\n * <textarea kendoTextArea></textarea>\n * ```\n */\nlet TextAreaDirective = TextAreaDirective_1 = class TextAreaDirective {\n    constructor(renderer, element, zone, changeDetector, injector, rtl) {\n        this.renderer = renderer;\n        this.element = element;\n        this.zone = zone;\n        this.changeDetector = changeDetector;\n        this.injector = injector;\n        this.elementClass = true;\n        this.autofillClass = true;\n        /**\n         * Fires each time the textarea value is changed.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Specifies if the `textarea` element will resize its height automatically\n         * ([see example]({% slug overview_textarea %}#toc-auto-resizing)).\n         *\n         * @default false\n         */\n        this.autoSize = false;\n        /**\n         * @hidden\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.onValueChange = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.autoFillStart = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.autoFillEnd = new EventEmitter();\n        this.listeners = [];\n        this.ngChange = (_) => { };\n        this.ngTouched = () => { };\n        this.direction = rtl ? 'rtl' : 'ltr';\n    }\n    get id() {\n        return this.element.nativeElement.id;\n    }\n    set id(id) {\n        this.renderer.setAttribute(this.element.nativeElement, 'id', id);\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.elementValue = value;\n        this.resize();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.setElementProperty('disabled', isDisabled);\n    }\n    ngOnInit() {\n        const element = this.element.nativeElement;\n        this.zone.runOutsideAngular(() => {\n            this.listeners = [\n                this.renderer.listen(element, 'focus', this.handleFocus.bind(this)),\n                this.renderer.listen(element, 'blur', this.handleBlur.bind(this)),\n                this.renderer.listen(element, 'animationstart', (e) => {\n                    if (e.animationName === 'autoFillStart') {\n                        this.autoFillStart.emit();\n                    }\n                    else if (e.animationName === 'autoFillEnd') {\n                        this.autoFillEnd.emit();\n                    }\n                })\n            ];\n            if (isDocumentAvailable() && this.autoSize) {\n                this.resizeSubscription = fromEvent(window, 'resize')\n                    .pipe((debounceTime(50)))\n                    .subscribe(() => this.resize());\n            }\n            this.inputSubscription = fromEvent(element, 'input')\n                .subscribe(this.handleInput.bind(this));\n        });\n        this.control = this.injector.get(NgControl, null);\n    }\n    ngOnChanges(changes) {\n        const element = this.element.nativeElement;\n        if (changes.value) {\n            this.elementValue = this.value;\n        }\n        if (changes.autoSize) {\n            if (this.autoSize) {\n                this.initialHeight = element.offsetHeight;\n                this.renderer.setStyle(element, 'resize', 'none');\n            }\n            else {\n                this.renderer.setStyle(element, 'overflow-y', 'auto');\n                this.renderer.setStyle(element, 'resize', 'both');\n                element.style.height = `${this.initialHeight}px`;\n            }\n        }\n        this.resize();\n    }\n    ngOnDestroy() {\n        this.listeners.forEach(listener => listener());\n        if (this.inputSubscription) {\n            this.inputSubscription.unsubscribe();\n        }\n        if (this.resizeSubscription) {\n            this.resizeSubscription.unsubscribe();\n        }\n    }\n    get elementValue() {\n        if (this.element) {\n            return this.element.nativeElement.value;\n        }\n        return '';\n    }\n    set elementValue(value) {\n        this.setElementProperty('value', (value === undefined || value === null) ? '' : value);\n    }\n    setElementProperty(name, value) {\n        if (this.element) {\n            this.renderer.setProperty(this.element.nativeElement, name, value);\n        }\n    }\n    resize() {\n        if (!this.autoSize) {\n            return;\n        }\n        const element = this.element.nativeElement;\n        this.renderer.setStyle(element, 'overflow-y', 'hidden');\n        element.style.height = `${this.initialHeight}px`;\n        const scrollHeight = element.scrollHeight;\n        if (scrollHeight > this.initialHeight) {\n            element.style.height = `${scrollHeight}px`;\n        }\n    }\n    handleInput() {\n        const value = this.elementValue;\n        this.value = value;\n        if (this.control || hasObservers(this.onValueChange) || hasObservers(this.valueChange)) {\n            this.zone.run(() => {\n                this.ngChange(value);\n                this.onValueChange.emit(value);\n                this.valueChange.emit(value);\n                this.changeDetector.markForCheck();\n            });\n        }\n        this.resize();\n    }\n    handleFocus() {\n        if (hasObservers(this.onFocus)) {\n            this.zone.run(() => {\n                this.onFocus.emit();\n            });\n        }\n    }\n    handleBlur() {\n        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n            this.zone.run(() => {\n                this.ngTouched();\n                this.onBlur.emit();\n                this.changeDetector.markForCheck();\n            });\n        }\n    }\n};\n__decorate([\n    HostBinding('class.k-textarea'),\n    __metadata(\"design:type\", Boolean)\n], TextAreaDirective.prototype, \"elementClass\", void 0);\n__decorate([\n    HostBinding('class.k-autofill'),\n    __metadata(\"design:type\", Boolean)\n], TextAreaDirective.prototype, \"autofillClass\", void 0);\n__decorate([\n    HostBinding('attr.dir'),\n    __metadata(\"design:type\", String)\n], TextAreaDirective.prototype, \"direction\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TextAreaDirective.prototype, \"valueChange\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], TextAreaDirective.prototype, \"autoSize\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextAreaDirective.prototype, \"value\", void 0);\nTextAreaDirective = TextAreaDirective_1 = __decorate([\n    Directive({\n        providers: [{\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => TextAreaDirective_1),\n                multi: true\n            }, {\n                provide: KendoInput,\n                useExisting: forwardRef(() => TextAreaDirective_1)\n            }],\n        selector: 'textarea[kendoTextArea]'\n    }),\n    __param(5, Optional()), __param(5, Inject(RTL)),\n    __metadata(\"design:paramtypes\", [Renderer2,\n        ElementRef,\n        NgZone,\n        ChangeDetectorRef,\n        Injector, Boolean])\n], TextAreaDirective);\n\n/**\n * @hidden\n */\nclass FloatingLabelInputAdapter {\n    constructor(component, formControl) {\n        this.component = component;\n        const isObservableOrEventEmitter = (event) => event instanceof Observable || event instanceof EventEmitter;\n        if (isObservableOrEventEmitter(component.onFocus)) {\n            this.onFocus = component.onFocus;\n        }\n        if (isObservableOrEventEmitter(component.autoFillStart)) {\n            this.autoFillStart = component.autoFillStart;\n        }\n        if (isObservableOrEventEmitter(component.autoFillEnd)) {\n            this.autoFillEnd = component.autoFillEnd;\n        }\n        if (isObservableOrEventEmitter(component.onBlur)) {\n            this.onBlur = component.onBlur;\n        }\n        if (formControl) {\n            this.onValueChange = formControl.valueChanges;\n        }\n        else if (component.onValueChange) {\n            this.onValueChange = component.onValueChange;\n        }\n    }\n    get focusableId() {\n        const component = this.component;\n        if ('focusableId' in component) {\n            return component.focusableId;\n        }\n        else if ('id' in component) {\n            return component.id;\n        }\n        return \"\";\n    }\n    set focusableId(value) {\n        const component = this.component;\n        if ('focusableId' in component) {\n            component.focusableId = value;\n        }\n        else if ('id' in component) {\n            component.id = value;\n        }\n    }\n}\n\nconst isFunction = (x) => Object.prototype.toString.call(x) === '[object Function]';\n/**\n * @hidden\n */\nlet TextBoxContainerComponent = class TextBoxContainerComponent {\n    constructor(elementRef, renderer, changeDetectorRef, rtl) {\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n        this.changeDetectorRef = changeDetectorRef;\n        /**\n         * @hidden\n         */\n        this.focused = false;\n        /**\n         * @hidden\n         */\n        this.empty = true;\n        /**\n         * @hidden\n         */\n        this.invalid = false;\n        this._subscriptions = [];\n        this.autoFillStarted = false;\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.renderer.removeAttribute(this.elementRef.nativeElement, \"id\");\n    }\n    get hostClasses() {\n        return true;\n    }\n    get textareaElementClass() {\n        return !!this.textarea;\n    }\n    get focusedClass() {\n        return this.focused;\n    }\n    get invalidClass() {\n        return this.invalid;\n    }\n    /**\n     * @hidden\n     */\n    ngAfterContentInit() {\n        if (!this.formControl && !this.kendoInput) {\n            if (isDevMode()) {\n                throw new Error(\"The TextBoxContainer requires a Kendo Input component\" +\n                    \" or a forms-bound component to function properly.\");\n            }\n            return;\n        }\n        // add focus/blur/valueChange handlers\n        const control = new FloatingLabelInputAdapter(this.kendoInput || this.formControl.valueAccessor, this.formControl);\n        const setFocus = (isFocused) => () => {\n            this.focused = isFocused;\n            this.updateState();\n        };\n        this.subscribe(control, 'onFocus', setFocus(true));\n        this.subscribe(control, 'onBlur', setFocus(false));\n        this.subscribe(control, 'autoFillStart', () => {\n            this.autoFillStarted = true;\n            this.renderer.removeClass(this.elementRef.nativeElement, 'k-state-empty');\n        });\n        this.subscribe(control, 'autoFillEnd', () => {\n            if (this.autoFillStarted) {\n                this.autoFillStarted = false;\n                if (this.empty) {\n                    this.renderer.addClass(this.elementRef.nativeElement, 'k-state-empty');\n                }\n            }\n        });\n        const updateState = () => this.updateState();\n        updateState();\n        this.subscribe(control, 'onValueChange', updateState);\n        // set label id for floating label\n        if (this.id && control.focusableId) {\n            // input wins\n            this.id = control.focusableId;\n        }\n        else if (this.id) {\n            control.focusableId = this.id;\n        }\n        else if (control.focusableId) {\n            this.id = control.focusableId;\n        }\n        else {\n            const id = \"_\" + guid();\n            control.focusableId = id;\n            this.id = id;\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        this._subscriptions.forEach(s => s.unsubscribe());\n        this._subscriptions = [];\n    }\n    subscribe(control, eventName, handler) {\n        if (control[eventName] instanceof EventEmitter) {\n            const subscription = control[eventName].subscribe(handler);\n            this._subscriptions.push(subscription);\n        }\n    }\n    updateState() {\n        const empty = value => {\n            // zero is not an empty value (e.g., NumericTextBox)\n            if (value === 0 || value === false) {\n                return false;\n            }\n            // empty arrays are an empty value (e.g., MultiSelect)\n            if (Array.isArray(value) && !value.length) {\n                return true;\n            }\n            return !value;\n        };\n        const formControl = this.formControl;\n        if (formControl) {\n            const valueAccessor = formControl.valueAccessor;\n            if (isFunction(valueAccessor.isEmpty)) {\n                this.empty = valueAccessor.isEmpty();\n            }\n            else {\n                this.empty = empty(formControl.value);\n            }\n            this.invalid = formControl.invalid && (formControl.touched || formControl.dirty);\n        }\n        else {\n            this.empty = isFunction(this.kendoInput.isEmpty) ?\n                this.kendoInput.isEmpty() : empty(this.kendoInput.value);\n        }\n        if (this.empty) {\n            this.renderer.addClass(this.elementRef.nativeElement, 'k-state-empty');\n        }\n        else {\n            this.renderer.removeClass(this.elementRef.nativeElement, 'k-state-empty');\n        }\n        this.changeDetectorRef.markForCheck();\n    }\n};\n__decorate([\n    HostBinding('class.k-textbox-container'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], TextBoxContainerComponent.prototype, \"hostClasses\", null);\n__decorate([\n    HostBinding('class.k-textarea-wrapper'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], TextBoxContainerComponent.prototype, \"textareaElementClass\", null);\n__decorate([\n    HostBinding('class.k-state-focused'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], TextBoxContainerComponent.prototype, \"focusedClass\", null);\n__decorate([\n    HostBinding('class.k-state-invalid'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], TextBoxContainerComponent.prototype, \"invalidClass\", null);\n__decorate([\n    HostBinding('attr.dir'),\n    __metadata(\"design:type\", String)\n], TextBoxContainerComponent.prototype, \"direction\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextBoxContainerComponent.prototype, \"id\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextBoxContainerComponent.prototype, \"floatingLabel\", void 0);\n__decorate([\n    ContentChild(KendoInput, { static: false }),\n    __metadata(\"design:type\", Object)\n], TextBoxContainerComponent.prototype, \"kendoInput\", void 0);\n__decorate([\n    ContentChild(TextAreaDirective, { static: false }),\n    __metadata(\"design:type\", TextAreaDirective)\n], TextBoxContainerComponent.prototype, \"textarea\", void 0);\n__decorate([\n    ContentChild(NgControl, { static: false }),\n    __metadata(\"design:type\", NgControl)\n], TextBoxContainerComponent.prototype, \"formControl\", void 0);\nTextBoxContainerComponent = __decorate([\n    Component({\n        selector: 'kendo-textbox-container',\n        template: `\n        <ng-content></ng-content>\n        <label *ngIf=\"floatingLabel\" [for]=\"id\" class=\"k-label\">{{ floatingLabel }}</label>\n    `\n    }),\n    __param(3, Optional()), __param(3, Inject(RTL)),\n    __metadata(\"design:paramtypes\", [ElementRef,\n        Renderer2,\n        ChangeDetectorRef, Boolean])\n], TextBoxContainerComponent);\n\nvar TextBoxDirective_1;\n/**\n * Represents the [Kendo UI TextBox directive]({% slug overview_textbox %}) for the Inputs components for Angular.\n * Used to style the textbox of any `input` element.\n *\n * @example\n * ```ts-no-run\n * <input kendoTextBox />\n * <input kendoTextBox type=\"email\" />\n * <input kendoTextBox type=\"password\" />\n * ```\n */\nlet TextBoxDirective = TextBoxDirective_1 = class TextBoxDirective {\n    constructor(renderer, inputElement, ngZone) {\n        this.renderer = renderer;\n        this.inputElement = inputElement;\n        this.ngZone = ngZone;\n        this.hostClass = true;\n        /**\n         * @hidden\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.onValueChange = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.autoFillStart = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.autoFillEnd = new EventEmitter();\n        this.listeners = [];\n    }\n    /**\n     * @hidden\n     */\n    set value(text) {\n        if (!this.inputElement) {\n            return;\n        }\n        this.inputElement.nativeElement.value = (text === undefined || text === null) ? '' : text;\n        this.onValueChange.emit();\n    }\n    /**\n     * @hidden\n     */\n    get value() {\n        return this.inputElement.nativeElement.value;\n    }\n    get id() {\n        return this.inputElement.nativeElement.id;\n    }\n    set id(id) {\n        this.renderer.setAttribute(this.inputElement.nativeElement, 'id', id);\n    }\n    ngAfterViewInit() {\n        const input = this.inputElement.nativeElement;\n        this.listeners = [\n            this.renderer.listen(input, 'focus', () => this.onFocus.emit()),\n            this.renderer.listen(input, 'blur', () => this.onBlur.emit())\n        ];\n        this.ngZone.runOutsideAngular(() => {\n            this.renderer.listen(input, 'animationstart', (e) => {\n                if (e.animationName === 'autoFillStart') {\n                    this.autoFillStart.emit();\n                }\n                else if (e.animationName === 'autoFillEnd') {\n                    this.autoFillEnd.emit();\n                }\n            });\n        });\n    }\n    ngOnDestroy() {\n        this.listeners.forEach(listener => listener());\n    }\n};\n__decorate([\n    HostBinding('class.k-textbox'),\n    __metadata(\"design:type\", Boolean)\n], TextBoxDirective.prototype, \"hostClass\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], TextBoxDirective.prototype, \"value\", null);\nTextBoxDirective = TextBoxDirective_1 = __decorate([\n    Directive({\n        selector: 'input[kendoTextBox]',\n        providers: [{\n                provide: KendoInput,\n                useExisting: forwardRef(() => TextBoxDirective_1)\n            }]\n    }),\n    __metadata(\"design:paramtypes\", [Renderer2,\n        ElementRef,\n        NgZone])\n], TextBoxDirective);\n\n/**\n * @hidden\n */\nconst createMaxValidator = (maxValue) => {\n    return (c) => {\n        if (!isPresent(maxValue) || !isPresent(c.value) || c.value <= maxValue) {\n            return null;\n        }\n        return {\n            maxError: {\n                maxValue: maxValue,\n                value: c.value\n            }\n        };\n    };\n};\n\n/**\n * @hidden\n */\nconst createMinValidator = (minValue) => {\n    return (c) => {\n        if (!isPresent(minValue) || !isPresent(c.value) || c.value >= minValue) {\n            return null;\n        }\n        return {\n            minError: {\n                minValue: minValue,\n                value: c.value\n            }\n        };\n    };\n};\n\n/**\n * @hidden\n */\nconst MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-min';\n/**\n * @hidden\n */\nconst MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-max';\n/**\n * @hidden\n */\nconst POINT = \".\";\n/**\n * @hidden\n */\nconst INITIAL_SPIN_DELAY = 500;\n/**\n * @hidden\n */\nconst SPIN_DELAY = 50;\n/**\n * @hidden\n */\nconst EXPONENT_REGEX = /[eE][\\-+]?([0-9]+)/;\n\n/**\n * @hidden\n */\nconst numericRegex = (options) => {\n    const { autoCorrect, decimals, min } = options;\n    let separator = options.separator;\n    if (separator === POINT) {\n        separator = '\\\\' + separator;\n    }\n    const signPattern = autoCorrect && min !== null && min >= 0 ? '' : '-?';\n    let numberPattern;\n    if (decimals === 0) {\n        numberPattern = '\\\\d*';\n    }\n    else {\n        numberPattern = `(?:(?:\\\\d+(${separator}\\\\d*)?)|(?:${separator}\\\\d*))?`;\n    }\n    return new RegExp(`^${signPattern}${numberPattern}$`);\n};\n/**\n * @hidden\n */\nconst decimalPart = (value) => {\n    return value >= 0 ? Math.floor(value) : Math.ceil(value);\n};\n/**\n * @hidden\n */\nconst noop = (_) => { }; // tslint:disable-line:no-empty\n/**\n * @hidden\n */\nconst defined = (value) => {\n    return typeof value !== 'undefined';\n};\n/**\n * @hidden\n */\nconst isNumber = (value) => {\n    return !isNaN(value) && value !== null;\n};\n/**\n * @hidden\n */\nfunction pad(value, digits) {\n    const count = digits - String(value).length;\n    let result = value;\n    if (count > 0) {\n        const padString = new Array(count + 1).join(\"0\");\n        result = parseFloat(value + padString);\n    }\n    return result;\n}\n/**\n * @hidden\n */\nconst getDeltaFromMouseWheel = (e) => {\n    let delta = 0;\n    if (e.wheelDelta) {\n        delta = e.wheelDelta / 120;\n        delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n    }\n    else if (e.detail) {\n        delta = Math.round(-e.detail / 3);\n    }\n    return delta;\n};\n/**\n * @hidden\n */\nconst getCaretPosition = (element) => element.selectionStart;\n/**\n * @hidden\n */\nconst extractSignificantNumericChars = (formattedString, separator) => {\n    const significantCharacters = `${separator}0123456789-`;\n    return formattedString.split('').reduce((acc, curr) => significantCharacters.includes(curr) ? ++acc : acc, 0);\n};\n/**\n * @hidden\n */\nconst isRightClick = (event) => {\n    const isRightClickIE = event.button && event.button === 2;\n    const isRightClickOther = event.which && event.which === 3;\n    return isRightClickIE || isRightClickOther;\n};\n\n/**\n * @hidden\n */\nvar ArrowDirection;\n(function (ArrowDirection) {\n    ArrowDirection[ArrowDirection[\"Down\"] = -1] = \"Down\";\n    ArrowDirection[ArrowDirection[\"None\"] = 0] = \"None\";\n    ArrowDirection[ArrowDirection[\"Up\"] = 1] = \"Up\";\n})(ArrowDirection || (ArrowDirection = {}));\n\nvar NumericTextBoxComponent_1;\nconst PARSABLE_OPTIONS = ['min', 'max', 'step', 'decimals'];\nconst PARSABLE_DEFAULTS = {\n    decimals: null,\n    max: null,\n    min: null,\n    step: 1\n};\nconst FOCUSED$1 = 'k-state-focused';\nconst FORMATTED_VALUE = 'k-formatted-value';\n/**\n * Represents the [Kendo UI NumericTextBox component for Angular]({% slug overview_numerictextbox %}).\n */\nlet NumericTextBoxComponent = NumericTextBoxComponent_1 = class NumericTextBoxComponent {\n    constructor(intl, renderer, localizationService, injector, ngZone, changeDetector, hostElement) {\n        this.intl = intl;\n        this.renderer = renderer;\n        this.localizationService = localizationService;\n        this.injector = injector;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Determines whether the NumericTextBox is disabled ([see example]({% slug disabled_numerictextbox %})).\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the NumericTextBox is in its read-only state ([see example]({% slug readonly_numerictextbox %})).\n         */\n        this.readonly = false;\n        /**\n         * Sets the title of the `input` element of the NumericTextBox.\n         */\n        this.title = '';\n        /**\n         * Specifies whether the value will be auto-corrected based on the minimum and maximum values\n         * ([see example]({% slug precision_numerictextbox %})).\n         */\n        this.autoCorrect = false;\n        /**\n         * Specifies the number of decimals that the user can enter when the input is focused\n         * ([see example]({% slug precision_numerictextbox %})).\n         */\n        this.decimals = null;\n        /**\n         * Specifies the value that is used to increment or decrement the component value\n         * ([see example]({% slug predefinedsteps_numerictextbox %})).\n         */\n        this.step = 1;\n        /**\n         * Specifies whether the **Up** and **Down** spin buttons will be rendered\n         * ([see example]({% slug spinbuttons_numerictextbox %})).\n         */\n        this.spinners = true;\n        /**\n         * Determines whether the built-in minimum or maximum validators are enforced when a form is validated.\n         *\n         * > The 4.2.0 Angular version introduces the `min` and `max` validation directives. As a result, even if you set `rangeValidation`\n         * to `false`, the built-in Angular validators will be executed.\n         */\n        this.rangeValidation = true;\n        /**\n         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Determines whether the value of the NumericTextBox will be changed via scrolling. Defaults to `true`.\n         *\n         * @default true\n         */\n        this.changeValueOnScroll = true;\n        /**\n         * Determines whether the whole value will be selected when the NumericTextBox is clicked. Defaults to `true`.\n         */\n        this.selectOnFocus = true;\n        /**\n         * Specifies the value of the NumericTextBox\n         * ([see example]({% slug formats_numerictextbox %})).\n         */\n        this.value = null;\n        /**\n         * Fires each time the user selects a new value ([see example]({% slug overview_numerictextbox %}#toc-events)).\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user focuses the `input` element ([see example]({% slug overview_numerictextbox %}#toc-events)).\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * Fires each time the `input` element gets blurred ([see example]({% slug overview_numerictextbox %}#toc-events)).\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.ArrowDirection = ArrowDirection;\n        /**\n         * @hidden\n         */\n        this.arrowDirection = ArrowDirection.None;\n        this.inputValue = '';\n        this.minValidateFn = noop;\n        this.maxValidateFn = noop;\n        this._format = \"n2\";\n        this.isPasted = false;\n        this.mouseDown = false;\n        this.ngChange = noop;\n        this.ngTouched = noop;\n        this.ngValidatorChange = noop;\n        /**\n         * @hidden\n         */\n        this.increasePress = (e) => {\n            this.arrowPress(ArrowDirection.Up, e);\n        };\n        /**\n         * @hidden\n         */\n        this.decreasePress = (e) => {\n            this.arrowPress(ArrowDirection.Down, e);\n        };\n        /**\n         * @hidden\n         */\n        this.releaseArrow = () => {\n            clearTimeout(this.spinTimeout);\n            if (this.arrowDirection !== ArrowDirection.None) {\n                this.arrowDirection = ArrowDirection.None;\n                this.changeDetector.detectChanges();\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handlePaste = () => {\n            this.isPasted = true;\n        };\n        /**\n         * @hidden\n         */\n        this.handleInput = () => {\n            const input = this.numericInput.nativeElement;\n            let { selectionStart, selectionEnd, value: inputValue } = input;\n            if (this.pressedKey === Keys.NumpadDecimal) {\n                inputValue = this.replaceNumpadDotValue();\n            }\n            if (this.isPasted) {\n                inputValue = this.formatInputValue(this.intl.parseNumber(inputValue));\n            }\n            if (!this.isValid(inputValue)) {\n                input.value = this.inputValue;\n                this.setSelection(selectionStart - 1, selectionEnd - 1);\n                return;\n            }\n            const parsedValue = this.intl.parseNumber(inputValue);\n            let value = this.restrictDecimals(parsedValue);\n            if (this.autoCorrect) {\n                const limited = this.limitInputValue(value);\n                value = limited.value;\n                selectionStart = limited.selectionStart;\n                selectionEnd = limited.selectionEnd;\n            }\n            if (parsedValue !== value || this.hasTrailingZeros(inputValue) || !this.focused) {\n                this.setInputValue(value);\n                this.setSelection(selectionStart, selectionEnd);\n            }\n            else {\n                this.inputValue = inputValue;\n            }\n            if (this.isPasted) {\n                input.value = this.inputValue;\n            }\n            this.updateValue(value);\n            this.previousSelection = null;\n            this.isPasted = false;\n        };\n        /**\n         * @hidden\n         */\n        this.handleDragEnter = () => {\n            if (!this.focused && !this.isDisabled) {\n                this.setInputValue(this.value, true);\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleMouseDown = () => {\n            this.mouseDown = true;\n        };\n        /**\n         * @hidden\n         */\n        this.handleFocus = () => {\n            if (!this.focused) {\n                this.focused = true;\n                if (!this.isDisabled) {\n                    const shouldSelectAll = this.selectOnFocus || !this.mouseDown;\n                    this.ngZone.runOutsideAngular(() => {\n                        setTimeout(() => {\n                            if (shouldSelectAll) {\n                                this.selectAll();\n                            }\n                            else {\n                                this.selectCaret();\n                            }\n                        }, 0);\n                    });\n                }\n            }\n            this.mouseDown = false;\n            if (hasObservers(this.onFocus)) {\n                this.ngZone.run(() => {\n                    this.onFocus.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleBlur = () => {\n            this.changeDetector.markForCheck();\n            this.focused = false;\n            //blur is thrown before input when dragging the input text in IE\n            if (this.inputValue !== this.elementValue) {\n                this.handleInput();\n            }\n            this.setInputValue();\n            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.ngTouched();\n                    this.onBlur.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleKeyDown = (e) => {\n            if (this.isDisabled) {\n                return;\n            }\n            let step;\n            if (e.keyCode === Keys.ArrowDown) {\n                step = -1;\n            }\n            else if (e.keyCode === Keys.ArrowUp) {\n                step = 1;\n            }\n            if (step && this.step) {\n                e.preventDefault();\n                this.addStep(step);\n            }\n            const input = this.numericInput.nativeElement;\n            this.previousSelection = {\n                end: input.selectionEnd,\n                start: input.selectionStart\n            };\n            this.pressedKey = e.keyCode;\n        };\n        /**\n         * @hidden\n         */\n        this.handleWheel = (e) => {\n            if (this.focused && !this.isDisabled && this.changeValueOnScroll) {\n                e.preventDefault();\n                const delta = getDeltaFromMouseWheel(e);\n                this.addStep(delta);\n            }\n        };\n        validatePackage(packageMetadata);\n        this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * Specifies the number format which is used when the NumericTextBox is not focused\n     * ([see example]({% slug formats_numerictextbox %})).\n     * If `format` is set to `null` or `undefined`, the default format will be used.\n     */\n    get format() {\n        const format = this._format;\n        return format !== null && format !== undefined ? format : 'n2';\n    }\n    set format(value) {\n        this._format = value;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    get widgetClasses() {\n        return true;\n    }\n    ngOnInit() {\n        this.subscriptions = this.localizationService\n            .changes\n            .subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n        this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));\n        if (this.hostElement) {\n            this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n        }\n        this.control = this.injector.get(NgControl, null);\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n        if (anyChanged(PARSABLE_OPTIONS, changes, false)) {\n            this.parseOptions(PARSABLE_OPTIONS.filter(option => changes[option]));\n        }\n        this.verifySettings();\n        if (anyChanged(['min', 'max', 'rangeValidation'], changes, false)) {\n            this.minValidateFn = this.rangeValidation ? createMinValidator(this.min) : noop;\n            this.maxValidateFn = this.rangeValidation ? createMaxValidator(this.max) : noop;\n            this.ngValidatorChange();\n        }\n        if (anyChanged(['autoCorrect', 'decimals', 'min'], changes)) {\n            delete this.numericRegex;\n        }\n        if (anyChanged(['value', 'format'], changes, false)) {\n            this.verifyValue(this.value);\n            this.value = this.restrictModelValue(this.value);\n            if (!this.focused || (this.intl.parseNumber(this.elementValue) !== this.value)) {\n                this.setInputValue();\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n        clearTimeout(this.spinTimeout);\n    }\n    /**\n     * @hidden\n     */\n    validate(control) {\n        return this.minValidateFn(control) || this.maxValidateFn(control);\n    }\n    /**\n     * @hidden\n     */\n    registerOnValidatorChange(fn) {\n        this.ngValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.verifyValue(value);\n        let restrictedValue = this.restrictModelValue(value);\n        this.value = restrictedValue;\n        this.setInputValue();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n        this.changeDetector.markForCheck();\n        this.disabled = isDisabled;\n    }\n    /**\n     * Focuses the NumericTextBox.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"numerictextbox.focus()\">Focus NumericTextBox</button>\n     *  <kendo-numerictextbox #numerictextbox></kendo-numerictextbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        invokeElementMethod(this.numericInput, 'focus');\n    }\n    /**\n     * Blurs the NumericTextBox.\n     */\n    blur() {\n        invokeElementMethod(this.numericInput, 'blur');\n    }\n    /**\n     * Notifies the `NumericTextBoxComponent` that the input value should be changed.\n     * Can be used to update the input after setting the component properties directly.\n     */\n    notifyValueChange() {\n        this.setInputValue();\n    }\n    /**\n     * @hidden\n     */\n    get incrementTitle() {\n        return this.localizationService.get('increment');\n    }\n    /**\n     * @hidden\n     */\n    get decrementTitle() {\n        return this.localizationService.get('decrement');\n    }\n    get decimalSeparator() {\n        const numberSymbols = this.intl.numberSymbols();\n        return numberSymbols.decimal;\n    }\n    get elementValue() {\n        return this.numericInput.nativeElement.value;\n    }\n    set elementValue(value) {\n        this.renderer.setProperty(this.numericInput.nativeElement, 'value', value);\n    }\n    get focused() {\n        return this.isFocused;\n    }\n    get hasDecimals() {\n        return this.decimals !== null && this.decimals >= 0;\n    }\n    set focused(value) {\n        if (this.isFocused !== value && this.numericWrap) {\n            const wrap = this.numericWrap.nativeElement;\n            const input = this.numericInput.nativeElement;\n            if (value) {\n                this.renderer.addClass(wrap, FOCUSED$1);\n                if (!this.isDisabled) {\n                    this.renderer.removeClass(input, FORMATTED_VALUE);\n                }\n            }\n            else {\n                this.renderer.removeClass(wrap, FOCUSED$1);\n                this.renderer.addClass(input, FORMATTED_VALUE);\n            }\n            this.isFocused = value;\n        }\n    }\n    get isDisabled() {\n        return this.disabled || this.readonly;\n    }\n    arrowPress(direction, e) {\n        e.preventDefault();\n        if (this.isDisabled || isRightClick(e)) {\n            return;\n        }\n        if (!mobileOS) {\n            this.focused = true;\n            this.focus();\n        }\n        if (this.arrowDirection !== direction) {\n            this.arrowDirection = direction;\n            this.changeDetector.detectChanges();\n        }\n        if (this.step) {\n            this.spin(direction, INITIAL_SPIN_DELAY);\n        }\n        else {\n            this.setInputValue();\n        }\n    }\n    updateValue(value) {\n        if (!areSame(this.value, value)) {\n            this.ngZone.run(() => {\n                this.value = value;\n                this.ngChange(value);\n                this.valueChange.emit(value);\n                this.changeDetector.markForCheck();\n            });\n        }\n    }\n    replaceNumpadDotValue() {\n        let value = this.inputValue || \"\";\n        if (this.previousSelection) {\n            const input = this.numericInput.nativeElement;\n            const { selectionStart, selectionEnd } = input;\n            const { start, end } = this.previousSelection;\n            input.value = value = value.substring(0, start) + this.decimalSeparator + value.substring(end);\n            this.setSelection(selectionStart, selectionEnd);\n        }\n        return value;\n    }\n    isValid(value) {\n        if (!this.numericRegex) {\n            this.numericRegex = numericRegex({\n                autoCorrect: this.autoCorrect,\n                decimals: this.decimals,\n                min: this.min,\n                separator: this.decimalSeparator\n            });\n        }\n        return this.numericRegex.test(value);\n    }\n    spin(step, timeout) {\n        clearTimeout(this.spinTimeout);\n        this.spinTimeout = window.setTimeout(() => {\n            this.spin(step, SPIN_DELAY);\n        }, timeout);\n        this.addStep(step);\n    }\n    addStep(step) {\n        let value = add(this.value || 0, this.step * step);\n        value = this.limitValue(value);\n        value = this.restrictDecimals(value);\n        this.setInputValue(value);\n        this.updateValue(value);\n    }\n    setSelection(start, end) {\n        if (this.focused) {\n            invokeElementMethod(this.numericInput, 'setSelectionRange', start, end);\n        }\n    }\n    limitValue(value) {\n        let result = value;\n        if (!this.isInRange(value)) {\n            if (isNumber(this.max) && value > this.max) {\n                result = this.max;\n            }\n            if (isNumber(this.min) && value < this.min) {\n                result = this.min;\n            }\n        }\n        return result;\n    }\n    limitInputValue(value) {\n        let { selectionStart, selectionEnd, value: enteredValue } = this.numericInput.nativeElement;\n        let limitedValue = value;\n        let selectToEnd = false;\n        if (!this.isInRange(value)) {\n            const lengthChange = enteredValue.length - String(this.inputValue).length;\n            const { min, max } = this;\n            const hasMax = isNumber(max);\n            const hasMin = isNumber(min);\n            let padLimit, replaceNext;\n            let correctedValue = value;\n            if (selectionStart === 0 && this.inputValue.substr(1) === enteredValue) {\n                return {\n                    selectionEnd: selectionEnd,\n                    selectionStart: selectionStart,\n                    value: null\n                };\n            }\n            if (hasMax && value > max) {\n                if (value > 0) {\n                    replaceNext = true;\n                }\n                else {\n                    padLimit = max;\n                }\n            }\n            else if (hasMin && value < min) {\n                if (value > 0) {\n                    padLimit = min;\n                }\n                else {\n                    replaceNext = true;\n                }\n            }\n            if (padLimit) {\n                const paddedValue = this.tryPadValue(value, padLimit);\n                if (paddedValue && decimalPart(value) !== decimalPart(padLimit)) {\n                    correctedValue = paddedValue;\n                    selectToEnd = true;\n                }\n            }\n            else if (replaceNext) {\n                if (this.inputValue && selectionStart !== enteredValue.length) {\n                    correctedValue = parseFloat(enteredValue.substr(0, selectionStart) +\n                        enteredValue.substr(selectionStart + lengthChange));\n                }\n            }\n            limitedValue = this.limitValue(correctedValue);\n            selectToEnd = (selectToEnd || limitedValue !== correctedValue) && this.previousSelection &&\n                (this.previousSelection.end - this.previousSelection.start + lengthChange) > 0;\n        }\n        return {\n            selectionEnd: selectToEnd ? String(limitedValue).length : selectionEnd,\n            selectionStart: selectionStart,\n            value: limitedValue\n        };\n    }\n    tryPadValue(value, limit) {\n        const limitLength = String(Math.floor(limit)).length;\n        const zeroPadded = pad(value, limitLength);\n        const zeroPaddedNext = pad(value, limitLength + 1);\n        let result;\n        if (this.isInRange(zeroPadded)) {\n            result = zeroPadded;\n        }\n        else if (this.isInRange(zeroPaddedNext)) {\n            result = zeroPaddedNext;\n        }\n        return result;\n    }\n    isInRange(value) {\n        return !isNumber(value) || ((!isNumber(this.min) || this.min <= value) && (!isNumber(this.max) || value <= this.max));\n    }\n    restrictModelValue(value) {\n        let result = this.restrictDecimals(value, true);\n        if (this.autoCorrect && this.limitValue(result) !== result) {\n            result = null;\n        }\n        return result;\n    }\n    restrictDecimals(value, round) {\n        let result = value;\n        if (value && this.hasDecimals) {\n            const decimals = this.decimals;\n            const stringValue = String(value);\n            if (round || EXPONENT_REGEX.test(stringValue)) {\n                result = toFixedPrecision(value, decimals);\n            }\n            else {\n                const parts = stringValue.split(POINT);\n                let fraction = parts[1];\n                if (fraction && fraction.length > decimals) {\n                    fraction = fraction.substr(0, decimals);\n                    result = parseFloat(`${parts[0]}${POINT}${fraction}`);\n                }\n            }\n        }\n        return result;\n    }\n    formatInputValue(value) {\n        let stringValue = String(value);\n        const exponentMatch = EXPONENT_REGEX.exec(stringValue);\n        if (exponentMatch) {\n            stringValue = value.toFixed(limitPrecision(parseInt(exponentMatch[1], 10)));\n        }\n        return stringValue.replace(POINT, this.decimalSeparator);\n    }\n    formatValue(value, focused) {\n        let formattedValue;\n        if (value === null || !defined(value) || value === '') {\n            formattedValue = '';\n        }\n        else if (focused && !this.readonly) {\n            formattedValue = this.formatInputValue(value);\n        }\n        else {\n            formattedValue = this.intl.formatNumber(value, this.format);\n        }\n        return formattedValue;\n    }\n    setInputValue(value = this.value, focused = this.focused) {\n        const formattedValue = this.formatValue(value, focused);\n        this.elementValue = formattedValue;\n        this.inputValue = formattedValue;\n    }\n    verifySettings() {\n        if (!isDevMode()) {\n            return;\n        }\n        if (this.min !== null && this.max !== null && this.min > this.max) {\n            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);\n        }\n    }\n    verifyValue(value) {\n        if (isDevMode() && value && typeof value !== 'number') {\n            throw new Error(`The NumericTextBox component requires value of type Number and ${JSON.stringify(value)} was set.`);\n        }\n    }\n    parseOptions(options) {\n        for (let idx = 0; idx < options.length; idx++) {\n            const name = options[idx];\n            const value = this[name];\n            if (typeof value === 'string') {\n                const parsed = parseFloat(value);\n                const valid = !isNaN(parsed);\n                if (isDevMode() && !valid && value !== '') {\n                    throw new Error('The NumericTextBox component requires value of type Number or a String representing ' +\n                        `a number for the ${name} property and ${JSON.stringify(value)} was set.`);\n                }\n                this[name] = valid ? parsed : PARSABLE_DEFAULTS[name];\n            }\n        }\n    }\n    intlChange() {\n        delete this.numericRegex;\n        if (this.numericInput && (!this.focused || !this.isValid(this.elementValue))) {\n            this.setInputValue();\n        }\n    }\n    hasTrailingZeros(inputValue) {\n        if (this.hasDecimals && this.focused) {\n            const fraction = inputValue.split(this.decimalSeparator)[1];\n            return fraction && fraction.length > this.decimals && fraction.lastIndexOf('0') === fraction.length - 1;\n        }\n    }\n    selectAll() {\n        this.setInputValue();\n        this.setSelection(0, this.inputValue.length);\n    }\n    selectCaret() {\n        const caretPosition = getCaretPosition(this.numericInput.nativeElement);\n        const formattedValue = this.elementValue;\n        const partialValue = formattedValue.substring(0, caretPosition);\n        this.setInputValue();\n        if (partialValue.length) {\n            const significantCharsInFormattedValue = extractSignificantNumericChars(partialValue, this.decimalSeparator);\n            const adjustedSignificantChars = this.adjustSignificantChars(formattedValue, significantCharsInFormattedValue);\n            this.setSelection(adjustedSignificantChars, adjustedSignificantChars);\n        }\n        else {\n            this.setSelection(0, 0);\n        }\n    }\n    numberOfLeadingZeroes(formattedValue) {\n        const separatorIndex = formattedValue.indexOf(this.decimalSeparator);\n        const matchedLeadingZeroes = formattedValue.match(/^[^1-9]*?(0+)/);\n        if (matchedLeadingZeroes) {\n            const lengthOfMatch = matchedLeadingZeroes[0].length;\n            const lengthOfLeadingZeroesMatch = matchedLeadingZeroes[1].length;\n            return lengthOfMatch === separatorIndex ? lengthOfLeadingZeroesMatch - 1 : lengthOfLeadingZeroesMatch;\n        }\n        return 0;\n    }\n    adjustSignificantChars(formattedValue, significantChars) {\n        const leadingZeroes = this.numberOfLeadingZeroes(formattedValue);\n        if (leadingZeroes > 0) {\n            return Math.max(0, significantChars - leadingZeroes);\n        }\n        return significantChars;\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], NumericTextBoxComponent.prototype, \"focusableId\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], NumericTextBoxComponent.prototype, \"disabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], NumericTextBoxComponent.prototype, \"readonly\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], NumericTextBoxComponent.prototype, \"title\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], NumericTextBoxComponent.prototype, \"autoCorrect\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object),\n    __metadata(\"design:paramtypes\", [Object])\n], NumericTextBoxComponent.prototype, \"format\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], NumericTextBoxComponent.prototype, \"max\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], NumericTextBoxComponent.prototype, \"min\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], NumericTextBoxComponent.prototype, \"decimals\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], NumericTextBoxComponent.prototype, \"placeholder\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], NumericTextBoxComponent.prototype, \"step\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], NumericTextBoxComponent.prototype, \"spinners\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], NumericTextBoxComponent.prototype, \"rangeValidation\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], NumericTextBoxComponent.prototype, \"tabindex\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], NumericTextBoxComponent.prototype, \"tabIndex\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], NumericTextBoxComponent.prototype, \"changeValueOnScroll\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], NumericTextBoxComponent.prototype, \"selectOnFocus\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], NumericTextBoxComponent.prototype, \"value\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], NumericTextBoxComponent.prototype, \"maxlength\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], NumericTextBoxComponent.prototype, \"valueChange\", void 0);\n__decorate([\n    Output('focus'),\n    __metadata(\"design:type\", EventEmitter)\n], NumericTextBoxComponent.prototype, \"onFocus\", void 0);\n__decorate([\n    Output('blur'),\n    __metadata(\"design:type\", EventEmitter)\n], NumericTextBoxComponent.prototype, \"onBlur\", void 0);\n__decorate([\n    ViewChild('numericInput', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], NumericTextBoxComponent.prototype, \"numericInput\", void 0);\n__decorate([\n    ViewChild('numericWrap', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], NumericTextBoxComponent.prototype, \"numericWrap\", void 0);\n__decorate([\n    HostBinding('attr.dir'),\n    __metadata(\"design:type\", String)\n], NumericTextBoxComponent.prototype, \"direction\", void 0);\n__decorate([\n    HostBinding('class.k-widget'),\n    HostBinding('class.k-numerictextbox'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], NumericTextBoxComponent.prototype, \"widgetClasses\", null);\nNumericTextBoxComponent = NumericTextBoxComponent_1 = __decorate([\n    Component({\n        exportAs: 'kendoNumericTextBox',\n        providers: [\n            LocalizationService,\n            { provide: L10N_PREFIX, useValue: 'kendo.numerictextbox' },\n            { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NumericTextBoxComponent_1), multi: true },\n            { provide: NG_VALIDATORS, useExisting: forwardRef(() => NumericTextBoxComponent_1), multi: true },\n            { provide: KendoInput, useExisting: forwardRef(() => NumericTextBoxComponent_1) }\n        ],\n        selector: 'kendo-numerictextbox',\n        template: `\n        <ng-container kendoNumericTextBoxLocalizedMessages\n            i18n-increment=\"kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox\"\n            increment=\"Increase value\"\n            i18n-decrement=\"kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox\"\n            decrement=\"Decrease value\"\n        >\n        </ng-container>\n        <span\n            class=\"k-numeric-wrap\"\n            [class.k-state-disabled]=\"disabled\"\n            [kendoEventsOutsideAngular]=\"{ mousewheel: handleWheel, DOMMouseScroll: handleWheel }\"\n            #numericWrap>\n            <input\n            role=\"spinbutton\"\n            class=\"k-input k-formatted-value\"\n            autocomplete=\"off\"\n            autocorrect=\"off\"\n            [id]=\"focusableId\"\n            [attr.aria-valuemin]=\"min\"\n            [attr.aria-valuemax]=\"max\"\n            [attr.aria-valuenow]=\"value\"\n            [attr.title]=\"title\"\n            [attr.placeholder]=\"placeholder\"\n            [attr.maxLength]=\"maxlength\"\n            [tabindex]=\"tabIndex\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [kendoEventsOutsideAngular]=\"{\n                mousedown: handleMouseDown,\n                dragenter: handleDragEnter,\n                keydown: handleKeyDown,\n                input: handleInput,\n                focus: handleFocus,\n                blur: handleBlur,\n                paste: handlePaste\n            }\"\n            #numericInput />\n            <span class=\"k-select\" *ngIf=\"spinners\" [kendoEventsOutsideAngular]=\"{ mouseup: releaseArrow, mouseleave: releaseArrow }\">\n                <span\n                    role=\"button\"\n                    [kendoEventsOutsideAngular]=\"{ mousedown: increasePress }\"\n                    [attr.aria-label]=\"incrementTitle\"\n                    [title]=\"incrementTitle\"\n                    [class.k-state-active]=\"arrowDirection === ArrowDirection.Up\"\n                    class=\"k-link k-link-increase\"\n                >\n                    <span class=\"k-icon k-i-arrow-n\"></span>\n                </span>\n                <span\n                    role=\"button\"\n                    [kendoEventsOutsideAngular]=\"{ mousedown: decreasePress }\"\n                    [attr.aria-label]=\"decrementTitle\"\n                    [title]=\"decrementTitle\"\n                    [class.k-state-active]=\"arrowDirection === ArrowDirection.Down\"\n                    class=\"k-link k-link-decrease\"\n                >\n                    <span class=\"k-icon k-i-arrow-s\"></span>\n                </span>\n            </span>\n        </span>\n      `\n    }),\n    __metadata(\"design:paramtypes\", [IntlService,\n        Renderer2,\n        LocalizationService,\n        Injector,\n        NgZone,\n        ChangeDetectorRef,\n        ElementRef])\n], NumericTextBoxComponent);\n\n/**\n * @hidden\n */\nclass NumericTextBoxMessages extends ComponentMessages {\n}\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], NumericTextBoxMessages.prototype, \"decrement\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], NumericTextBoxMessages.prototype, \"increment\", void 0);\n\nvar NumericTextBoxCustomMessagesComponent_1;\n/**\n * Custom component messages override default component messages.\n */\nlet NumericTextBoxCustomMessagesComponent = NumericTextBoxCustomMessagesComponent_1 = class NumericTextBoxCustomMessagesComponent extends NumericTextBoxMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n};\nNumericTextBoxCustomMessagesComponent = NumericTextBoxCustomMessagesComponent_1 = __decorate([\n    Component({\n        providers: [\n            {\n                provide: NumericTextBoxMessages,\n                useExisting: forwardRef(() => NumericTextBoxCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref\n            }\n        ],\n        selector: 'kendo-numerictextbox-messages',\n        template: ``\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], NumericTextBoxCustomMessagesComponent);\n\n/**\n * @hidden\n */\nvar ResultType;\n(function (ResultType) {\n    ResultType[ResultType[\"Literal\"] = 0] = \"Literal\";\n    ResultType[ResultType[\"Mask\"] = 1] = \"Mask\";\n    ResultType[ResultType[\"Undefined\"] = 2] = \"Undefined\";\n})(ResultType || (ResultType = {}));\n/**\n * @hidden\n */\nclass Result {\n    constructor(value, rest, type = ResultType.Undefined) {\n        this.value = value;\n        this.rest = rest;\n        this.type = type;\n    }\n    //map :: Functor f => f a ~> (a -> b) -> f b\n    map(fn) {\n        return new Result(fn(this.value), this.rest);\n    }\n    //chain :: Chain m => m a ~> (a -> m b) -> m b\n    chain(fn) {\n        return fn(this.value, this.rest);\n    }\n    fold(s, _ /*we don't need it*/) {\n        return s(this.value, this.rest);\n    }\n    concat(r) {\n        return this.map((vs, _) => r.chain((v, __) => vs.concat([v])));\n    }\n    toString() {\n        return `Result({ value: '${this.value}', rest: ${this.rest} })`;\n    }\n}\n\n/**\n * @hidden\n */\nclass Stream {\n    constructor(input = [], control = []) {\n        this.input = input;\n        this.control = control;\n        this.inputCursor = 0;\n        this.controlCursor = 0;\n    }\n    eof() {\n        return this.inputCursor >= this.input.length;\n    }\n    // Get the first value from the input.\n    next() {\n        return {\n            char: this.input[this.inputCursor++],\n            control: this.control[this.controlCursor++]\n        };\n    }\n    peek() {\n        return {\n            char: this.input[this.inputCursor],\n            control: this.control[this.controlCursor]\n        };\n    }\n    eat_input() {\n        this.inputCursor++;\n    }\n    eat_control() {\n        this.controlCursor++;\n    }\n    eat() {\n        this.inputCursor++;\n        this.controlCursor++;\n    }\n}\n\nconst toArray = (value) => (value || '').split('');\nconst ESCAPE_CHARACTER = '\\\\';\n/**\n * @hidden\n */\nclass Parser {\n    constructor(parse) {\n        this.parse = parse;\n    }\n    run(input, control = '') {\n        if (input instanceof Stream) {\n            return this.parse(input);\n        }\n        else {\n            return this.parse(new Stream(toArray(input), toArray(control)));\n        }\n    }\n    //map :: Functor f => f a ~> (a -> b) -> f b\n    map(f) {\n        return new Parser(stream => this.parse(stream).map(f));\n    }\n    //chain :: Chain m => m a ~> (a -> m b) -> m b\n    chain(f) {\n        return new Parser(stream => this.parse(stream).chain((v, s) => f(v).run(s)));\n    }\n    isLiteral(c) {\n        return this.run(c).type === ResultType.Literal;\n    }\n}\n/**\n * @hidden\n */\nconst mask = ({ prompt, promptPlaceholder }) => rule => new Parser(stream => {\n    while (!stream.eof()) {\n        const { char, control } = stream.peek();\n        if (char === control && control === prompt) {\n            stream.eat();\n            return new Result(prompt, stream, ResultType.Mask);\n        }\n        if (rule.test(char)) {\n            stream.eat();\n            return new Result(char, stream, ResultType.Mask);\n        }\n        if (char === promptPlaceholder) {\n            stream.eat();\n            return new Result(prompt, stream, ResultType.Mask);\n        }\n        stream.eat_input();\n    }\n    stream.eat();\n    return new Result(prompt, stream, ResultType.Mask);\n});\n/**\n * @hidden\n */\nconst literal = _token => new Parser(stream => {\n    //    let {char, control} = stream.peek();\n    let char = stream.peek().char;\n    if (char === _token) {\n        stream.eat();\n        return new Result(_token, stream, ResultType.Literal);\n    }\n    //    if (control === _token) {\n    //        while (!stream.eof() && char !== _token) {\n    //            stream.eat_input();\n    //            char = stream.peek().char;\n    //        }\n    //    }\n    //\n    //    if (control !== undefined) {\n    //        stream.eat();\n    //    }\n    return new Result(_token, stream, ResultType.Literal);\n});\n/**\n * @hidden\n */\nconst unmask = prompt => rule => new Parser(stream => {\n    while (!stream.eof()) {\n        const { char, control } = stream.peek();\n        if (char === prompt && control === prompt) {\n            stream.eat();\n            return new Result(char, stream);\n        }\n        if (rule.test(char)) {\n            stream.eat();\n            return new Result(char, stream);\n        }\n        stream.eat_input();\n    }\n    stream.eat();\n    return new Result('', stream);\n});\n/**\n * @hidden\n */\nconst unliteral = _token => new Parser(stream => {\n    if (stream.eof()) {\n        return new Result('', stream);\n    }\n    const { char } = stream.peek();\n    if (char === _token) {\n        stream.eat();\n    }\n    return new Result(_token, stream);\n});\n/**\n * @hidden\n */\nconst token = (rules, creator) => new Parser(stream => {\n    let { char } = stream.next();\n    const rule = rules[char];\n    if (char === ESCAPE_CHARACTER) {\n        char = stream.next().char;\n        return new Result(creator.literal(char), stream);\n    }\n    if (!rule) {\n        return new Result(creator.literal(char), stream);\n    }\n    return new Result(creator.mask(rule), stream);\n});\n/**\n * @hidden\n */\nconst rawMask = ({ prompt, promptPlaceholder }) => new Parser(stream => {\n    let { char } = stream.next();\n    if (char === prompt) {\n        return new Result(promptPlaceholder, stream);\n    }\n    return new Result(char, stream);\n});\n/**\n * @hidden\n */\nconst rawLiteral = includeLiterals => new Parser(stream => {\n    let { char } = stream.next();\n    if (includeLiterals) {\n        return new Result(char, stream);\n    }\n    return new Result('', stream);\n});\n\n/**\n * @hidden\n */\nconst always = value => new Parser(stream => new Result(value, stream));\n/**\n * @hidden\n */\nconst append = (p1, p2) => p1.chain(vs => p2.map(v => vs.concat([v])));\n/**\n * @hidden\n */\nconst sequence = list => list.reduce((acc, parser) => append(acc, parser), always([]));\n/**\n * @hidden\n */\nconst greedy = parser => new Parser(stream => {\n    let result = new Result([], stream);\n    while (!stream.eof()) {\n        result = result.concat(parser.run(stream));\n    }\n    return result;\n});\n\n/**\n * @hidden\n */\nlet MaskingService = class MaskingService {\n    /**\n     * @hidden\n     */\n    constructor() {\n        this.rules = {};\n        this.prompt = \"_\";\n        this.mask = \"\";\n        this.promptPlaceholder = \" \";\n        this.includeLiterals = false;\n        this.maskTokens = [];\n        this.unmaskTokens = [];\n        this.rawTokens = [];\n        this.validationTokens = [];\n    }\n    update({ mask: mask$$1 = '', prompt = '', promptPlaceholder = ' ', rules = {}, includeLiterals = false }) {\n        this.mask = mask$$1;\n        this.prompt = prompt;\n        this.promptPlaceholder = promptPlaceholder;\n        this.rules = rules;\n        this.includeLiterals = includeLiterals;\n        this.tokenize();\n    }\n    validationValue(maskedValue = '') {\n        let value = maskedValue;\n        sequence(this.validationTokens)\n            .run(maskedValue)\n            .fold(unmasked => {\n            value = unmasked.join('');\n        });\n        return value;\n    }\n    rawValue(maskedValue = '') {\n        let value = maskedValue;\n        if (!this.rawTokens.length) {\n            return value;\n        }\n        sequence(this.rawTokens)\n            .run(maskedValue)\n            .fold(unmasked => {\n            value = unmasked.join('');\n        });\n        return value;\n    }\n    /**\n     * @hidden\n     */\n    maskRaw(rawValue = '') {\n        let value = rawValue;\n        if (!this.maskTokens.length) {\n            return value;\n        }\n        sequence(this.maskTokens)\n            .run(rawValue)\n            .fold(masked => {\n            value = masked.join('');\n        });\n        return value;\n    }\n    maskInput(input, control, splitPoint) {\n        if (input.length < control.length) {\n            return this.maskRemoved(input, control, splitPoint);\n        }\n        return this.maskInserted(input, control, splitPoint);\n    }\n    maskInRange(pasted, oldValue, start, end) {\n        let value = '';\n        let selection = end;\n        const beforeChange = oldValue.split('').slice(0, start);\n        const afterChange = oldValue.split('').slice(end);\n        sequence(this.maskTokens.slice(start, end))\n            .run(pasted)\n            .fold(masked => {\n            value = beforeChange\n                .concat(masked)\n                .concat(afterChange)\n                .join('');\n        });\n        return {\n            selection,\n            value\n        };\n    }\n    maskRemoved(input, control, splitPoint) {\n        let value = '';\n        let selection = splitPoint;\n        const unchanged = input.split('').slice(splitPoint);\n        const changed = input.split('').slice(0, splitPoint).join('');\n        const take$$1 = this.maskTokens.length - (input.length - splitPoint);\n        sequence(this.maskTokens.slice(0, take$$1))\n            .run(changed, control)\n            .fold(masked => {\n            selection = this.adjustPosition(masked, selection);\n            value = masked.concat(unchanged).join('');\n        });\n        return {\n            selection,\n            value\n        };\n    }\n    adjustPosition(input, selection) {\n        const caretChar = input[selection];\n        const isLiteral = this.maskTokens[selection].isLiteral(caretChar);\n        if (!isLiteral && caretChar !== this.prompt) {\n            return selection + 1;\n        }\n        return selection;\n    }\n    maskInserted(input, control, splitPoint) {\n        let value = '';\n        let selection = splitPoint;\n        const changed = input.slice(0, splitPoint);\n        sequence(this.unmaskTokens)\n            .run(changed, control)\n            .chain(unmasked => {\n            selection = unmasked.join('').length;\n            const unchanged = control.slice(selection);\n            return sequence(this.maskTokens)\n                .run(unmasked.join('') + unchanged, control);\n        })\n            .fold(masked => {\n            value = masked.join('');\n        });\n        return {\n            selection,\n            value\n        };\n    }\n    get maskTokenCreator() {\n        const { prompt, promptPlaceholder } = this;\n        return {\n            literal: rule => literal(rule),\n            mask: rule => mask({ prompt, promptPlaceholder })(rule)\n        };\n    }\n    get unmaskTokenCreator() {\n        return {\n            literal: rule => unliteral(rule),\n            mask: rule => unmask(this.prompt)(rule)\n        };\n    }\n    get rawTokenCreator() {\n        const { prompt, promptPlaceholder, includeLiterals } = this;\n        return {\n            literal: _ => rawLiteral(includeLiterals),\n            mask: _ => rawMask({ prompt, promptPlaceholder })\n        };\n    }\n    get validationTokenCreator() {\n        const { prompt } = this;\n        return {\n            literal: _ => rawLiteral(false),\n            mask: _ => rawMask({ prompt, promptPlaceholder: '' })\n        };\n    }\n    tokenize() {\n        greedy(token(this.rules, this.maskTokenCreator))\n            .run(this.mask)\n            .fold((tokens, _) => {\n            this.maskTokens = tokens;\n        });\n        greedy(token(this.rules, this.unmaskTokenCreator))\n            .run(this.mask)\n            .fold((tokens, _) => {\n            this.unmaskTokens = tokens;\n        });\n        greedy(token(this.rules, this.rawTokenCreator))\n            .run(this.mask)\n            .fold((tokens, _) => {\n            this.rawTokens = tokens;\n        });\n        greedy(token(this.rules, this.validationTokenCreator))\n            .run(this.mask)\n            .fold((tokens, _) => {\n            this.validationTokens = tokens;\n        });\n    }\n};\nMaskingService = __decorate([\n    Injectable()\n], MaskingService);\n\nvar MaskedTextBoxComponent_1;\nconst resolvedPromise = Promise.resolve(null);\nconst FOCUSED$2 = 'k-state-focused';\n/**\n * Represents the [Kendo UI MaskedTextBox component for Angular]({% slug overview_maskedtextbox %}).\n *\n * @example\n * ```ts-no-run\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *      <kendo-maskedtextbox\n *          [mask]=\"mask\"\n *          [value]=\"value\">\n *      </kendo-maskedtextbox>\n *     `\n * })\n *\n * class AppComponent {\n *  public value: string = \"9580128055807792\";\n *  public mask: string = \"0000-0000-0000-0000\";\n * }\n * ```\n */\nlet MaskedTextBoxComponent = MaskedTextBoxComponent_1 = class MaskedTextBoxComponent {\n    constructor(service, renderer, hostElement, ngZone, injector, changeDetector, rtl) {\n        this.service = service;\n        this.renderer = renderer;\n        this.hostElement = hostElement;\n        this.ngZone = ngZone;\n        this.injector = injector;\n        this.changeDetector = changeDetector;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Determines whether the MaskedTextBox is disabled ([see example]({% slug disabled_maskedtextbox %})).\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the MaskedTextBox is in its read-only state ([see example]({% slug readonly_maskedtextbox %})).\n         */\n        this.readonly = false;\n        this.hostClasses = true;\n        /**\n         * Represents a prompt character for the masked value.\n         * @default `_`\n         */\n        this.prompt = '_';\n        /**\n         * Indicates a character which represents an empty position in the raw value.\n         * @default ' '\n         */\n        this.promptPlaceholder = ' ';\n        /**\n         * Indicates whether to include literals in the raw value  ([see example]({% slug value_maskedtextbox %})).\n         * @default false\n         */\n        this.includeLiterals = false;\n        /**\n         * Specifies if the mask should be shown on focus for empty value.\n         */\n        this.maskOnFocus = false;\n        /**\n         * Determines whether the built-in mask validator is enforced when a form is validated\n         * ([see example]({% slug validation_maskedtextbox %})).\n         * @default true\n         */\n        this.maskValidation = true;\n        /**\n         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Fires each time the user focuses the `input` element.\n         *\n         * > To wire the event programmatically, use the `onFocus` property.\n         *\n         * @example\n         * ```ts-no-run\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-maskedtextbox (focus)=\"handleFocus()\"></kendo-maskedtextbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleFocus(): void {\n         *      console.log(\"Component is focused\");\n         *   }\n         * }\n         * ```\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the `input` element gets blurred.\n         *\n         * > To wire the event programmatically, use the `onBlur` property.\n         *\n         * @example\n         * ```ts-no-run\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-maskedtextbox (blur)=\"handleBlur()\"></kendo-maskedtextbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleBlur(): void {\n         *      console.log(\"Component is blurred\");\n         *   }\n         * }\n         * ```\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the value changes.\n         */\n        this.valueChange = new EventEmitter();\n        this.focusClick = false;\n        this.defaultRules = {\n            \"#\": /[\\d\\s\\+\\-]/,\n            \"&\": /[\\S]/,\n            \"0\": /[\\d]/,\n            \"9\": /[\\d\\s]/,\n            \"?\": /[a-zA-Z\\s]/,\n            \"A\": /[a-zA-Z0-9]/,\n            \"C\": /./,\n            \"L\": /[a-zA-Z]/,\n            \"a\": /[a-zA-Z0-9\\s]/\n        };\n        this.isPasted = false;\n        this.selection = [0, 0];\n        /**\n         * @hidden\n         */\n        this.handleFocus = () => {\n            this.focused = true;\n            if (this.maskOnFocus && this.emptyMask) {\n                this.updateInput(this.service.maskRaw(this.value));\n                this.ngZone.runOutsideAngular(() => {\n                    setTimeout(() => { this.setSelection(0, 0); }, 0);\n                });\n            }\n            if (hasObservers(this.onFocus)) {\n                this.ngZone.run(() => {\n                    this.onFocus.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleClick = () => {\n            if (this.focused && !this.focusClick) {\n                this.focusClick = true;\n                const { selectionStart, selectionEnd } = this.input.nativeElement;\n                if (selectionStart === selectionEnd) {\n                    this.setFocusSelection();\n                }\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleBlur = () => {\n            this.changeDetector.markForCheck();\n            this.focused = false;\n            this.focusClick = false;\n            if (this.maskOnFocus && this.emptyMask) {\n                this.updateInput(this.maskedValue);\n            }\n            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.onTouched();\n                    this.onBlur.emit();\n                });\n            }\n        };\n        this.onChange = (_) => { };\n        this.onTouched = () => { };\n        validatePackage(packageMetadata);\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.updateService();\n    }\n    get hostDisabledClass() {\n        return this.disabled;\n    }\n    /**\n     * Exposes the RegExp-based mask validation array ([see example]({% slug masks_maskedtextbox %})).\n     */\n    get rules() {\n        return this._rules || this.defaultRules;\n    }\n    set rules(value) {\n        this._rules = Object.assign({}, this.defaultRules, value);\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    ngOnInit() {\n        if (this.hostElement) {\n            this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n        }\n        this.control = this.injector.get(NgControl, null);\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the MaskedTextBox is empty.\n     */\n    isEmpty() {\n        if (this.input) {\n            return !Boolean(this.input.nativeElement.value);\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleDragDrop() {\n        return false;\n    }\n    /**\n     * Focuses the MaskedTextBox.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"maskedinput.focus()\">Focus the input</button>\n     *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.input) {\n            return;\n        }\n        this.input.nativeElement.focus();\n        this.setFocusSelection();\n    }\n    /**\n     * Blurs the MaskedTextBox.\n     */\n    blur() {\n        if (!this.input) {\n            return;\n        }\n        this.input.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     */\n    pasteHandler(e) {\n        const { selectionStart, selectionEnd } = e.target;\n        if (selectionEnd === selectionStart) {\n            return;\n        }\n        this.isPasted = true;\n        this.selection = [selectionStart, selectionEnd];\n    }\n    /**\n     * @hidden\n     */\n    inputHandler(e) {\n        const value = e.target.value;\n        const [start, end] = this.selection;\n        if (!this.mask) {\n            this.updateValue(value);\n            this.isPasted = false;\n            return;\n        }\n        let result;\n        if (this.isPasted) {\n            this.isPasted = false;\n            const rightPart = this.maskedValue.length - end;\n            const to = value.length - rightPart;\n            result = this.service.maskInRange(value.slice(start, to), this.maskedValue, start, end);\n        }\n        else {\n            result = this.service.maskInput(value, this.maskedValue, e.target.selectionStart);\n        }\n        this.updateInput(result.value, result.selection);\n        this.updateValue(result.value);\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n        if (changes.value) {\n            this.value = this.normalizeValue();\n        }\n        if (!this.mask) {\n            this.updateInput(this.value);\n            return;\n        }\n        const next = this.extractChanges(changes);\n        this.updateService(next);\n        if (isChanged('value', changes)) {\n            const maskedValue = this.service.maskRaw(this.value);\n            if (maskedValue !== this.maskedValue) {\n                this.updateInput(maskedValue);\n            }\n        }\n        else if (anyChanged(['promptPlaceholder', 'includeLiterals'], changes)) {\n            resolvedPromise.then(() => {\n                this.updateValue(this.maskedValue);\n            });\n        }\n        else {\n            this.updateInput(this.service.maskRaw(this.value));\n        }\n    }\n    /**\n     * @hidden\n     * Writes a new value to the element.\n     */\n    writeValue(value) {\n        this.value = this.normalizeValue(value);\n        this.updateInput(this.service.maskRaw(this.value));\n    }\n    /**\n     * @hidden\n     * Sets the function that will be called when a `change` event is triggered.\n     */\n    registerOnChange(fn) {\n        this.onChange = fn;\n    }\n    /**\n     * @hidden\n     * Sets the function that will be called when a `touch` event is triggered.\n     */\n    registerOnTouched(fn) {\n        this.onTouched = fn;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n        this.changeDetector.markForCheck();\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    validate(_) {\n        if (this.maskValidation === false || !this.mask) {\n            return null;\n        }\n        if (!this.service.validationValue(this.maskedValue)) {\n            return null;\n        }\n        if (this.maskedValue.indexOf(this.prompt) !== -1) {\n            return {\n                patternError: {\n                    mask: this.mask,\n                    maskedValue: this.maskedValue,\n                    value: this.value\n                }\n            };\n        }\n        return null;\n    }\n    /**\n     * @hidden\n     */\n    updateValue(maskedValue) {\n        if (this.mask && !this.service.validationValue(maskedValue)) {\n            this.value = '';\n        }\n        else {\n            this.value = this.service.rawValue(maskedValue);\n        }\n        this.onChange(this.value);\n        this.valueChange.emit(this.value);\n    }\n    updateInput(maskedValue = '', selection) {\n        this.maskedValue = maskedValue;\n        const value = this.maskOnFocus && !this.focused && this.emptyMask ? '' : maskedValue;\n        this.renderer.setProperty(this.input.nativeElement, \"value\", value);\n        if (selection !== undefined) {\n            this.setSelection(selection, selection);\n        }\n    }\n    extractChanges(changes) {\n        return Object.keys(changes).filter(key => key !== 'rules').reduce((obj, key) => {\n            obj[key] = changes[key].currentValue;\n            return obj;\n        }, {}); // tslint:disable-line:align\n    }\n    updateService(extra) {\n        const config = Object.assign({\n            includeLiterals: this.includeLiterals,\n            mask: this.mask,\n            prompt: this.prompt,\n            promptPlaceholder: this.promptPlaceholder,\n            rules: this.rules\n        }, extra); // tslint:disable-line:align\n        this.service.update(config);\n    }\n    setSelection(start = this.selection[0], end = this.selection[1]) {\n        if (this.focused) {\n            invokeElementMethod(this.input, 'setSelectionRange', start, end);\n        }\n    }\n    get emptyMask() {\n        return this.service.maskRaw() === this.maskedValue;\n    }\n    setFocusSelection() {\n        const selectionStart = this.input.nativeElement.selectionStart;\n        const index = this.maskedValue ? this.maskedValue.indexOf(this.prompt) : 0;\n        if (index >= 0 && index < selectionStart) {\n            this.selection = [index, index];\n            this.setSelection();\n        }\n    }\n    get focused() {\n        return this.isFocused;\n    }\n    set focused(value) {\n        if (this.isFocused !== value && this.hostElement) {\n            const element = this.hostElement.nativeElement;\n            if (value) {\n                this.renderer.addClass(element, FOCUSED$2);\n            }\n            else {\n                this.renderer.removeClass(element, FOCUSED$2);\n            }\n            this.isFocused = value;\n        }\n    }\n    normalizeValue(value = this.value) {\n        const present = isPresent(value);\n        if (present && typeof value !== 'string') {\n            if (isDevMode()) {\n                throw new Error('The MaskedTextBox component supports only string values.');\n            }\n            return String(value);\n        }\n        return present ? value : '';\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"focusableId\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], MaskedTextBoxComponent.prototype, \"disabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], MaskedTextBoxComponent.prototype, \"readonly\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"title\", void 0);\n__decorate([\n    HostBinding('attr.dir'),\n    __metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"direction\", void 0);\n__decorate([\n    HostBinding('class.k-widget'),\n    HostBinding('class.k-maskedtextbox'),\n    __metadata(\"design:type\", Boolean)\n], MaskedTextBoxComponent.prototype, \"hostClasses\", void 0);\n__decorate([\n    HostBinding('class.k-state-disabled'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], MaskedTextBoxComponent.prototype, \"hostDisabledClass\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"mask\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"value\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object),\n    __metadata(\"design:paramtypes\", [Object])\n], MaskedTextBoxComponent.prototype, \"rules\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"prompt\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], MaskedTextBoxComponent.prototype, \"promptPlaceholder\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], MaskedTextBoxComponent.prototype, \"includeLiterals\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], MaskedTextBoxComponent.prototype, \"maskOnFocus\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], MaskedTextBoxComponent.prototype, \"maskValidation\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], MaskedTextBoxComponent.prototype, \"tabindex\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], MaskedTextBoxComponent.prototype, \"tabIndex\", null);\n__decorate([\n    Output('focus'),\n    __metadata(\"design:type\", EventEmitter)\n], MaskedTextBoxComponent.prototype, \"onFocus\", void 0);\n__decorate([\n    Output('blur'),\n    __metadata(\"design:type\", EventEmitter)\n], MaskedTextBoxComponent.prototype, \"onBlur\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], MaskedTextBoxComponent.prototype, \"valueChange\", void 0);\n__decorate([\n    ViewChild('input', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], MaskedTextBoxComponent.prototype, \"input\", void 0);\n__decorate([\n    HostListener('paste', ['$event']),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object]),\n    __metadata(\"design:returntype\", void 0)\n], MaskedTextBoxComponent.prototype, \"pasteHandler\", null);\n__decorate([\n    HostListener('input', ['$event']),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object]),\n    __metadata(\"design:returntype\", void 0)\n], MaskedTextBoxComponent.prototype, \"inputHandler\", null);\nMaskedTextBoxComponent = MaskedTextBoxComponent_1 = __decorate([\n    Component({\n        exportAs: 'kendoMaskedTextBox',\n        providers: [\n            MaskingService,\n            {\n                multi: true,\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => MaskedTextBoxComponent_1) /* tslint:disable-line */\n            },\n            {\n                multi: true,\n                provide: NG_VALIDATORS,\n                useExisting: forwardRef(() => MaskedTextBoxComponent_1) /* tslint:disable-line */\n            },\n            {\n                provide: KendoInput,\n                useExisting: forwardRef(() => MaskedTextBoxComponent_1)\n            }\n        ],\n        selector: 'kendo-maskedtextbox',\n        template: `\n        <input type=\"text\"\n            #input\n            autocomplete=\"off\"\n            autocorrect=\"off\"\n            autocapitalize=\"off\"\n            spellcheck=\"false\"\n            class=\"k-textbox\"\n            [id]=\"focusableId\"\n            [tabindex]=\"tabIndex\"\n            [attr.title]=\"title\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [kendoEventsOutsideAngular]=\"{\n                focus: handleFocus,\n                blur: handleBlur,\n                click: handleClick,\n                dragstart: handleDragDrop,\n                drop: handleDragDrop\n            }\"\n        />\n    `\n    }),\n    __param(6, Optional()), __param(6, Inject(RTL)),\n    __metadata(\"design:paramtypes\", [MaskingService,\n        Renderer2,\n        ElementRef,\n        NgZone,\n        Injector,\n        ChangeDetectorRef, Boolean])\n], MaskedTextBoxComponent);\n\n/**\n * @hidden\n */\nclass SliderTick {\n    constructor(value) {\n        this.value = value;\n        this.classes = {\n            'k-tick': true\n        };\n    }\n}\n/**\n * @hidden\n */\nlet SliderTicksComponent = class SliderTicksComponent {\n    constructor(rtl) {\n        this.rtl = rtl;\n        this.wrapperClasses = 'k-reset k-slider-items';\n        this.ticks = [];\n    }\n    ngOnChanges(_) {\n        this.createTicks();\n    }\n    createTicks() {\n        const count = calculateTicksCount(this.min, this.max, this.step);\n        const largeStep = this.largeStep;\n        const tickValueProps = {\n            max: this.max,\n            min: this.min,\n            smallStep: this.step\n        };\n        let result = [];\n        for (let i = 0; i < count; i++) {\n            result.push(new SliderTick(calculateValueFromTick(i, tickValueProps)));\n            if (largeStep && i % largeStep === 0) {\n                result[i].large = true;\n                result[i].classes['k-tick-large'] = true;\n            }\n        }\n        if (this.rtl || this.vertical) {\n            result = result.reverse();\n        }\n        if (result.length > 0) {\n            Object.assign(result[0].classes, this.endTickClasses(true));\n            Object.assign(result[result.length - 1].classes, this.endTickClasses(false));\n        }\n        this.ticks = result;\n    }\n    endTickClasses(first) {\n        return {\n            'k-first': (first && !this.vertical) || (!first && this.vertical),\n            'k-last': (!first && !this.vertical) || (first && this.vertical)\n        };\n    }\n};\n__decorate([\n    HostBinding('class'),\n    __metadata(\"design:type\", String)\n], SliderTicksComponent.prototype, \"wrapperClasses\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Function)\n], SliderTicksComponent.prototype, \"tickTitle\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], SliderTicksComponent.prototype, \"vertical\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], SliderTicksComponent.prototype, \"step\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], SliderTicksComponent.prototype, \"largeStep\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], SliderTicksComponent.prototype, \"min\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], SliderTicksComponent.prototype, \"max\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", TemplateRef)\n], SliderTicksComponent.prototype, \"labelTemplate\", void 0);\n__decorate([\n    ViewChildren('tickElement'),\n    __metadata(\"design:type\", QueryList)\n], SliderTicksComponent.prototype, \"tickElements\", void 0);\nSliderTicksComponent = __decorate([\n    Component({\n        selector: '[kendoSliderTicks]',\n        template: `\n    <li #tickElement *ngFor=\"let tick of ticks;\"\n        [ngClass]=\"tick.classes\"\n        title=\"{{ tickTitle(tick.value) }}\"\n        role=\"presentation\"\n     >\n         <ng-container [ngSwitch]=\"tick.large\">\n            <span class=\"k-label\" *ngSwitchCase=\"true\">\n                <ng-container [ngTemplateOutlet]=\"labelTemplate || defaultLabel\" [ngTemplateOutletContext]=\"tick\">\n                </ng-container>\n            </span>\n            <ng-container *ngSwitchCase=\"false\">&nbsp;</ng-container>\n         </ng-container>\n     </li>\n\n     <ng-template #defaultLabel let-value=\"value\">\n        {{ tickTitle(value) }}\n     </ng-template>\n  `\n    }),\n    __param(0, Optional()), __param(0, Inject(RTL)),\n    __metadata(\"design:paramtypes\", [Boolean])\n], SliderTicksComponent);\n\n/**\n * @hidden\n */\nlet SlidersCommonModule = class SlidersCommonModule {\n};\nSlidersCommonModule = __decorate([\n    NgModule({\n        declarations: [\n            SliderTicksComponent,\n            LabelTemplateDirective\n        ],\n        exports: [\n            LabelTemplateDirective,\n            SliderTicksComponent,\n            DraggableModule,\n            EventsModule,\n            ResizeSensorModule\n        ],\n        imports: [CommonModule, DraggableModule, EventsModule, ResizeSensorModule]\n    })\n], SlidersCommonModule);\n\n/**\n * @hidden\n */\nclass SliderMessages extends ComponentMessages {\n}\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], SliderMessages.prototype, \"decrement\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], SliderMessages.prototype, \"increment\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], SliderMessages.prototype, \"dragHandle\", void 0);\n\nvar LocalizedSliderMessagesDirective_1;\n/**\n * @hidden\n */\nlet LocalizedSliderMessagesDirective = LocalizedSliderMessagesDirective_1 = class LocalizedSliderMessagesDirective extends SliderMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n};\nLocalizedSliderMessagesDirective = LocalizedSliderMessagesDirective_1 = __decorate([\n    Directive({\n        providers: [\n            {\n                provide: SliderMessages,\n                useExisting: forwardRef(() => LocalizedSliderMessagesDirective_1) // tslint:disable-line:no-forward-ref\n            }\n        ],\n        selector: '[kendoSliderLocalizedMessages]'\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], LocalizedSliderMessagesDirective);\n\nvar SliderCustomMessagesComponent_1;\n/**\n * Custom component messages override default component messages.\n */\nlet SliderCustomMessagesComponent = SliderCustomMessagesComponent_1 = class SliderCustomMessagesComponent extends SliderMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n};\nSliderCustomMessagesComponent = SliderCustomMessagesComponent_1 = __decorate([\n    Component({\n        providers: [\n            {\n                provide: SliderMessages,\n                useExisting: forwardRef(() => SliderCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref\n            }\n        ],\n        selector: 'kendo-slider-messages',\n        template: ``\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], SliderCustomMessagesComponent);\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Slider component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Inputs module\n * import { SliderModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, SliderModule], // import Slider module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet SliderModule = class SliderModule {\n};\nSliderModule = __decorate([\n    NgModule({\n        declarations: [\n            SliderComponent,\n            SliderCustomMessagesComponent,\n            LocalizedSliderMessagesDirective\n        ],\n        exports: [\n            SliderComponent,\n            SliderCustomMessagesComponent,\n            LabelTemplateDirective,\n            LocalizedSliderMessagesDirective\n        ],\n        imports: [CommonModule, SlidersCommonModule]\n    })\n], SliderModule);\n\n/**\n * @hidden\n */\nclass RangeSliderMessages extends ComponentMessages {\n}\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], RangeSliderMessages.prototype, \"dragHandleStart\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], RangeSliderMessages.prototype, \"dragHandleEnd\", void 0);\n\nvar LocalizedRangeSliderMessagesDirective_1;\n/**\n * @hidden\n */\nlet LocalizedRangeSliderMessagesDirective = LocalizedRangeSliderMessagesDirective_1 = class LocalizedRangeSliderMessagesDirective extends RangeSliderMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n};\nLocalizedRangeSliderMessagesDirective = LocalizedRangeSliderMessagesDirective_1 = __decorate([\n    Directive({\n        providers: [\n            {\n                provide: RangeSliderMessages,\n                useExisting: forwardRef(() => LocalizedRangeSliderMessagesDirective_1) // tslint:disable-line:no-forward-ref\n            }\n        ],\n        selector: '[kendoSliderLocalizedMessages]'\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], LocalizedRangeSliderMessagesDirective);\n\nvar RangeSliderCustomMessagesComponent_1;\n/**\n * Custom component messages override default component messages.\n */\nlet RangeSliderCustomMessagesComponent = RangeSliderCustomMessagesComponent_1 = class RangeSliderCustomMessagesComponent extends RangeSliderMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n};\nRangeSliderCustomMessagesComponent = RangeSliderCustomMessagesComponent_1 = __decorate([\n    Component({\n        providers: [\n            {\n                provide: RangeSliderMessages,\n                useExisting: forwardRef(() => RangeSliderCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref\n            }\n        ],\n        selector: 'kendo-rangeslider-messages',\n        template: ``\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], RangeSliderCustomMessagesComponent);\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the RangeSlider component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Inputs module\n * import { RangeSliderModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, RangeSliderModule], // import RangeSlider module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet RangeSliderModule = class RangeSliderModule {\n};\nRangeSliderModule = __decorate([\n    NgModule({\n        declarations: [\n            RangeSliderComponent,\n            RangeSliderCustomMessagesComponent,\n            LocalizedRangeSliderMessagesDirective\n        ],\n        exports: [\n            RangeSliderComponent,\n            RangeSliderCustomMessagesComponent,\n            LocalizedRangeSliderMessagesDirective,\n            LabelTemplateDirective\n        ],\n        imports: [CommonModule, SlidersCommonModule]\n    })\n], RangeSliderModule);\n\n/**\n * @hidden\n */\nclass Messages extends ComponentMessages {\n}\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], Messages.prototype, \"on\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], Messages.prototype, \"off\", void 0);\n\nvar LocalizedSwitchMessagesDirective_1;\n/**\n * @hidden\n */\nlet LocalizedSwitchMessagesDirective = LocalizedSwitchMessagesDirective_1 = class LocalizedSwitchMessagesDirective extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n};\nLocalizedSwitchMessagesDirective = LocalizedSwitchMessagesDirective_1 = __decorate([\n    Directive({\n        providers: [\n            {\n                provide: Messages,\n                useExisting: forwardRef(() => LocalizedSwitchMessagesDirective_1) // tslint:disable-line:no-forward-ref\n            }\n        ],\n        selector: '[kendoSwitchLocalizedMessages]'\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], LocalizedSwitchMessagesDirective);\n\nvar SwitchCustomMessagesComponent_1;\n/**\n * Custom component messages override default component messages.\n */\nlet SwitchCustomMessagesComponent = SwitchCustomMessagesComponent_1 = class SwitchCustomMessagesComponent extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n};\nSwitchCustomMessagesComponent = SwitchCustomMessagesComponent_1 = __decorate([\n    Component({\n        providers: [\n            {\n                provide: Messages,\n                useExisting: forwardRef(() => SwitchCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref\n            }\n        ],\n        selector: 'kendo-switch-messages',\n        template: ``\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], SwitchCustomMessagesComponent);\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Switch component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Switch module\n * import { SwitchModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, SwitchModule], // import Switch module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet SwitchModule = class SwitchModule {\n};\nSwitchModule = __decorate([\n    NgModule({\n        declarations: [\n            SwitchComponent,\n            SwitchCustomMessagesComponent,\n            LocalizedSwitchMessagesDirective\n        ],\n        exports: [\n            SwitchComponent,\n            SwitchCustomMessagesComponent,\n            LocalizedSwitchMessagesDirective\n        ],\n        imports: [CommonModule, EventsModule, ResizeSensorModule]\n    })\n], SwitchModule);\n\nvar LocalizedNumericTextBoxMessagesDirective_1;\n/**\n * @hidden\n */\nlet LocalizedNumericTextBoxMessagesDirective = LocalizedNumericTextBoxMessagesDirective_1 = class LocalizedNumericTextBoxMessagesDirective extends NumericTextBoxMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n};\nLocalizedNumericTextBoxMessagesDirective = LocalizedNumericTextBoxMessagesDirective_1 = __decorate([\n    Directive({\n        providers: [\n            {\n                provide: NumericTextBoxMessages,\n                useExisting: forwardRef(() => LocalizedNumericTextBoxMessagesDirective_1) // tslint:disable-line:no-forward-ref\n            }\n        ],\n        selector: '[kendoNumericTextBoxLocalizedMessages]'\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], LocalizedNumericTextBoxMessagesDirective);\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the NumericTextBox component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the NumericTextBox module\n * import { NumericTextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, NumericTextBoxModule], // import NumericTextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet NumericTextBoxModule = class NumericTextBoxModule {\n};\nNumericTextBoxModule = __decorate([\n    NgModule({\n        declarations: [\n            LocalizedNumericTextBoxMessagesDirective,\n            NumericTextBoxComponent,\n            NumericTextBoxCustomMessagesComponent\n        ],\n        exports: [\n            NumericTextBoxComponent,\n            NumericTextBoxCustomMessagesComponent\n        ],\n        imports: [CommonModule, EventsModule]\n    })\n], NumericTextBoxModule);\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the MaskedTextBox component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the MaskedTextBox module\n * import { MaskedTextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, MaskedTextBoxModule], // import MaskedTextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet MaskedTextBoxModule = class MaskedTextBoxModule {\n};\nMaskedTextBoxModule = __decorate([\n    NgModule({\n        declarations: [MaskedTextBoxComponent],\n        exports: [MaskedTextBoxComponent],\n        imports: [CommonModule, EventsModule]\n    })\n], MaskedTextBoxModule);\n\n/**\n * @hidden\n *\n * Returns true if the used browser is Safari.\n */\nconst isSafari = (userAgent) => {\n    return detectDesktopBrowser(userAgent).safari ||\n        (detectMobileOS(userAgent) && detectMobileOS(userAgent).browser === 'mobilesafari');\n};\n/**\n * @hidden\n *\n * Checks if input is Japanese IME\n */\nconst isJapanese = (input) => {\n    const japaneseRegex = /[\\u3000-\\u303F]|[\\u3040-\\u309F]|[\\u30A0-\\u30FF]|[\\uFF00-\\uFFEF]|[\\u4E00-\\u9FAF]|[\\u2605-\\u2606]|[\\u2190-\\u2195]|\\u203B/g;\n    return japaneseRegex.test(input);\n};\n\n/**\n * Specifies the adornments in the suffix container ([see examples]({% slug adornments_textbox %}#toc-suffixadornments)).\n *  @example\n * ```ts-no-run\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-textbox>\n *    <ng-template kendoTextBoxSuffixTemplate>\n *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n *    </ng-template>\n *  </kendo-textbox>\n * `\n * })\n * class AppComponent {}\n * ```\n */\nlet TextBoxSuffixTemplateDirective = class TextBoxSuffixTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n};\nTextBoxSuffixTemplateDirective = __decorate([\n    Directive({\n        selector: '[kendoTextBoxSuffixTemplate]'\n    }),\n    __param(0, Optional()),\n    __metadata(\"design:paramtypes\", [TemplateRef])\n], TextBoxSuffixTemplateDirective);\n\n/**\n * Specifies the adornments in the prefix container ([see examples]({% slug adornments_textbox %}#toc-prefixadornments)).\n * @example\n * ```ts-no-run\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-textbox>\n *    <ng-template kendoTextBoxPrefixTemplate>\n *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n *    </ng-template>\n *  </kendo-textbox>\n * `\n * })\n * class AppComponent {}\n * ```\n */\nlet TextBoxPrefixTemplateDirective = class TextBoxPrefixTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n};\nTextBoxPrefixTemplateDirective = __decorate([\n    Directive({\n        selector: '[kendoTextBoxPrefixTemplate]'\n    }),\n    __param(0, Optional()),\n    __metadata(\"design:paramtypes\", [TemplateRef])\n], TextBoxPrefixTemplateDirective);\n\nvar TextBoxComponent_1;\nconst FOCUSED$3 = 'k-state-focused';\nlet TextBoxComponent = TextBoxComponent_1 = class TextBoxComponent {\n    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {\n        this.localizationService = localizationService;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.renderer = renderer;\n        this.injector = injector;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Sets the `title` attribute of the `input` element of the TextBox.\n         */\n        this.title = '';\n        /**\n         * Sets the disabled state of the component.\n         *\n         * @default false\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the component.\n         *\n         * @default false\n         */\n        this.readonly = false;\n        /**\n         * Specifies the `tabindex` of the TextBox.\n         *\n         * @default 0\n         */\n        this.tabindex = 0;\n        /**\n         * Provides a value for the TextBox.\n         */\n        this.value = null;\n        /**\n         * Determines whether the whole value will be selected when the TextBox is clicked. Defaults to `false`.\n         *\n         * @default false\n         */\n        this.selectOnFocus = false;\n        /**\n         * Specifies when the Success icon will be shown ([see example]({% slug validation_textbox %})).\n         *\n         * The possible values are:\n         *\n         * `boolean`&mdash;The Success icon is displayed, if the condition given by the developer is met.\n         *\n         * `initial`&mdash;The Success icon will be displayed when the component state is neither `invalid` nor `touched` or `dirty`.\n         *\n         * @default false\n         */\n        this.showSuccessIcon = false;\n        /**\n         * Specifies when the Error icon will be shown ([see example]({% slug validation_textbox %})).\n         *\n         * The possible values are:\n         *\n         * * `initial`&mdash;The Error icon will be displayed when the component state is\n         * `invalid` and `touched` or `dirty`.\n         * * `boolean`&mdash;The Error icon is displayed, if the condition given by the developer is met.\n         *\n         * @default false\n         */\n        this.showErrorIcon = false;\n        /**\n         * Specifies whether a Clear button will be rendered.\n         *\n         * @default false\n         */\n        this.clearButton = false;\n        /**\n         * Fires each time the value is changed&mdash;\n         * when the component is blurred or the value is cleared through the **Clear** button\n         * ([see example]({% slug overview_textbox %}#toc-events)).\n         * When the value of the component is programmatically changed to `ngModel` or `formControl`\n         * through its API or form binding, the `valueChange` event is not triggered because it\n         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user focuses the `input` element.\n         */\n        this.inputFocus = new EventEmitter();\n        /**\n         * Fires each time the `input` element gets blurred.\n         */\n        this.inputBlur = new EventEmitter();\n        /**\n         * Fires each time the user focuses the TextBox component.\n         *\n         * > To wire the event programmatically, use the `onFocus` property.\n         *\n         * @example\n         * ```ts-no-run\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-textbox (focus)=\"handleFocus()\"></kendo-textbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleFocus(): void {\n         *      console.log('Component is isFocused');\n         *   }\n         * }\n         * ```\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * Fires each time the TextBox component gets blurred.\n         *\n         * > To wire the event programmatically, use the `onBlur` property.\n         *\n         * @example\n         * ```ts-no-run\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-textbox (blur)=\"handleBlur()\"></kendo-textbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleBlur(): void {\n         *      console.log('Component is blurred');\n         *   }\n         * }\n         * ```\n         */\n        this.onBlur = new EventEmitter();\n        this.hostClass = true;\n        this._isFocused = false;\n        this.focusChangedProgrammatically = false;\n        /**\n         * @hidden\n         */\n        this.handleInputFocus = () => {\n            if (!this.disabled) {\n                if (this.selectOnFocus && this.value) {\n                    this.ngZone.run(() => {\n                        setTimeout(() => { this.selectAll(); });\n                    });\n                }\n                if (hasObservers(this.onFocus)) {\n                    if (!this.isFocused) {\n                        this.ngZone.run(() => {\n                            this.onFocus.emit();\n                        });\n                    }\n                }\n                if (hasObservers(this.inputFocus)) {\n                    if (!this.focusChangedProgrammatically || (this.focusChangedProgrammatically && this.clearButtonClicked)) {\n                        this.ngZone.run(() => {\n                            this.inputFocus.emit();\n                        });\n                    }\n                }\n                this.ngZone.run(() => {\n                    this.isFocused = true;\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleInputBlur = () => {\n            this.changeDetector.markForCheck();\n            if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.ngTouched();\n                    this.inputBlur.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleInput = (ev) => {\n            let incomingValue = isSafari(navigator.userAgent) && isJapanese(ev.target.value) ? ev.data : ev.target.value;\n            this.updateValue(incomingValue);\n        };\n        this.ngChange = (_) => { };\n        this.ngTouched = () => { };\n        validatePackage(packageMetadata);\n        this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    get disabledClass() {\n        return this.disabled;\n    }\n    ngOnInit() {\n        this.control = this.injector.get(NgControl, null);\n        this.checkClearButton();\n        this.subscriptions = this.localizationService.changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n    }\n    ngAfterViewInit() {\n        const hostElement = this.hostElement.nativeElement;\n        let cursorInsideWrapper = false;\n        let tabbing = false;\n        this.ngZone.runOutsideAngular(() => {\n            // focusIn and focusOut are relative to the host element\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n                if (!this.isFocused) {\n                    this.ngZone.run(() => {\n                        this.onFocus.emit();\n                        this.isFocused = true;\n                    });\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {\n                if (!this.isFocused) {\n                    return;\n                }\n                if (tabbing) {\n                    const closestTextbox = closest(args.relatedTarget, (element) => element === this.hostElement.nativeElement);\n                    if (!closestTextbox) {\n                        this.handleBlur();\n                    }\n                    tabbing = false;\n                }\n                else {\n                    if (!cursorInsideWrapper && !this.clearButtonClicked) {\n                        this.handleBlur();\n                    }\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n                cursorInsideWrapper = true;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n                cursorInsideWrapper = false;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {\n                if (args.keyCode === Keys.Tab) {\n                    tabbing = true;\n                }\n                else {\n                    tabbing = false;\n                }\n            }));\n        });\n    }\n    ngOnChanges(changes) {\n        if (changes.disabled || changes.readonly || changes.value) {\n            this.checkClearButton();\n        }\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n    }\n    /**\n     * Focuses the TextBox.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"input.focus()\">Focus the input</button>\n     *  <kendo-textbox #input></kendo-textbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.input) {\n            return;\n        }\n        this.focusChangedProgrammatically = true;\n        this.isFocused = true;\n        this.input.nativeElement.focus();\n        this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the TextBox.\n     */\n    blur() {\n        this.focusChangedProgrammatically = true;\n        const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');\n        if (isFocusedElement) {\n            isFocusedElement.blur();\n        }\n        this.isFocused = false;\n        this.focusChangedProgrammatically = false;\n    }\n    /**\n     * @hidden\n     */\n    clearTitle() {\n        return this.localizationService.get('clear');\n    }\n    /**\n     * @hidden\n     */\n    checkClearButton() {\n        this.showClearButton =\n            !this.disabled &&\n                !this.readonly &&\n                this.clearButton &&\n                !!this.value;\n    }\n    /**\n     * @hidden\n     */\n    clearValue(ev) {\n        if (ev) {\n            ev.preventDefault();\n        }\n        this.clearButtonClicked = true;\n        this.input.nativeElement.value = '';\n        this.input.nativeElement.focus();\n        this.updateValue('');\n        this.checkClearButton();\n        this.clearButtonClicked = false;\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.value = value;\n        this.checkClearButton();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n        this.changeDetector.markForCheck();\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    showErrorsInitial() {\n        if (!this.control) {\n            return false;\n        }\n        const { invalid, dirty, touched } = this.control;\n        return invalid && (dirty || touched);\n    }\n    /**\n     * @hidden\n     */\n    showSuccessInitial() {\n        if (!this.control) {\n            return false;\n        }\n        const { valid, dirty, touched } = this.control;\n        return valid && (dirty || touched);\n    }\n    /**\n     * @hidden\n     */\n    get successIconClasses() {\n        return this.successIcon\n            ? `k-text-success ${this.successIcon}`\n            : `k-text-success k-icon k-i-check-outline`;\n    }\n    /**\n     * @hidden\n     */\n    get errorIconClasses() {\n        return this.errorIcon\n            ? `k-text-error ${this.errorIcon}`\n            : `k-text-error k-icon k-i-warning`;\n    }\n    /**\n     * @hidden\n     */\n    get clearButtonClasses() {\n        return this.clearButtonIcon\n            ? this.clearButtonIcon\n            : `k-icon k-i-close-circle`;\n    }\n    /**\n     * @hidden\n     */\n    get hasErrors() {\n        return this.showErrorIcon === 'initial'\n            ? this.showErrorsInitial()\n            : this.showErrorIcon;\n    }\n    /**\n     * @hidden\n     */\n    get isSuccessful() {\n        return this.showSuccessIcon === 'initial'\n            ? this.showSuccessInitial()\n            : this.showSuccessIcon;\n    }\n    setSelection(start, end) {\n        if (this.isFocused) {\n            invokeElementMethod(this.input, 'setSelectionRange', start, end);\n        }\n    }\n    selectAll() {\n        if (this.value) {\n            this.setSelection(0, this.value.length);\n        }\n    }\n    updateValue(value) {\n        if (!areSame(this.value, value)) {\n            this.ngZone.run(() => {\n                this.value = value;\n                this.ngChange(value);\n                this.valueChange.emit(value);\n                this.checkClearButton();\n                this.changeDetector.markForCheck();\n            });\n        }\n    }\n    get isFocused() {\n        return this._isFocused;\n    }\n    set isFocused(value) {\n        if (this._isFocused !== value && this.hostElement) {\n            const element = this.hostElement.nativeElement;\n            if (value && !this.disabled) {\n                this.renderer.addClass(element, FOCUSED$3);\n            }\n            else {\n                this.renderer.removeClass(element, FOCUSED$3);\n            }\n            this._isFocused = value;\n        }\n    }\n    handleBlur() {\n        this.ngZone.run(() => {\n            if (!this.focusChangedProgrammatically) {\n                this.onBlur.emit();\n            }\n            this.isFocused = false;\n        });\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"focusableId\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"title\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], TextBoxComponent.prototype, \"disabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], TextBoxComponent.prototype, \"readonly\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], TextBoxComponent.prototype, \"tabindex\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"value\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], TextBoxComponent.prototype, \"selectOnFocus\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TextBoxComponent.prototype, \"showSuccessIcon\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TextBoxComponent.prototype, \"showErrorIcon\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], TextBoxComponent.prototype, \"clearButton\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"successIcon\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"errorIcon\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"clearButtonIcon\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], TextBoxComponent.prototype, \"tabIndex\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"placeholder\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], TextBoxComponent.prototype, \"maxlength\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TextBoxComponent.prototype, \"valueChange\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TextBoxComponent.prototype, \"inputFocus\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TextBoxComponent.prototype, \"inputBlur\", void 0);\n__decorate([\n    Output('focus'),\n    __metadata(\"design:type\", EventEmitter)\n], TextBoxComponent.prototype, \"onFocus\", void 0);\n__decorate([\n    Output('blur'),\n    __metadata(\"design:type\", EventEmitter)\n], TextBoxComponent.prototype, \"onBlur\", void 0);\n__decorate([\n    ViewChild('input', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], TextBoxComponent.prototype, \"input\", void 0);\n__decorate([\n    ContentChild(TextBoxSuffixTemplateDirective, { static: false }),\n    __metadata(\"design:type\", TextBoxSuffixTemplateDirective)\n], TextBoxComponent.prototype, \"suffixTemplate\", void 0);\n__decorate([\n    ContentChild(TextBoxPrefixTemplateDirective, { static: false }),\n    __metadata(\"design:type\", TextBoxPrefixTemplateDirective)\n], TextBoxComponent.prototype, \"prefixTemplate\", void 0);\n__decorate([\n    HostBinding('class.k-state-disabled'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], TextBoxComponent.prototype, \"disabledClass\", null);\n__decorate([\n    HostBinding('class.k-textbox'),\n    __metadata(\"design:type\", Boolean)\n], TextBoxComponent.prototype, \"hostClass\", void 0);\n__decorate([\n    HostBinding('attr.dir'),\n    __metadata(\"design:type\", String)\n], TextBoxComponent.prototype, \"direction\", void 0);\nTextBoxComponent = TextBoxComponent_1 = __decorate([\n    Component({\n        exportAs: 'kendoTextBox',\n        providers: [\n            LocalizationService,\n            { provide: L10N_PREFIX, useValue: 'kendo.textbox' },\n            {\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => TextBoxComponent_1),\n                multi: true\n            },\n            { provide: KendoInput, useExisting: forwardRef(() => TextBoxComponent_1) }\n        ],\n        selector: 'kendo-textbox',\n        template: `\n        <ng-container kendoTextBoxLocalizedMessages\n            i18n-clear=\"kendo.textbox.clear|The title for the **Clear** button in the TextBox.\"\n            clear=\"Clear\">\n        </ng-container>\n        <span class=\"k-input-prefix\">\n            <ng-template\n                *ngIf=\"prefixTemplate\"\n                [ngTemplateOutlet]=\"prefixTemplate?.templateRef\">\n            </ng-template>\n        </span>\n        <input\n            class=\"k-input\"\n            #input\n            [id]=\"focusableId\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [attr.tabindex]=\"disabled ? undefined : tabindex\"\n            [value]=\"value\"\n            [attr.placeholder]=\"placeholder\"\n            [attr.title]=\"title\"\n            [attr.maxlength]=\"maxlength\"\n            [kendoEventsOutsideAngular]=\"{\n                focus: handleInputFocus,\n                blur: handleInputBlur,\n                input: handleInput}\"/>\n        <span class=\"k-input-suffix\">\n            <span *ngIf=\"hasErrors\" [ngClass]=\"errorIconClasses\"></span>\n            <span *ngIf=\"isSuccessful\" [ngClass]=\"successIconClasses\"></span>\n            <span\n                role=\"button\"\n                class=\"k-clear-value\"\n                *ngIf=\"showClearButton\"\n                (click)=\"clearValue()\"\n                (mousedown)=\"$event.preventDefault()\"\n                [tabindex]=\"tabIndex\"\n                [attr.aria-label]=\"clearTitle()\"\n                [title]=\"clearTitle()\"\n                (keydown.enter)=\"clearValue($event)\"\n                (keydown.space)=\"clearValue($event)\"\n                >\n                <span [ngClass]=\"clearButtonClasses\"></span>\n            </span>\n            <ng-template\n                *ngIf=\"suffixTemplate\"\n                [ngTemplateOutlet]=\"suffixTemplate?.templateRef\">\n            </ng-template>\n        </span>\n    `\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService,\n        NgZone,\n        ChangeDetectorRef,\n        Renderer2,\n        Injector,\n        ElementRef])\n], TextBoxComponent);\n\n/**\n * @hidden\n */\nclass TextBoxMessages extends ComponentMessages {\n}\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextBoxMessages.prototype, \"clear\", void 0);\n\nvar TextBoxCustomMessagesComponent_1;\n/**\n * Custom component messages override default component messages.\n */\nlet TextBoxCustomMessagesComponent = TextBoxCustomMessagesComponent_1 = class TextBoxCustomMessagesComponent extends TextBoxMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n};\nTextBoxCustomMessagesComponent = TextBoxCustomMessagesComponent_1 = __decorate([\n    Component({\n        providers: [\n            {\n                provide: TextBoxMessages,\n                useExisting: forwardRef(() => TextBoxCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref\n            }\n        ],\n        selector: 'kendo-textbox-messages',\n        template: ``\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], TextBoxCustomMessagesComponent);\n\nvar LocalizedTextBoxMessagesDirective_1;\n/**\n * @hidden\n */\nlet LocalizedTextBoxMessagesDirective = LocalizedTextBoxMessagesDirective_1 = class LocalizedTextBoxMessagesDirective extends TextBoxMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n};\nLocalizedTextBoxMessagesDirective = LocalizedTextBoxMessagesDirective_1 = __decorate([\n    Directive({\n        providers: [\n            {\n                provide: TextBoxMessages,\n                useExisting: forwardRef(() => LocalizedTextBoxMessagesDirective_1) // tslint:disable-line:no-forward-ref\n            }\n        ],\n        selector: '[kendoTextBoxLocalizedMessages]'\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], LocalizedTextBoxMessagesDirective);\n\n/**\n * Specifies a separator in the content of components like the TextArea and the TextBox. ([see examples]({% slug adornments_textbox %}#toc-separator)).\n * @example\n * ```ts-no-run\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-textbox>\n *    <ng-template kendoTextBoxSuffixTemplate>\n *        <kendo-input-separator></kendo-input-separator>\n *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n *    </ng-template>\n *  </kendo-textbox>\n * `\n * })\n * class AppComponent {}\n * ```\n */\nlet InputSeparatorComponent = class InputSeparatorComponent {\n    /**\n     * Specifies a separator in the content of components like the TextArea and the TextBox. ([see examples]({% slug adornments_textbox %}#toc-separator)).\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-textbox>\n     *    <ng-template kendoTextBoxSuffixTemplate>\n     *        <kendo-input-separator></kendo-input-separator>\n     *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n     *    </ng-template>\n     *  </kendo-textbox>\n     * `\n     * })\n     * class AppComponent {}\n     * ```\n     */\n    constructor() {\n        this.hostClass = true;\n    }\n};\n__decorate([\n    HostBinding('class.k-input-separator'),\n    __metadata(\"design:type\", Boolean)\n], InputSeparatorComponent.prototype, \"hostClass\", void 0);\nInputSeparatorComponent = __decorate([\n    Component({\n        selector: 'kendo-input-separator, kendo-textbox-separator',\n        template: ``\n    })\n], InputSeparatorComponent);\n\n/**\n * @hidden\n */\nconst SHARED_DIRECTIVES = [\n    InputSeparatorComponent,\n    TextAreaDirective\n];\n/**\n * @hidden\n */\nlet SharedModule = class SharedModule {\n};\nSharedModule = __decorate([\n    NgModule({\n        declarations: [SHARED_DIRECTIVES],\n        exports: [SHARED_DIRECTIVES]\n    })\n], SharedModule);\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the TextBox directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the TextBox module\n * import { TextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, TextBoxModule], // import TextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet TextBoxModule = class TextBoxModule {\n};\nTextBoxModule = __decorate([\n    NgModule({\n        declarations: [\n            TextBoxDirective,\n            TextBoxContainerComponent,\n            TextBoxComponent,\n            TextBoxSuffixTemplateDirective,\n            TextBoxPrefixTemplateDirective,\n            TextBoxCustomMessagesComponent,\n            LocalizedTextBoxMessagesDirective\n        ],\n        exports: [\n            TextBoxDirective,\n            TextBoxContainerComponent,\n            TextBoxComponent,\n            TextBoxSuffixTemplateDirective,\n            TextBoxPrefixTemplateDirective,\n            EventsModule,\n            TextBoxCustomMessagesComponent,\n            LocalizedTextBoxMessagesDirective,\n            SHARED_DIRECTIVES\n        ],\n        imports: [CommonModule, EventsModule, SharedModule]\n    })\n], TextBoxModule);\n\n/**\n * @hidden\n */\nclass TextFieldsBase {\n    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {\n        this.localizationService = localizationService;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.renderer = renderer;\n        this.injector = injector;\n        this.hostElement = hostElement;\n        /**\n         * Sets the `title` attribute of the internal textarea input element of the component.\n         */\n        this.title = '';\n        /**\n         * Sets the disabled state of the TextArea component.\n         *\n         * @default false\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the TextArea component.\n         *\n         * @default false\n         */\n        this.readonly = false;\n        /**\n         * Provides a value for the TextArea component.\n         */\n        this.value = null;\n        /**\n         * Determines whether the whole value will be selected when the TextArea is clicked. Defaults to `false`.\n         *\n         * @default false\n         */\n        this.selectOnFocus = false;\n        /**\n         * Fires each time the user focuses the internal textarea element of the component.\n         * This event is useful when you need to distinguish between focusing the textarea element and focusing one of its adornments.\n         */\n        this.inputFocus = new EventEmitter();\n        /**\n         * Fires each time the internal textarea element gets blurred.\n         * This event is useful when adornments are used, in order to distinguish between blurring the textarea element and blurring the whole TextArea component.\n         */\n        this.inputBlur = new EventEmitter();\n        this.subscriptions = new Subscription();\n        this._isFocused = false;\n        this.focusChangedProgrammatically = false;\n        /**\n         * @hidden\n         */\n        this.handleInputBlur = () => {\n            this.changeDetector.markForCheck();\n            if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.ngTouched();\n                    this.inputBlur.emit();\n                });\n            }\n        };\n        this.ngChange = (_) => { };\n        this.ngTouched = () => { };\n    }\n    get disabledClass() {\n        return this.disabled;\n    }\n    ngOnDestroy() {\n        this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n        this.changeDetector.markForCheck();\n        this.disabled = isDisabled;\n    }\n}\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextFieldsBase.prototype, \"title\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], TextFieldsBase.prototype, \"disabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], TextFieldsBase.prototype, \"readonly\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextFieldsBase.prototype, \"value\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], TextFieldsBase.prototype, \"selectOnFocus\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextFieldsBase.prototype, \"placeholder\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TextFieldsBase.prototype, \"inputFocus\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TextFieldsBase.prototype, \"inputBlur\", void 0);\n__decorate([\n    ViewChild('input', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], TextFieldsBase.prototype, \"input\", void 0);\n__decorate([\n    HostBinding('class.k-state-disabled'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], TextFieldsBase.prototype, \"disabledClass\", null);\n__decorate([\n    HostBinding('attr.dir'),\n    __metadata(\"design:type\", String)\n], TextFieldsBase.prototype, \"direction\", void 0);\n\nvar TextAreaComponent_1;\nconst resizeClasses = {\n    'vertical': 'k-resize-vertical',\n    'horizontal': 'k-resize-horizontal',\n    'both': 'k-resize-both',\n    'none': 'k-resize-none',\n    'auto': 'k-resize-none'\n};\nconst FOCUSED$4 = 'k-state-focus';\n/**\n * Represents the [Kendo UI TextArea component for Angular]({% slug overview_textarea %}).\n */\nlet TextAreaComponent = TextAreaComponent_1 = class TextAreaComponent extends TextFieldsBase {\n    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {\n        super(localizationService, ngZone, changeDetector, renderer, injector, hostElement);\n        this.localizationService = localizationService;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.renderer = renderer;\n        this.injector = injector;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        this.hostClass = true;\n        /**\n         * Specifies the flow direction of the TextArea sections. This property is useful when adornments are used, in order to specify\n         * their position in relation to the textarea element.\n         *\n         * The possible values are:\n         * * `vertical`(Default) &mdash;TextArea sections are placed from top to bottom.\n         * * `horizontal`&mdash;TextArea sections are placed from left to right in `ltr`, and from right to left in `rtl` mode.\n         */\n        this.flow = 'vertical';\n        /**\n         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Configures the resize behavior of the TextArea.\n         *\n         * The possible values are:\n         * * `vertical`(Default)&mdash;The TextArea component can be resized only vertically.\n         * * `horizontal`&mdash;The TextArea component can be resized only horizontally.\n         * * `both`&mdash;The TextArea component can be resized in both (horizontal and vertical) directions.\n         * * `auto`&mdash;Specifies whether the TextArea component will adjust its height automatically, based on the content.\n         * * `none`&mdash;The TextArea cannot be resized.\n         *\n         */\n        this.resizable = 'vertical';\n        /**\n         * Fires each time the user focuses the TextArea component.\n         *\n         * > To wire the event programmatically, use the `onFocus` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-textarea (focus)=\"handleFocus()\"></kendo-textarea>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleFocus(): void {\n         *      console.log('Component is focused');\n         *   }\n         * }\n         * ```\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * Fires each time the TextArea component gets blurred.\n         *\n         * > To wire the event programmatically, use the `onBlur` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-textarea (blur)=\"handleBlur()\"></kendo-textarea>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleBlur(): void {\n         *      console.log('Component is blurred');\n         *   }\n         * }\n         * ```\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * Fires each time the value is changed or the component is blurred\n         * ([see example]({% slug overview_textarea %}#toc-events)).\n         * When the component value is changed programmatically or via its form control binding, the valueChange event is not emitted.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.handleInput = (ev) => {\n            let incomingValue = ev.target.value;\n            this.updateValue(incomingValue);\n            this.resize();\n        };\n        /**\n         * @hidden\n         */\n        this.handleInputFocus = () => {\n            if (!this.disabled) {\n                if (this.selectOnFocus && this.value) {\n                    this.ngZone.run(() => {\n                        setTimeout(() => { this.selectAll(); });\n                    });\n                }\n                if (hasObservers(this.onFocus)) {\n                    if (!this.isFocused) {\n                        this.ngZone.run(() => {\n                            this.onFocus.emit();\n                        });\n                    }\n                }\n                if (hasObservers(this.inputFocus)) {\n                    if (!this.focusChangedProgrammatically) {\n                        this.ngZone.run(() => {\n                            this.inputFocus.emit();\n                        });\n                    }\n                }\n                this.ngZone.run(() => {\n                    this.isFocused = true;\n                });\n            }\n        };\n        validatePackage(packageMetadata);\n        this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    get flowCol() {\n        return this.flow === 'vertical';\n    }\n    get flowRow() {\n        return this.flow === 'horizontal';\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    ngAfterViewInit() {\n        const hostElement = this.hostElement.nativeElement;\n        let cursorInsideWrapper = false;\n        let tabbing = false;\n        this.ngZone.runOutsideAngular(() => {\n            // focusIn and focusOut are relative to the host element\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n                if (!this.isFocused) {\n                    this.ngZone.run(() => {\n                        this.onFocus.emit();\n                        this.isFocused = true;\n                    });\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {\n                if (!this.isFocused) {\n                    return;\n                }\n                if (tabbing) {\n                    const closestTextbox = closest(args.relatedTarget, (element) => element === this.hostElement.nativeElement);\n                    if (!closestTextbox) {\n                        this.handleBlur();\n                    }\n                    tabbing = false;\n                }\n                else {\n                    if (!cursorInsideWrapper) {\n                        this.handleBlur();\n                    }\n                }\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n                cursorInsideWrapper = true;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n                cursorInsideWrapper = false;\n            }));\n            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {\n                if (args.keyCode === Keys.Tab) {\n                    tabbing = true;\n                }\n                else {\n                    tabbing = false;\n                }\n            }));\n        });\n    }\n    ngOnInit() {\n        this.control = this.injector.get(NgControl, null);\n        if (isDocumentAvailable() && this.resizable === 'auto') {\n            this.resizeSubscription = fromEvent(window, 'resize')\n                .pipe((debounceTime(50)))\n                .subscribe(() => this.resize());\n        }\n        if (this.hostElement) {\n            this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n        }\n        this.subscriptions = this.localizationService.changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n    }\n    ngOnChanges(changes) {\n        const hostElement = this.hostElement.nativeElement;\n        const element = this.input.nativeElement;\n        if (changes.resizable) {\n            if (this.resizable === 'auto') {\n                this.initialHeight = element.offsetHeight;\n            }\n            else {\n                this.renderer.setStyle(element, 'overflow-y', 'auto');\n                this.renderer.setStyle(element, 'resize', 'both');\n                element.style.height = `${this.initialHeight}px`;\n            }\n        }\n        if (changes.cols) {\n            if (isPresent(changes.cols.currentValue)) {\n                this.renderer.setStyle(hostElement, 'width', 'auto');\n            }\n            else {\n                this.renderer.removeStyle(hostElement, 'width');\n            }\n        }\n    }\n    ngAfterViewChecked() {\n        this.resize();\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.value = value;\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    updateValue(value) {\n        if (!areSame(this.value, value)) {\n            this.ngZone.run(() => {\n                this.value = value;\n                this.ngChange(value);\n                this.valueChange.emit(value);\n                this.changeDetector.markForCheck();\n            });\n        }\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        if (this.resizeSubscription) {\n            this.resizeSubscription.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    get resizableClass() {\n        return resizeClasses[this.resizable];\n    }\n    /**\n     * Focuses the TextArea component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"textarea.focus()\">Focus the textarea</button>\n     *  <kendo-textarea #textarea></kendo-textarea>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.input) {\n            return;\n        }\n        this.focusChangedProgrammatically = true;\n        this.isFocused = true;\n        this.input.nativeElement.focus();\n        this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the TextArea component.\n     */\n    blur() {\n        this.focusChangedProgrammatically = true;\n        const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');\n        if (isFocusedElement) {\n            isFocusedElement.blur();\n        }\n        this.isFocused = false;\n        this.focusChangedProgrammatically = false;\n    }\n    resize() {\n        if (this.resizable !== 'auto') {\n            return;\n        }\n        const element = this.input.nativeElement;\n        this.renderer.setStyle(element, 'overflow-y', 'hidden');\n        this.renderer.setStyle(element, 'height', `${this.initialHeight}px`);\n        const scrollHeight = element.scrollHeight;\n        if (scrollHeight > this.initialHeight) {\n            element.style.height = `${scrollHeight}px`;\n        }\n    }\n    get isFocused() {\n        return this._isFocused;\n    }\n    set isFocused(value) {\n        if (this._isFocused !== value && this.hostElement) {\n            const element = this.hostElement.nativeElement;\n            if (value && !this.disabled) {\n                this.renderer.addClass(element, FOCUSED$4);\n            }\n            else {\n                this.renderer.removeClass(element, FOCUSED$4);\n            }\n            this._isFocused = value;\n        }\n    }\n    handleBlur() {\n        this.ngZone.run(() => {\n            if (!this.focusChangedProgrammatically) {\n                this.onBlur.emit();\n            }\n            this.isFocused = false;\n        });\n    }\n    setSelection(start, end) {\n        if (this.isFocused) {\n            invokeElementMethod(this.input, 'setSelectionRange', start, end);\n        }\n    }\n    selectAll() {\n        if (this.value) {\n            this.setSelection(0, this.value.length);\n        }\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextAreaComponent.prototype, \"focusableId\", void 0);\n__decorate([\n    HostBinding('class.k-textarea'),\n    __metadata(\"design:type\", Boolean)\n], TextAreaComponent.prototype, \"hostClass\", void 0);\n__decorate([\n    HostBinding('class.k-flex-col'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], TextAreaComponent.prototype, \"flowCol\", null);\n__decorate([\n    HostBinding('class.k-flex-row'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], TextAreaComponent.prototype, \"flowRow\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextAreaComponent.prototype, \"flow\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], TextAreaComponent.prototype, \"rows\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], TextAreaComponent.prototype, \"cols\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], TextAreaComponent.prototype, \"maxlength\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], TextAreaComponent.prototype, \"tabindex\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], TextAreaComponent.prototype, \"tabIndex\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TextAreaComponent.prototype, \"resizable\", void 0);\n__decorate([\n    Output('focus'),\n    __metadata(\"design:type\", EventEmitter)\n], TextAreaComponent.prototype, \"onFocus\", void 0);\n__decorate([\n    Output('blur'),\n    __metadata(\"design:type\", EventEmitter)\n], TextAreaComponent.prototype, \"onBlur\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TextAreaComponent.prototype, \"valueChange\", void 0);\nTextAreaComponent = TextAreaComponent_1 = __decorate([\n    Component({\n        exportAs: 'kendoTextArea',\n        providers: [\n            LocalizationService,\n            { provide: L10N_PREFIX, useValue: 'kendo.textarea' },\n            {\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => TextAreaComponent_1),\n                multi: true\n            },\n            { provide: KendoInput, useExisting: forwardRef(() => TextAreaComponent_1) }\n        ],\n        selector: 'kendo-textarea',\n        template: `\n        <textarea\n            #input\n            [attr.aria-multiline]=\"true\"\n            [attr.aria-disabled]=\"disabled ? true : undefined\"\n            [attr.aria-readonly]=\"readonly ? true : undefined\"\n            class=\"k-input\"\n            [ngClass]=\"resizableClass\"\n            [id]=\"focusableId\"\n            [value]=\"value\"\n            [attr.placeholder]=\"placeholder\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [attr.rows]=\"rows\"\n            [attr.cols]=\"cols\"\n            [attr.tabindex]=\"tabIndex\"\n            [attr.title]=\"title\"\n            [attr.maxlength]=\"maxlength\"\n            [kendoEventsOutsideAngular]=\"{\n                focus: handleInputFocus,\n                blur: handleInputBlur,\n                input: handleInput}\">\n            </textarea>\n            <ng-content select=\"kendo-textarea-suffix\"></ng-content>\n    `\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService,\n        NgZone,\n        ChangeDetectorRef,\n        Renderer2,\n        Injector,\n        ElementRef])\n], TextAreaComponent);\n\n/**\n * Specifies the adornments in the suffix container ([see example]({% slug textarea_adornments %}).\n *  @example\n * ```ts-no-run\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-textarea>\n *    <kendo-textarea-suffix>\n *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n *    </kendo-textarea-suffix>\n *  </kendo-textarea>\n * `\n * })\n * class AppComponent {}\n * ```\n */\nlet TextAreaSuffixComponent = class TextAreaSuffixComponent {\n    /**\n     * Specifies the adornments in the suffix container ([see example]({% slug textarea_adornments %}).\n     *  @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-textarea>\n     *    <kendo-textarea-suffix>\n     *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n     *    </kendo-textarea-suffix>\n     *  </kendo-textarea>\n     * `\n     * })\n     * class AppComponent {}\n     * ```\n     */\n    constructor() {\n        this.hostClass = true;\n    }\n};\n__decorate([\n    HostBinding('class.k-textarea-suffix'),\n    __metadata(\"design:type\", Boolean)\n], TextAreaSuffixComponent.prototype, \"hostClass\", void 0);\nTextAreaSuffixComponent = __decorate([\n    Component({\n        exportAs: 'kendoTextAreaSuffix',\n        selector: 'kendo-textarea-suffix',\n        template: `<ng-content></ng-content>`\n    })\n], TextAreaSuffixComponent);\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the TextArea component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the TextArea module\n * import { TextAreaModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, TextAreaModule], // import TextArea module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet TextAreaModule = class TextAreaModule {\n};\nTextAreaModule = __decorate([\n    NgModule({\n        declarations: [\n            TextAreaComponent,\n            TextAreaSuffixComponent\n        ],\n        exports: [\n            TextAreaComponent,\n            EventsModule,\n            TextAreaSuffixComponent,\n            SHARED_DIRECTIVES\n        ],\n        imports: [CommonModule, EventsModule, SharedModule]\n    })\n], TextAreaModule);\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n    constructor() {\n        this.prevented = false;\n    }\n    /**\n     * Prevents the default action for a specified event.\n     * In this way, the source component suppresses the built-in behavior that follows the event.\n     */\n    preventDefault() {\n        this.prevented = true;\n    }\n    /**\n     * If the event is prevented by any of its subscribers, returns `true`.\n     *\n     * @returns - `true` if the default action was prevented. Otherwise, returns `false`.\n     */\n    isDefaultPrevented() {\n        return this.prevented;\n    }\n}\n\n/**\n * Fires each time the left side of the ColorPicker wrapper is clicked.\n * The event is triggered regardless of whether a ColorPicker icon is set or not.\n *\n * Provides information about the current active color and gives the option to prevent the opening of the popup.\n *\n * @example\n *\n * ```ts-no-run\n * _@Component({\n *   selector: 'my-app',\n *   template: `\n *       <kendo-colorpicker\n *           [icon]=\"'edit-tools'\"\n *           [value]=\"'#900'\"\n *           (activeColorClick)=\"handleActiveColorClick($event)\"\n *       >\n *       </kendo-colorpicker>\n *   `\n * })\n * class AppComponent {\n *     public handleActiveColorClick(event: ActiveColorClickEvent): void {\n *         event.preventOpen();\n *\n *         console.log('Open prevented:', event.isOpenPrevented());\n *         console.log('Current color:', event.color);\n *     }\n *  }\n * ```\n */\nclass ActiveColorClickEvent {\n    /**\n     * @hidden\n     * @param color Represents the current value of the ColorPicker.\n     */\n    constructor(color) {\n        this.color = color;\n        this.openPrevented = false;\n    }\n    /**\n     * Prevents the opening of the popup.\n     */\n    preventOpen() {\n        this.openPrevented = true;\n    }\n    /**\n     * Returns `true` if the popup opening is prevented by any of its subscribers.\n     *\n     * @returns - Returns `true` if the open action was prevented. Otherwise, returns `false`.\n     */\n    isOpenPrevented() {\n        return this.openPrevented;\n    }\n}\n\n/**\n * @hidden\n *\n * Returns the hex or rgba string representation of the color.\n */\nconst parseColor$1 = (value, format, safe = true) => {\n    const allowedFormats = ['hex', 'rgba', 'name'];\n    if (allowedFormats.indexOf(format) === -1) {\n        throw new Error(`Unsupported color output format '${format}'. The available options are 'hex', 'rgba' or 'name'.`);\n    }\n    if (!isPresent(value)) {\n        return;\n    }\n    if (format === 'name') {\n        return nameFormat(value, safe);\n    }\n    const parsedColor = parseColor(value.trim(), safe);\n    if (!isPresent(parsedColor)) {\n        return;\n    }\n    return format === 'hex' ? parsedColor.toCss() : parsedColor.toCssRgba();\n};\n/**\n * @hidden\n *\n * Returns an HSV object representation of the color string.\n */\nconst getHSV = (value, safe = true) => {\n    const parsed = parseColor(value, safe);\n    if (!isPresent(parsed)) {\n        return {};\n    }\n    return parsed.toHSV();\n};\n/**\n * @hidden\n *\n * Returns an RGBA object representation of the color string.\n */\nconst getRGBA = (value, safe = true) => {\n    const parsed = parseColor(value, safe);\n    if (!isPresent(parsed)) {\n        return {};\n    }\n    return parsed.toBytes();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\nconst getColorFromHSV = (hsva) => {\n    const hue = fitIntoBounds(hsva.h, 0, 359.9);\n    const saturation = fitIntoBounds(hsva.s, 0, 1);\n    const value = fitIntoBounds(hsva.v, 0, 1);\n    const alpha = fitIntoBounds(hsva.a, 0, 1);\n    return Color.fromHSV(hue, saturation, value, alpha).toCssRgba();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color based on the `hue`, assuming the `value`, `saturation` and `alpha` have value of `1`.\n */\nconst getColorFromHue = (hue) => {\n    return getColorFromHSV({ h: hue, s: 1, v: 1, a: 1 });\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\nconst getColorFromRGBA = (rgba) => {\n    const red = fitIntoBounds(rgba.r, 0, 255);\n    const green = fitIntoBounds(rgba.g, 0, 255);\n    const blue = fitIntoBounds(rgba.b, 0, 255);\n    const alpha = fitIntoBounds(rgba.a, 0, 1);\n    return Color.fromBytes(red, green, blue, alpha).toCssRgba();\n};\n/**\n *\n * @hidden\n */\nfunction nameFormat(value, safe) {\n    value = value.toLowerCase().trim();\n    if (isPresent(namedColors[value])) {\n        return value;\n    }\n    if (parseColor(value, safe)) {\n        value = parseColor(value, safe).toHex();\n    }\n    const key = Object.keys(namedColors).find(key => namedColors[key] === value);\n    if (!key && !safe) {\n        throw new Error(`The provided color ${value} is not supported for 'format=\"name\"' property.To display ${value} color, the component 'format' property shoud be set to 'hex' or 'rgba' `);\n    }\n    return key;\n}\n/**\n * @hidden\n *\n * Returns the RGB object representation of the color based on the background color.\n */\nconst getRGBFromRGBA = (foregroundColor, backgroundColor) => {\n    const r1 = fitIntoBounds(foregroundColor.r, 0, 255);\n    const g1 = fitIntoBounds(foregroundColor.g, 0, 255);\n    const b1 = fitIntoBounds(foregroundColor.b, 0, 255);\n    const a1 = fitIntoBounds(foregroundColor.a, 0, 1);\n    const r2 = fitIntoBounds(backgroundColor.r, 0, 255);\n    const g2 = fitIntoBounds(backgroundColor.g, 0, 255);\n    const b2 = fitIntoBounds(backgroundColor.b, 0, 255);\n    return {\n        r: Math.round(((1 - a1) * r2) + (a1 * r1)),\n        g: Math.round(((1 - a1) * g2) + (a1 * g1)),\n        b: Math.round(((1 - a1) * b2) + (a1 * b1))\n    };\n};\n/**\n * @hidden\n *\n * Returns the relative luminance.\n */\nconst getLuminance = (rgb) => {\n    let a = [rgb.r, rgb.g, rgb.b].map(function (v) {\n        v /= 255;\n        return v <= 0.03928\n            ? v / 12.92\n            : Math.pow((v + 0.055) / 1.055, 2.4);\n    });\n    return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;\n};\n/**\n * @hidden\n *\n * Returns the color contrast.\n */\nconst getContrast = (luminance1, luminance2) => {\n    const brightest = Math.max(luminance1, luminance2);\n    const darkest = Math.min(luminance1, luminance2);\n    return (brightest + 0.05)\n        / (darkest + 0.05);\n};\n/**\n * @hidden\n *\n * Returns the color contrast from two RGBA colors.\n */\nconst getContrastFromTwoRGBAs = (a, b) => {\n    return getContrast(getLuminance(getRGBFromRGBA(a, b)), getLuminance(getRGBFromRGBA(b, { r: 0, g: 0, b: 0, a: 1 })));\n};\n\n// tslint:disable:max-line-length\n/**\n * @hidden\n */\nconst PALETTEPRESETS = {\n    basic: {\n        colors: '000000,7f7f7f,880015,ed1c24,ff7f27,fff200,22b14c,00a2e8,3f48cc,a349a4,ffffff,c3c3c3,b97a57,ffaec9,ffc90e,efe4b0,b5e61d,99d9ea,7092be,c8bfe7',\n        columns: 10\n    },\n    office: {\n        colors: 'ffffff, 000000, e6e6e6, 435569, 4371c4, ed7e32, a5a4a5, febf04, 5a9bd5, 71ae48, f2f2f3, 7f7f7f, d1cece, d5dde3, dae1f4, fce5d4, deeded, fff2cc, deeaf6, e1efd9, d7d8d8, 585959, aeabab, adbaca, b4c5e7, f6caac, dbdbdb, ffe498, bcd6ee, c5e0b2, bfbfc0, 3f3f3f, 767070, 8595b1, 8fabdb, f5b183, c9c8c9, fed965, 9bc4e5, a8d08d, a5a5a6, 262625, 393939, 334050, 2e5496, c45a11, 7b7b7a, bf9000, 2f75b5, 548235, 7f7f7f, 0b0c0c, 161616, 222a34, 203764, 843d0b, 525252, 7f6000, 1d4d79, 375623',\n        columns: 10\n    },\n    apex: {\n        colors: 'ffffff, 000000, c9c2d1, 69676d, ceb966, 9cb084, 6bb1c9, 6585cf, 7e6bc9, a379bb, f2f2f2, 7f7f7f, f4f2f5, e0e0e2, f5f1e0, ebefe6, e1eff4, e0e6f5, e5e1f4, ece4f1, d8d8d8, 595959, e9e6ec, c2c1c5, ebe3c1, d7dfcd, c3dfe9, c1ceeb, cbc3e9, dac9e3, bfbfbf, 3f3f3f, dedae3, a4a3a8, e1d5a3, c3cfb5, a6d0de, a2b5e2, b1a6de, c7aed6, a5a5a5, 262626, 9688a5, 4e4d51, ae9638, 758c5a, 3d8da9, 365bb0, 533da9, 7d4d99, 7f7f7f, 0c0c0c, 635672, 343336, 746425, 4e5d3c, 295e70, 243c75, 372970, 533366',\n        columns: 10\n    },\n    austin: {\n        colors: 'ffffff, 000000, caf278, 3e3d2d, 94c600, 71685a, ff6700, 909465, 956b43, fea022, f2f2f2, 7f7f7f, f4fce4, dddcd0, efffc0, e3e1dc, ffe0cb, e8e9df, ece1d6, feecd2, d8d8d8, 595959, e9f9c9, bbb9a1, dfff82, c8c3ba, ffc299, d2d4c0, dac3ad, fed9a6, bfbfbf, 3f3f3f, dff7ae, ada598, cfff43, ada598, ffa365, bcbfa1, c8a585, fec67a, a5a5a5, 262626, a9ea25, 2e2d21, 6f9400, 544e43, bf4d00, 6c6f4b, 6f5032, d77b00, 7f7f7f, 0c0c0c, 74a50f, 1f1e16, 4a6300, 38342d, 7f3300, 484a32, 4a3521, 8f5200',\n        columns: 10\n    },\n    clarity: {\n        colors: 'ffffff, 292934, f3f2dc, d2533c, 93a299, ad8f67, 726056, 4c5a6a, 808da0, 79463d, f2f2f2, e7e7ec, e7e5b9, f6dcd8, e9ecea, eee8e0, e4dedb, d8dde3, e5e8ec, e9d6d3, d8d8d8, c4c4d1, d5d185, edbab1, d3d9d6, ded2c2, c9beb8, b2bcc8, ccd1d9, d3aea7, bfbfbf, 8a8aa3, aca73b, e4978a, bec7c1, cdbba3, af9e94, 8c9bac, b2bac6, bd857c, a5a5a5, 56566e, 56531d, a43925, 6b7c72, 866b48, 554840, 39434f, 5c697b, 5a342d, 7f7f7f, 3b3b4b, 22210b, 6d2619, 47534c, 594730, 39302b, 262d35, 3d4652, 3c231e',\n        columns: 10\n    },\n    slipstream: {\n        colors: 'ffffff, 000000, b4dcfa, 212745, 4e67c8, 5eccf3, a7ea52, 5dceaf, ff8021, f14124, f2f2f2, 7f7f7f, 8bc9f7, c7cce4, dbe0f4, def4fc, edfadc, def5ef, ffe5d2, fcd9d3, d8d8d8, 595959, 4facf3, 909aca, b8c2e9, beeafa, dbf6b9, beebdf, ffcca6, f9b3a7, bfbfbf, 3f3f3f, 0d78c9, 5967af, 94a3de, 9ee0f7, caf297, 9de1cf, ffb279, f68d7b, a5a5a5, 262626, 063c64, 181d33, 31479f, 11b2eb, 81d319, 34ac8b, d85c00, c3260c, 7f7f7f, 0c0c0c, 021828, 101322, 202f6a, 0b769c, 568c11, 22725c, 903d00, 821908',\n        columns: 10\n    },\n    metro: {\n        colors: 'ffffff, 000000, d6ecff, 4e5b6f, 7fd13b, ea157a, feb80a, 00addc, 738ac8, 1ab39f, f2f2f2, 7f7f7f, a7d6ff, d9dde4, e5f5d7, fad0e4, fef0cd, c5f2ff, e2e7f4, c9f7f1, d8d8d8, 595959, 60b5ff, b3bcca, cbecb0, f6a1c9, fee29c, 8be6ff, c7d0e9, 94efe3, bfbfbf, 3f3f3f, 007dea, 8d9baf, b2e389, f272af, fed46b, 51d9ff, aab8de, 5fe7d5, a5a5a5, 262626, 003e75, 3a4453, 5ea226, af0f5b, c58c00, 0081a5, 425ea9, 138677, 7f7f7f, 0c0c0c, 00192e, 272d37, 3f6c19, 750a3d, 835d00, 00566e, 2c3f71, 0c594f',\n        columns: 10\n    },\n    flow: {\n        colors: 'ffffff, 000000, dbf5f9, 04617b, 0f6fc6, 009dd9, 0bd0d9, 10cf9b, 7cca62, a5c249, f2f2f2, 7f7f7f, b2e9f2, b4ecfc, c7e2fa, c4eeff, c9fafc, c9faed, e4f4df, edf2da, d8d8d8, 595959, 76d9e8, 6adafa, 90c6f6, 89deff, 93f5f9, 94f6db, cae9c0, dbe6b6, bfbfbf, 3f3f3f, 21b2c8, 20c8f7, 59a9f2, 4fceff, 5df0f6, 5ff2ca, b0dfa0, c9da91, a5a5a5, 262626, 105964, 02485c, 0b5394, 0075a2, 089ca2, 0b9b74, 54a838, 7e9532, 7f7f7f, 0c0c0c, 062328, 01303d, 073763, 004e6c, 05686c, 07674d, 387025, 546321',\n        columns: 10\n    },\n    hardcover: {\n        colors: 'ffffff, 000000, ece9c6, 895d1d, 873624, d6862d, d0be40, 877f6c, 972109, aeb795, f2f2f2, 7f7f7f, e1dca5, f2e0c6, f0d0c9, f6e6d5, f5f2d8, e7e5e1, fbc7bc, eef0e9, d8d8d8, 595959, d0c974, e6c28d, e2a293, eeceaa, ece5b2, cfccc3, f78f7a, dee2d4, bfbfbf, 3f3f3f, a29a36, daa454, d4735e, e6b681, e2d88c, b7b2a5, f35838, ced3bf, a5a5a5, 262626, 514d1b, 664515, 65281a, a2641f, a39428, 655f50, 711806, 879464, 7f7f7f, 0c0c0c, 201e0a, 442e0e, 431b11, 6c4315, 6d621a, 433f35, 4b1004, 5a6243',\n        columns: 10\n    },\n    trek: {\n        colors: 'ffffff, 000000, fbeec9, 4e3b30, f0a22e, a5644e, b58b80, c3986d, a19574, c17529, f2f2f2, 7f7f7f, f7e09e, e1d6cf, fcecd5, eddfda, f0e7e5, f3eae1, ece9e3, f5e3d1, d8d8d8, 595959, f3cc5f, c4ad9f, f9d9ab, dcc0b6, e1d0cc, e7d5c4, d9d4c7, ebc7a3, bfbfbf, 3f3f3f, d29f0f, a78470, f6c781, cba092, d2b9b2, dbc1a7, c6bfab, e1ac76, a5a5a5, 262626, 694f07, 3a2c24, c87d0e, 7b4b3a, 926255, a17242, 7b7153, 90571e, 7f7f7f, 0c0c0c, 2a1f03, 271d18, 855309, 523226, 614138, 6b4c2c, 524b37, 603a14',\n        columns: 10\n    },\n    verve: {\n        colors: 'ffffff, 000000, d2d2d2, 666666, ff388c, e40059, 9c007f, 68007f, 005bd3, 00349e, f2f2f2, 7f7f7f, bdbdbd, e0e0e0, ffd7e8, ffc6dc, ffb8f1, f1b2ff, c3dcff, b8cfff, d8d8d8, 595959, 9d9d9d, c1c1c1, ffafd1, ff8eba, ff71e4, e365ff, 87baff, 72a0ff, bfbfbf, 3f3f3f, 696969, a3a3a3, ff87ba, ff5597, ff2ad7, d519ff, 4b98ff, 2b71ff, a5a5a5, 262626, 343434, 4c4c4c, e90062, ab0042, 75005f, 4e005f, 00449e, 002676, 7f7f7f, 0c0c0c, 151515, 333333, 9b0041, 72002c, 4e003f, 34003f, 002d69, 00194f',\n        columns: 10\n    },\n    monochrome: {\n        colors: '000000, 1a1a1a, 333333, 4d4d4d, 666666, 808080, 999999, b3b3b3, cccccc, e6e6e6, f2f2f2, ffffff',\n        columns: 12\n    },\n    accessible: {\n        colors: 'black, grey, darkred, red, darkorange, gold, green, blue, darkblue, purple, white, darkgrey, saddlebrown, pink, orange, yellow, lightgreen, lightskyblue, lightblue, mediumpurple',\n        columns: 10\n    }\n};\n\n/**\n * @hidden\n */\nlet ColorPickerLocalizationService = class ColorPickerLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, _rtl) {\n        super(prefix, messageService, _rtl);\n    }\n};\nColorPickerLocalizationService = __decorate([\n    __param(0, Inject(L10N_PREFIX)),\n    __param(1, Optional()),\n    __param(2, Optional()), __param(2, Inject(RTL)),\n    __metadata(\"design:paramtypes\", [String, MessageService, Boolean])\n], ColorPickerLocalizationService);\n\n/**\n * @hidden\n */\nlet ColorGradientLocalizationService = class ColorGradientLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, _rtl, colorPickerLocalization) {\n        super(prefix, messageService, _rtl);\n        this.colorPickerLocalization = colorPickerLocalization;\n    }\n    get(shortKey) {\n        if (this.colorPickerLocalization) {\n            return this.colorPickerLocalization.get(shortKey);\n        }\n        return super.get(shortKey);\n    }\n};\nColorGradientLocalizationService = __decorate([\n    __param(0, Inject(L10N_PREFIX)),\n    __param(1, Optional()),\n    __param(2, Optional()), __param(2, Inject(RTL)),\n    __param(3, Optional()), __param(3, Inject(ColorPickerLocalizationService)),\n    __metadata(\"design:paramtypes\", [String, MessageService, Boolean, ColorPickerLocalizationService])\n], ColorGradientLocalizationService);\n\n/**\n * @hidden\n */\nlet ColorInputComponent = class ColorInputComponent {\n    constructor(localization, host, renderer) {\n        this.localization = localization;\n        this.host = host;\n        this.renderer = renderer;\n        /**\n         * Sets whether the alpha slider will be shown.\n         */\n        this.opacity = true;\n        /**\n         * Sets the disabled state of the ColorInput.\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the ColorInput.\n         */\n        this.readonly = false;\n        /**\n         * Emits a parsed rgba string color.\n         */\n        this.valueChange = new EventEmitter();\n        this.colorInputClass = true;\n        /**\n         * The rgba inputs values.\n         */\n        this.rgba = {};\n        this.subscriptions = new Subscription();\n    }\n    /**\n     * Indicates whether any of the inputs are focused.\n     */\n    get isFocused() {\n        if (!(isDocumentAvailable() && isPresent(this.host))) {\n            return false;\n        }\n        const activeElement = document.activeElement;\n        return this.host.nativeElement.contains(activeElement);\n    }\n    /**\n     * Indicates whether any of the rgba inputs have value.\n     */\n    get rgbaInputValid() {\n        return Object.keys(this.rgba).every(key => isPresent(this.rgba[key]));\n    }\n    ngAfterViewInit() {\n        this.initDomEvents();\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n    }\n    ngOnChanges(changes) {\n        if (isPresent(changes.value) && !this.isFocused) {\n            this.hex = parseColor$1(this.value, 'hex');\n            this.rgba = getRGBA(this.value);\n            this.rgba.a = parseColor$1(this.value, 'rgba') ? this.rgba.a : 1;\n        }\n    }\n    handleRgbaValueChange() {\n        const color = getColorFromRGBA(this.rgba);\n        if (!this.rgbaInputValid || color === this.value) {\n            return;\n        }\n        this.value = color;\n        this.rgba = getRGBA(this.value);\n        this.hex = parseColor$1(color, 'hex');\n        this.valueChange.emit(color);\n    }\n    handleHexValueChange(hex) {\n        this.hex = hex;\n        const color = parseColor$1(hex, 'rgba');\n        if (!isPresent(color) || color === this.value) {\n            return;\n        }\n        this.value = color;\n        this.rgba = getRGBA(color);\n        this.valueChange.emit(color);\n    }\n    handleRgbaInputBlur() {\n        if (!this.rgbaInputValid) {\n            this.rgba = getRGBA(this.value);\n        }\n    }\n    handleHexInputBlur() {\n        this.hex = parseColor$1(this.value, 'hex');\n    }\n    textFor(key) {\n        return this.localization.get(key);\n    }\n    toggleFormatView() {\n        this.formatView = this.formatView === 'hex' ? 'rgba' : 'hex';\n    }\n    initDomEvents() {\n        if (!this.host) {\n            return;\n        }\n        this.subscriptions.add(this.renderer.listen(this.toggleFormatButton.nativeElement, 'click', () => this.toggleFormatView()));\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorInputComponent.prototype, \"formatView\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorInputComponent.prototype, \"value\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], ColorInputComponent.prototype, \"opacity\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], ColorInputComponent.prototype, \"disabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], ColorInputComponent.prototype, \"readonly\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], ColorInputComponent.prototype, \"valueChange\", void 0);\n__decorate([\n    HostBinding('class.k-colorgradient-inputs'),\n    HostBinding('class.k-hstack'),\n    __metadata(\"design:type\", Boolean)\n], ColorInputComponent.prototype, \"colorInputClass\", void 0);\n__decorate([\n    ViewChild('opacityInput', { read: ElementRef, static: false }),\n    __metadata(\"design:type\", ElementRef)\n], ColorInputComponent.prototype, \"opacityInput\", void 0);\n__decorate([\n    ViewChild('toggleFormatButton', { static: false }),\n    __metadata(\"design:type\", ElementRef)\n], ColorInputComponent.prototype, \"toggleFormatButton\", void 0);\nColorInputComponent = __decorate([\n    Component({\n        selector: 'kendo-colorinput',\n        template: `\n        <div class=\"k-vstack\">\n            <button class=\"k-colorgradient-toggle-mode k-button k-icon-button k-flat\" #toggleFormatButton>\n                <span class=\"k-button-icon k-icon k-i-arrows-kpi\"></span>\n            </button>\n        </div>\n        <input *ngIf=\"formatView === 'hex'\"\n            #hexInput\n            class=\"k-textbox k-hex-value\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [value]=\"hex || ''\"\n            [placeholder]=\"textFor('hexInputPlaceholder')\"\n            (blur)=\"handleHexInputBlur()\"\n            (input)=\"handleHexValueChange(hexInput.value)\"\n        />\n        <ng-container *ngIf=\"formatView === 'rgba'\">\n            <div class=\"k-vstack\">\n                <kendo-numerictextbox\n                    #red\n                    [disabled]=\"disabled\"\n                    [readonly]=\"readonly\"\n                    [min]=\"0\"\n                    [max]=\"255\"\n                    [placeholder]=\"textFor('redInputPlaceholder')\"\n                    [(value)]=\"rgba.r\"\n                    [autoCorrect]=\"true\"\n                    [spinners]=\"false\"\n                    [format]=\"'n'\"\n                    [decimals]=\"0\"\n                    (blur)=\"handleRgbaInputBlur()\"\n                    (valueChange)=\"handleRgbaValueChange()\">\n                </kendo-numerictextbox>\n                <label [for]=\"red.focusableId\" class=\"k-colorgradient-input-label\">R</label>\n            </div>\n            <div class=\"k-vstack\">\n                <kendo-numerictextbox\n                    #green\n                    [disabled]=\"disabled\"\n                    [readonly]=\"readonly\"\n                    [min]=\"0\"\n                    [max]=\"255\"\n                    [placeholder]=\"textFor('greenInputPlaceholder')\"\n                    [(value)]=\"rgba.g\"\n                    [autoCorrect]=\"true\"\n                    [spinners]=\"false\"\n                    [format]=\"'n'\"\n                    [decimals]=\"0\"\n                    (blur)=\"handleRgbaInputBlur()\"\n                    (valueChange)=\"handleRgbaValueChange()\">\n                </kendo-numerictextbox>\n                <label [for]=\"green.focusableId\" class=\"k-colorgradient-input-label\">G</label>\n            </div>\n            <div class=\"k-vstack\">\n                <kendo-numerictextbox\n                    #blue\n                    [disabled]=\"disabled\"\n                    [readonly]=\"readonly\"\n                    [min]=\"0\"\n                    [max]=\"255\"\n                    [placeholder]=\"textFor('blueInputPlaceholder')\"\n                    [(value)]=\"rgba.b\"\n                    [autoCorrect]=\"true\"\n                    [spinners]=\"false\"\n                    [format]=\"'n'\"\n                    [decimals]=\"0\"\n                    (blur)=\"handleRgbaInputBlur()\"\n                    (valueChange)=\"handleRgbaValueChange()\">\n                </kendo-numerictextbox>\n                <label [for]=\"blue.focusableId\" class=\"k-colorgradient-input-label\">B</label>\n            </div>\n            <div class=\"k-vstack\" *ngIf=\"opacity\">\n                <kendo-numerictextbox  #opacityInput\n                    #alpha\n                    [disabled]=\"disabled\"\n                    [readonly]=\"readonly\"\n                    [min]=\"0\"\n                    [max]=\"1\"\n                    [placeholder]=\"textFor('alphaInputPlaceholder')\"\n                    [(value)]=\"rgba.a\"\n                    [autoCorrect]=\"true\"\n                    [spinners]=\"false\"\n                    [step]=\"0.01\"\n                    [format]=\"'n2'\"\n                    [decimals]=\"2\"\n                    (blur)=\"handleRgbaInputBlur()\"\n                    (valueChange)=\"handleRgbaValueChange()\">\n                </kendo-numerictextbox>\n                <label [for]=\"alpha.focusableId\" class=\"k-colorgradient-input-label\">A</label>\n            </div>\n        </ng-container>\n    `\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService,\n        ElementRef,\n        Renderer2])\n], ColorInputComponent);\n\n/**\n * @hidden\n */\nconst DEFAULT_OUTPUT_FORMAT = 'rgba';\n/**\n * @hidden\n */\nconst DEFAULT_GRADIENT_BACKGROUND_COLOR = 'rgba(255, 0, 0, 1)';\n/**\n * @hidden\n */\nconst DRAGHANDLE_MOVE_SPEED = 5;\n/**\n * @hidden\n */\nconst AAA_RATIO = 7.0;\n/**\n * @hidden\n */\nconst AA_RATIO = 4.5;\n\nvar ColorGradientComponent_1;\nlet serial = 0;\n/**\n * The ColorGradient component enables smooth color transitions and provides options for selecting specific colors over the drag handle.\n * The ColorGradient is independently used by `kendo-colorpicker` and can be directly added to the page.\n */\nlet ColorGradientComponent = ColorGradientComponent_1 = class ColorGradientComponent {\n    constructor(host, ngZone, renderer, cdr, localizationService) {\n        this.host = host;\n        this.ngZone = ngZone;\n        this.renderer = renderer;\n        this.cdr = cdr;\n        this.localizationService = localizationService;\n        /**\n         * @hidden\n         */\n        this.hostClasses = true;\n        /**\n         * @hidden\n         */\n        this.id = `k-colorgradient-${serial++}`;\n        /**\n         * Defines whether the alpha slider will be displayed.\n         */\n        this.opacity = true;\n        /**\n         * Sets the disabled state of the ColorGradient.\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the ColorGradient.\n         */\n        this.readonly = false;\n        /**\n         * Specifies whether the ColorGradient should display a 'Clear color' button.\n         */\n        this.clearButton = false;\n        /**\n         * Determines the delay time (in milliseconds) before the value is changed on handle drag. A value of 0 indicates no delay.\n         *\n         * @default 0\n         */\n        this.delay = 0;\n        /**\n         * Fires each time the user selects a new color.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.backgroundColor = DEFAULT_GRADIENT_BACKGROUND_COLOR;\n        /**\n         * @hidden\n         *\n         * Represents the currently selected `hue`, `saturation`, `value`, and `alpha` values.\n         * The values are initially set in `ngOnInit` or in `ngOnChanges` and are\n         * updated on moving the drag handle or the sliders.\n         */\n        this.hsva = {};\n        /**\n         * Specifies the output format of the ColorGradientComponent.\n         * The input value may be in a different format. However, it will be parsed into the output `format`\n         * after the component processes it.\n         *\n         * The supported values are:\n         * * (Default) `rgba`\n         * * `hex`\n         */\n        this.format = DEFAULT_OUTPUT_FORMAT;\n        this._tabindex = 0;\n        this.listeners = [];\n        this.updateValues = new Subject();\n        this.notifyNgChanged = () => { };\n        this.notifyNgTouched = () => { };\n        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n    }\n    /**\n     * @hidden\n     */\n    get readonlyAttribute() {\n        return this.readonly;\n    }\n    /**\n     * @hidden\n     */\n    get disabledClass() {\n        return this.disabled;\n    }\n    /**\n     * @hidden\n     */\n    get hostTabindex() {\n        return this.tabindex;\n    }\n    /**\n     * @hidden\n     */\n    get gradientId() {\n        return this.id;\n    }\n    /**\n     * Specifies the value of the initially selected color.\n     */\n    set value(value) {\n        this._value = parseColor$1(value, this.format);\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n    set tabindex(value) {\n        const tabindex = Number(value);\n        const defaultValue = 0;\n        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n    get tabindex() {\n        return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * Indicates whether the ColorGradient or any of its content is focused.\n     */\n    get isFocused() {\n        if (!(isDocumentAvailable() && isPresent(this.host))) {\n            return false;\n        }\n        return this.host.nativeElement === document.activeElement || this.host.nativeElement.contains(document.activeElement);\n    }\n    /**\n     * @hidden\n     */\n    get alphaSliderValue() {\n        // setting the initial value to undefined to force the slider to recalculate the height of the slider track on the next cdr run\n        if (!(isPresent(this.hsva) && isPresent(this.hsva.a))) {\n            return;\n        }\n        return this.hsva.a * 100;\n    }\n    get gradientRect() {\n        return this.gradientWrapper.nativeElement.getBoundingClientRect();\n    }\n    /**\n     * @hidden\n     */\n    get contrastToolVisible() {\n        return typeof this.contrastTool === 'string' && this.contrastTool !== '';\n    }\n    ngAfterViewInit() {\n        this.updateUI();\n        this.cdr.detectChanges();\n        this.addEventListeners();\n        this.subscribeChanges();\n    }\n    ngOnChanges(changes) {\n        if (isChanged('value', changes) && !this.isFocused) {\n            this.updateUI();\n        }\n        if (isChanged('delay', changes)) {\n            this.unsubscribeChanges();\n            this.subscribeChanges();\n        }\n    }\n    ngOnDestroy() {\n        this.listeners.forEach(removeListener => removeListener());\n        if (this.dynamicRTLSubscription) {\n            this.dynamicRTLSubscription.unsubscribe();\n        }\n        this.unsubscribeChanges();\n    }\n    /**\n     * Focuses the component.\n     */\n    focus() {\n        if (this.disabled) {\n            return;\n        }\n        this.host.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n    reset() {\n        this.handleValueChange(undefined);\n        this.updateUI();\n        this.host.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n    handleDragPress(args) {\n        if (this.disabled || this.readonly || !isPresent(args.originalEvent)) {\n            return;\n        }\n        this.focus();\n        args.originalEvent.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    onHandleDrag(args) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');\n        this.changePosition(args);\n    }\n    /**\n     * @hidden\n     */\n    onHandleRelease() {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');\n        this.handleValueChange(getColorFromHSV(this.hsva));\n    }\n    /**\n     * @hidden\n     */\n    onKeyboardAction(args) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        if (args.key && args.key.indexOf('Arrow') !== -1) {\n            args.preventDefault();\n            const dragHandleElement = this.gradientDragHandle.nativeElement;\n            this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');\n            let keyboardMoveX = 0;\n            let keyboardMoveY = 0;\n            switch (args.key) {\n                case 'ArrowRight':\n                    keyboardMoveX = DRAGHANDLE_MOVE_SPEED;\n                    break;\n                case 'ArrowLeft':\n                    keyboardMoveX = -DRAGHANDLE_MOVE_SPEED;\n                    break;\n                case 'ArrowUp':\n                    keyboardMoveY = -DRAGHANDLE_MOVE_SPEED;\n                    break;\n                case 'ArrowDown':\n                    keyboardMoveY = DRAGHANDLE_MOVE_SPEED;\n                    break;\n                default: break;\n            }\n            const newY = parseInt(dragHandleElement.style.top, 10) + keyboardMoveY;\n            const newX = parseInt(dragHandleElement.style.left, 10) + keyboardMoveX;\n            this.renderer.setStyle(dragHandleElement, 'top', `${newY}px`);\n            this.renderer.setStyle(dragHandleElement, 'left', `${newX}px`);\n            this.ngZone.run(() => this.moveDragHandle(newX, newY));\n        }\n    }\n    /**\n     * @hidden\n     */\n    changePosition(position) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.gradientDragHandle.nativeElement.focus();\n        const newX = position.clientX - this.gradientRect.left;\n        const newY = position.clientY - this.gradientRect.top;\n        this.ngZone.run(() => this.moveDragHandle(newX, newY));\n    }\n    /**\n     * @hidden\n     */\n    handleHueSliderChange(hue) {\n        this.handleValueChange(getColorFromHSV(this.hsva));\n        this.backgroundColor = getColorFromHue(hue);\n        this.setAlphaSliderBackground(this.backgroundColor);\n    }\n    /**\n     * @hidden\n     */\n    handleAlphaSliderChange(alpha) {\n        this.hsva.a = alpha / 100;\n        this.handleValueChange(getColorFromHSV(this.hsva));\n    }\n    /**\n     * @hidden\n     */\n    handleInputsValueChange(color) {\n        const parsed = parseColor$1(color, this.format);\n        if (this.value !== parsed) {\n            this.handleValueChange(parsed);\n            this.updateUI();\n        }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.value = value;\n        if (isPresent(this.gradientWrapper)) {\n            this.updateUI();\n        }\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.cdr.markForCheck();\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    get colorGradientHandleTitle() {\n        return this.localizationService.get('colorGradientHandle');\n    }\n    /**\n     * @hidden\n     */\n    get colorGradientHandleAriaLabel() {\n        const parsed = parseColor$1(this.value, this.format);\n        return `${this.value ? parsed : this.localizationService.get('colorGradientHandle')}`;\n    }\n    /**\n     * @hidden\n     */\n    get hueSliderTitle() {\n        return this.localizationService.get('hueSliderHandle');\n    }\n    /**\n     * @hidden\n     */\n    get opacitySliderTitle() {\n        return this.localizationService.get('opacitySliderHandle');\n    }\n    /**\n     * @hidden\n     */\n    get clearButtonTitle() {\n        return this.localizationService.get('clearButton');\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    moveDragHandle(positionX, positionY) {\n        const top = fitIntoBounds(positionY, 0, this.gradientRect.height);\n        const left = fitIntoBounds(positionX, 0, this.gradientRect.width);\n        this.setDragHandleElementPosition(top, left);\n        this.hsva.s = left / this.gradientRect.width;\n        this.hsva.v = 1 - top / this.gradientRect.height;\n        this.updateValues.next(getColorFromHSV(this.hsva));\n        this.setAlphaSliderBackground(getColorFromHSV(Object.assign({}, this.hsva, { a: 1 })));\n    }\n    updateUI() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.hsva = this.value ? getHSV(this.value) : { h: 0, s: 0, v: 1, a: 1 };\n        const top = (1 - this.hsva.v) * this.gradientRect.height;\n        const left = this.hsva.s * this.gradientRect.width;\n        this.setDragHandleElementPosition(top, left);\n        this.backgroundColor = getColorFromHue(this.hsva.h);\n        this.setAlphaSliderBackground(this.backgroundColor);\n        this.setHostElementAriaLabel();\n    }\n    handleValueChange(color) {\n        if (this.value === color) {\n            return;\n        }\n        this.value = color;\n        this.valueChange.emit(color);\n        this.notifyNgChanged(color);\n        this.setHostElementAriaLabel();\n    }\n    setDragHandleElementPosition(top, left) {\n        const dragHandle = this.gradientDragHandle.nativeElement;\n        this.renderer.setStyle(dragHandle, 'top', `${top}px`);\n        this.renderer.setStyle(dragHandle, 'left', `${left}px`);\n    }\n    setAlphaSliderBackground(backgroundColor) {\n        if (!isPresent(this.alphaSlider)) {\n            return;\n        }\n        const sliderTrack = this.alphaSlider.track.nativeElement;\n        this.renderer.setStyle(sliderTrack, 'background', `linear-gradient(to top, transparent, ${backgroundColor})`);\n    }\n    setHostElementAriaLabel() {\n        const parsed = parseColor$1(this.value, this.format);\n        this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorGradientNoColor')}`);\n    }\n    addEventListeners() {\n        this.ngZone.runOutsideAngular(() => {\n            const focusOutListener = this.renderer.listen(this.host.nativeElement, 'focusout', (event) => {\n                if (!containsFocus(this.host.nativeElement, event.relatedTarget) && isUntouched(this.host)) {\n                    this.ngZone.run(() => this.notifyNgTouched());\n                }\n            });\n            const keydownListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keydown', (event) => {\n                this.onKeyboardAction(event);\n            });\n            const keyupListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keyup', () => {\n                this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');\n                if (!this.readonly && !this.disabled) {\n                    this.ngZone.run(() => this.handleValueChange(getColorFromHSV(this.hsva)));\n                }\n            });\n            const dragHandleFocusInListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusin', () => {\n                this.renderer.addClass(this.gradientDragHandle.nativeElement, 'k-state-focus');\n            });\n            const dragHandleFocusOutListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusout', () => {\n                this.renderer.removeClass(this.gradientDragHandle.nativeElement, 'k-state-focus');\n            });\n            this.listeners.push(focusOutListener, keydownListener, keyupListener, dragHandleFocusInListener, dragHandleFocusOutListener);\n        });\n    }\n    subscribeChanges() {\n        this.changeRequestsSubscription = this.updateValues.pipe(throttleTime(this.delay)).subscribe(value => {\n            this.handleValueChange(value);\n        });\n    }\n    unsubscribeChanges() {\n        if (this.changeRequestsSubscription) {\n            this.changeRequestsSubscription.unsubscribe();\n        }\n    }\n};\n__decorate([\n    HostBinding('class.k-colorgradient'),\n    __metadata(\"design:type\", Boolean)\n], ColorGradientComponent.prototype, \"hostClasses\", void 0);\n__decorate([\n    HostBinding('attr.aria-readonly'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], ColorGradientComponent.prototype, \"readonlyAttribute\", null);\n__decorate([\n    HostBinding('class.k-state-disabled'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], ColorGradientComponent.prototype, \"disabledClass\", null);\n__decorate([\n    HostBinding('attr.tabindex'),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [])\n], ColorGradientComponent.prototype, \"hostTabindex\", null);\n__decorate([\n    HostBinding('attr.id'),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [])\n], ColorGradientComponent.prototype, \"gradientId\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorGradientComponent.prototype, \"id\", void 0);\n__decorate([\n    HostBinding('attr.dir'),\n    __metadata(\"design:type\", String)\n], ColorGradientComponent.prototype, \"direction\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], ColorGradientComponent.prototype, \"opacity\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], ColorGradientComponent.prototype, \"disabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], ColorGradientComponent.prototype, \"readonly\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], ColorGradientComponent.prototype, \"clearButton\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], ColorGradientComponent.prototype, \"delay\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], ColorGradientComponent.prototype, \"value\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorGradientComponent.prototype, \"contrastTool\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], ColorGradientComponent.prototype, \"tabindex\", null);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], ColorGradientComponent.prototype, \"valueChange\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorGradientComponent.prototype, \"format\", void 0);\n__decorate([\n    ViewChild('gradientDragHandle', { read: ElementRef, static: false }),\n    __metadata(\"design:type\", ElementRef)\n], ColorGradientComponent.prototype, \"gradientDragHandle\", void 0);\n__decorate([\n    ViewChild('inputs', { static: false }),\n    __metadata(\"design:type\", ColorInputComponent)\n], ColorGradientComponent.prototype, \"inputs\", void 0);\n__decorate([\n    ViewChild('alphaSlider', { static: false }),\n    __metadata(\"design:type\", SliderComponent)\n], ColorGradientComponent.prototype, \"alphaSlider\", void 0);\n__decorate([\n    ViewChild('gradientWrapper', { static: false }),\n    __metadata(\"design:type\", ElementRef)\n], ColorGradientComponent.prototype, \"gradientWrapper\", void 0);\nColorGradientComponent = ColorGradientComponent_1 = __decorate([\n    Component({\n        selector: 'kendo-colorgradient',\n        providers: [\n            {\n                multi: true,\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => ColorGradientComponent_1)\n            },\n            {\n                provide: KendoInput,\n                useExisting: forwardRef(() => ColorGradientComponent_1)\n            },\n            ColorGradientLocalizationService,\n            {\n                provide: LocalizationService,\n                useExisting: ColorGradientLocalizationService\n            },\n            {\n                provide: L10N_PREFIX,\n                useValue: 'kendo.colorgradient'\n            }\n        ],\n        template: `\n        <ng-container kendoColorGradientLocalizedMessages\n            i18n-colorGradientNoColor=\"kendo.colorgradient.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.\"\n            colorGradientNoColor=\"Colorgradient no color chosen\"\n            i18n-colorGradientHandle=\"kendo.colorgradient.colorGradientHandle|The title for the gradient color drag handle chooser.\"\n            colorGradientHandle=\"Choose color\"\n            i18n-clearButton=\"kendo.colorgradient.clearButton|The title for the clear button.\"\n            clearButton=\"Clear value\"\n            i18n-hueSliderHandle=\"kendo.colorgradient.hueSliderHandle|The title for the hue slider handle.\"\n            hueSliderHandle=\"Set hue\"\n            i18n-opacitySliderHandle=\"kendo.colorgradient.opacitySliderHandle|The title for the opacity slider handle.\"\n            opacitySliderHandle=\"Set opacity\"\n            i18n-hexInputPlaceholder=\"kendo.colorgradient.hexInputPlaceholder|The placeholder for the HEX color input.\"\n            hexInputPlaceholder=\"HEX Color\"\n            i18n-redInputPlaceholder=\"kendo.colorgradient.redInputPlaceholder|The placeholder for the red color input.\"\n            redInputPlaceholder=\"Red\"\n            i18n-greenInputPlaceholder=\"kendo.colorgradient.greenInputPlaceholder|The placeholder for the green color input.\"\n            greenInputPlaceholder=\"Green\"\n            i18n-blueInputPlaceholder=\"kendo.colorgradient.blueInputPlaceholder|The placeholder for the blue color input.\"\n            blueInputPlaceholder=\"Blue\"\n            i18n-alphaInputPlaceholder=\"kendo.colorgradient.alphaInputPlaceholder|The placeholder for the alpha input.\"\n            alphaInputPlaceholder=\"Alpha\"\n            i18n-passContrast=\"kendo.colorgradient.passContrast|The pass message for the contrast tool.\"\n            passContrast=\"Pass\"\n            i18n-failContrast=\"kendo.colorgradient.failContrast|The fail message for the contrast tool.\"\n            failContrast=\"Fail\"\n            i18n-contrastRatio=\"kendo.colorgradient.contrastRatio|The contrast ratio message for the contrast tool.\"\n            contrastRatio=\"Contrast ratio\">\n        </ng-container>\n        <div class=\"k-colorgradient-canvas k-hstack\">\n            <div class=\"k-hsv-rectangle\" [style.background]=\"backgroundColor\">\n                <div\n                    #gradientWrapper\n                    kendoDraggable\n                    class=\"k-hsv-gradient\"\n                    (click)=\"changePosition($event)\"\n                    (kendoPress)=\"handleDragPress($event)\"\n                    (kendoDrag)=\"onHandleDrag($event)\"\n                    (kendoRelease)=\"onHandleRelease()\">\n                    <div\n                        #gradientDragHandle\n                        class=\"k-hsv-draghandle k-draghandle\"\n                        tabindex=\"0\"\n                        [attr.title]=\"colorGradientHandleTitle\"\n                        [attr.aria-label]=\"colorGradientHandleAriaLabel\"\n                    >\n                    </div>\n                </div>\n            </div>\n            <div class=\"k-hsv-controls k-hstack {{ clearButton ? 'k-sliders-wrap-clearable' : '' }}\">\n                <span class=\"k-clear-color k-button k-flat k-button-icon\"\n                    *ngIf=\"clearButton\"\n                    (click)=\"reset()\"\n                    (keydown.enter)=\"reset()\"\n                    (keydown.space)=\"reset()\"\n                    [attr.aria-label]=\"clearButtonTitle\"\n                    [attr.title]=\"clearButtonTitle\"\n                    tabindex=\"0\">\n                    <span class=\"k-icon k-i-reset-color\"></span>\n                </span>\n                <kendo-slider\n                    [ngClass]=\"{'k-align-self-end': clearButton}\"\n                    class=\"k-hue-slider k-colorgradient-slider\"\n                    [dragHandleTitle]=\"hueSliderTitle\"\n                    [disabled]=\"disabled\"\n                    [readonly]=\"readonly\"\n                    [showButtons]=\"false\"\n                    [tickPlacement]=\"'none'\"\n                    [vertical]=\"true\"\n                    [min]=\"0\"\n                    [max]=\"360\"\n                    [smallStep]=\"5\"\n                    [largeStep]=\"10\"\n                    [(value)]=\"hsva.h\"\n                    (valueChange)=\"handleHueSliderChange($event)\"\n                >\n                </kendo-slider>\n                <kendo-slider\n                    *ngIf=\"opacity && format === 'rgba'\"\n                    #alphaSlider\n                    [ngClass]=\"{'k-align-self-end': clearButton}\"\n                    class=\"k-alpha-slider k-colorgradient-slider\"\n                    [dragHandleTitle]=\"opacitySliderTitle\"\n                    [disabled]=\"disabled\"\n                    [readonly]=\"readonly\"\n                    [showButtons]=\"false\"\n                    [tickPlacement]=\"'none'\"\n                    [vertical]=\"true\"\n                    [min]=\"0\"\n                    [max]=\"100\"\n                    [smallStep]=\"1\"\n                    [largeStep]=\"10\"\n                    [value]=\"alphaSliderValue\"\n                    (valueChange)=\"handleAlphaSliderChange($event)\"\n                >\n                </kendo-slider>\n            </div>\n        </div>\n        <kendo-colorinput  #inputs\n            [opacity]=\"opacity\"\n            [formatView]=\"format\"\n            [value]=\"value\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            (valueChange)=\"handleInputsValueChange($event)\"\n        >\n        </kendo-colorinput>\n        <div class=\"k-colorgradient-color-contrast k-vbox\" *ngIf=\"contrastToolVisible\"\n            kendoContrastTool\n            [value]=\"value\"\n            [ratio]=\"contrastTool\">\n        </div>\n    `,\n        styles: [`\n        .k-clear-color {\n            position: absolute;\n            left: 50%;\n            transform: translateX(-50%);\n        }\n        .k-align-self-end {\n            height: 140px;\n        }\n    `]\n    }),\n    __metadata(\"design:paramtypes\", [ElementRef,\n        NgZone,\n        Renderer2,\n        ChangeDetectorRef,\n        LocalizationService])\n], ColorGradientComponent);\n\nvar ColorPickerComponent_1;\nconst DEFAULT_PRESET = 'office';\nconst DEFAULT_ACCESSIBLE_PRESET = 'accessible';\nlet serial$1 = 0;\n/**\n * Represents the [Kendo UI ColorPicker component for Angular]({% slug overview_colorpicker %}).\n * Designed to replace the `<input type=\"color\">` HTML5 tag which is not widely supported in browsers.\n */\nlet ColorPickerComponent = ColorPickerComponent_1 = class ColorPickerComponent {\n    constructor(popupService, cdr, localizationService, ngZone) {\n        this.popupService = popupService;\n        this.cdr = cdr;\n        this.localizationService = localizationService;\n        this.ngZone = ngZone;\n        /**\n         * @hidden\n         */\n        this.hostClasses = true;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-colorpicker-${serial$1++}`;\n        /**\n         * Sets what view the ColorPicker will render in the popup.\n         */\n        this.view = 'gradient';\n        /**\n         * Sets the read-only state of the ColorPicker.\n         */\n        this.readonly = false;\n        /**\n         * Sets the disabled state of the ColorPicker.\n         */\n        this.disabled = false;\n        /**\n         * Specifies the output format of the ColorPicker.\n         * The input value may be in a different format. However, it will be parsed into the output `format`\n         * after the component processes it.\n         *\n         * If the `gradient` view is used with the `opacity` option set to true, this setting will be ignored and `rgba` will be used instead.\n         *\n         * The supported values are:\n         * * `rgba` (default)\n         * * `hex`\n         * * [name](https://www.w3.org/wiki/CSS/Properties/color/keywords)\n         */\n        this.format = 'rgba';\n        /**\n         * Fires each time the value is changed.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the popup is about to open.\n         * This event is preventable. If you cancel it, the popup will remain closed.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close.\n         * This event is preventable. If you cancel it, the popup will remain open.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires each time ColorPicker is focused.\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * Fires each time the ColorPicker is blurred.\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * Fires each time the left side of the ColorPicker wrapper is clicked.\n         * The event is triggered regardless of whether a ColorPicker icon is set or not.\n         *\n         * The [ActiveColorClickEvent]({% slug api_inputs_activecolorclickevent %}) event provides the option to prevent the popup opening.\n         */\n        this.activeColorClick = new EventEmitter();\n        this._tabindex = 0;\n        this._popupSettings = { animate: true };\n        this._paletteSettings = {};\n        this._gradientSettings = { opacity: true, clearButton: false, delay: 0 };\n        this.notifyNgTouched = () => { };\n        this.notifyNgChanged = () => { };\n        validatePackage(packageMetadata);\n        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n    }\n    /**\n     * Specifies the value of the initially selected color.\n     */\n    set value(value) {\n        this._value = parseColor$1(value, this.format);\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Configures the popup of the ColorPicker.\n     */\n    set popupSettings(value) {\n        this._popupSettings = Object.assign(this._popupSettings, value);\n    }\n    get popupSettings() {\n        return this._popupSettings;\n    }\n    /**\n     * Configures the palette that is displayed in the ColorPicker popup.\n     */\n    set paletteSettings(value) {\n        this._paletteSettings = Object.assign(this._paletteSettings, value);\n    }\n    get paletteSettings() {\n        return this._paletteSettings;\n    }\n    /**\n     * Configures the gradient that is displayed in the ColorPicker popup.\n     */\n    set gradientSettings(value) {\n        this._gradientSettings = Object.assign(this._gradientSettings, value);\n    }\n    get gradientSettings() {\n        return this._gradientSettings;\n    }\n    /**\n     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n    set tabindex(value) {\n        const tabindex = Number(value);\n        const defaultValue = 0;\n        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n    get tabindex() {\n        return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * Indicates whether the ColorPicker popup is open.\n     */\n    get isOpen() {\n        return isPresent(this.popupRef);\n    }\n    /**\n     * @hidden\n     */\n    get iconStyles() {\n        if (this.iconClass) {\n            return this.iconClass;\n        }\n        if (this.icon) {\n            return `k-icon k-i-${this.icon}`;\n        }\n    }\n    ngOnInit() {\n        const defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;\n        const settingsPalette = this._paletteSettings.palette;\n        const presetColumns = typeof settingsPalette === 'string' && PALETTEPRESETS[settingsPalette] ?\n            PALETTEPRESETS[settingsPalette].columns :\n            undefined;\n        this._paletteSettings = {\n            palette: settingsPalette || defaultPreset,\n            tileSize: this._paletteSettings.tileSize || 24,\n            columns: this._paletteSettings.columns || presetColumns || 10\n        };\n    }\n    ngOnChanges(changes) {\n        if (changes.format && changes.format.currentValue === 'name') {\n            this.view = 'palette';\n        }\n        if (this.view === 'gradient' && this.gradientSettings.opacity) {\n            this.format = 'rgba';\n            this.value = parseColor$1(this.value, this.format);\n        }\n    }\n    ngOnDestroy() {\n        this.closePopup();\n        if (this.dynamicRTLSubscription) {\n            this.dynamicRTLSubscription.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleWrapperClick() {\n        this.toggleWithEvents(!this.isOpen);\n        this.focus();\n    }\n    /**\n     * @hidden\n     */\n    handleActiveColorClick() {\n        this.focus();\n        const event = new ActiveColorClickEvent(this.value);\n        this.activeColorClick.emit(event);\n        if (!event.isOpenPrevented() || this.isOpen) {\n            this.handleWrapperClick();\n        }\n    }\n    /**\n     * Focuses the wrapper of the ColorPicker.\n     */\n    focus() {\n        if (this.disabled) {\n            return;\n        }\n        this.wrapper.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n    handleWrapperFocus() {\n        if (isPresent(this.palette)) {\n            this.palette.nativeElement.focus();\n        }\n        if (this.isFocused) {\n            return;\n        }\n        this.isFocused = true;\n        this.onFocus.emit();\n    }\n    /**\n     * Blurs the ColorPicker.\n     */\n    blur() {\n        this.wrapper.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     */\n    handleWrapperBlur() {\n        if (this.isOpen) {\n            return;\n        }\n        this.isFocused = false;\n        this.onBlur.emit();\n        this.notifyNgTouched();\n    }\n    /**\n     * Clears the color value of the ColorPicker.\n     */\n    reset() {\n        if (!isPresent(this.value)) {\n            return;\n        }\n        this._value = undefined;\n        this.notifyNgChanged(undefined);\n    }\n    /**\n     * Toggles the popup of the ColorPicker.\n     * Does not trigger the `open` and `close` events of the component.\n     *\n     * @param open An optional parameter. Specifies whether the popup will be opened or closed.\n     */\n    toggle(open) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.closePopup();\n        open = isPresent(open) ? open : !this.isOpen;\n        if (open) {\n            this.openPopup();\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleValueChange(color, closePopup) {\n        const parsedColor = parseColor$1(color, this.format);\n        const valueChange = parsedColor !== this.value;\n        if (closePopup) {\n            this.toggleWithEvents(false);\n            this.focus();\n        }\n        if (valueChange) {\n            this.value = parsedColor;\n            this.valueChange.emit(parsedColor);\n            this.notifyNgChanged(parsedColor);\n        }\n    }\n    /**\n     * @hidden\n     */\n    handlePopupBlur(event) {\n        const focusInPopupElement = this.popupRef.popupElement.contains(event.relatedTarget);\n        const wrapperClicked = event.relatedTarget === this.wrapper.nativeElement;\n        if (!this.isFocused || wrapperClicked || focusInPopupElement) {\n            return;\n        }\n        this.isFocused = false;\n        this.onBlur.emit();\n        this.notifyNgTouched();\n        this.toggleWithEvents(false);\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.value = value;\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.cdr.markForCheck();\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    handleWrapperKeyDown(event) {\n        if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.Enter) {\n            event.preventDefault();\n            this.toggleWithEvents(true);\n        }\n    }\n    /**\n     * @hidden\n     */\n    handlePopupKeyDown(event) {\n        if (event.keyCode === Keys.Escape) {\n            this.toggleWithEvents(false);\n            this.wrapper.nativeElement.focus();\n        }\n        if (event.keyCode === Keys.Tab) {\n            const firstElement = this.colorGradient ? this.colorGradient.gradientDragHandle.nativeElement : this.palette.nativeElement;\n            const lastElement = this.palette ? this.palette.nativeElement :\n                this.colorGradient.inputs.opacityInput.nativeElement.childNodes[1].children[0];\n            if (event.shiftKey) {\n                if (event.target === firstElement) {\n                    event.preventDefault();\n                    lastElement.focus();\n                    return;\n                }\n            }\n            else {\n                if (event.target === lastElement) {\n                    event.preventDefault();\n                    firstElement.focus();\n                    return;\n                }\n            }\n        }\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    toggleWithEvents(open) {\n        const sameState = this.isOpen === open;\n        if (this.disabled || this.readonly || sameState) {\n            return;\n        }\n        const eventArgs = new PreventableEvent();\n        open ? this.open.emit(eventArgs) : this.close.emit(eventArgs);\n        if (!eventArgs.isDefaultPrevented()) {\n            this.toggle(open);\n        }\n        if (open) {\n            this.ngZone.runOutsideAngular(() => {\n                setTimeout(() => {\n                    if (this.colorGradient) {\n                        this.colorGradient.gradientDragHandle.nativeElement.focus();\n                    }\n                });\n            });\n        }\n    }\n    openPopup() {\n        const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n        const anchorPosition = { horizontal: horizontalAlign, vertical: \"bottom\" };\n        const popupPosition = { horizontal: horizontalAlign, vertical: \"top\" };\n        this.popupRef = this.popupService.open({\n            anchor: this.wrapper,\n            animate: this.popupSettings.animate,\n            appendTo: this.popupSettings.appendTo,\n            popupAlign: popupPosition,\n            anchorAlign: anchorPosition,\n            popupClass: 'k-colorpicker-popup',\n            content: this.popupTemplate,\n            positionMode: 'absolute'\n        });\n        this.popupRef.popupAnchorViewportLeave.subscribe(() => {\n            this.toggleWithEvents(false);\n            if (!this.isOpen) {\n                this.wrapper.nativeElement.focus({\n                    preventScroll: true\n                });\n            }\n        });\n    }\n    closePopup() {\n        if (!this.isOpen) {\n            return;\n        }\n        this.popupRef.close();\n        this.popupRef = null;\n        this.palette = null;\n    }\n};\n__decorate([\n    HostBinding('class.k-widget'),\n    HostBinding('class.k-colorpicker'),\n    __metadata(\"design:type\", Boolean)\n], ColorPickerComponent.prototype, \"hostClasses\", void 0);\n__decorate([\n    HostBinding('attr.dir'),\n    __metadata(\"design:type\", String)\n], ColorPickerComponent.prototype, \"direction\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerComponent.prototype, \"focusableId\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerComponent.prototype, \"view\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], ColorPickerComponent.prototype, \"readonly\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], ColorPickerComponent.prototype, \"disabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerComponent.prototype, \"format\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], ColorPickerComponent.prototype, \"value\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object),\n    __metadata(\"design:paramtypes\", [Object])\n], ColorPickerComponent.prototype, \"popupSettings\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object),\n    __metadata(\"design:paramtypes\", [Object])\n], ColorPickerComponent.prototype, \"paletteSettings\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object),\n    __metadata(\"design:paramtypes\", [Object])\n], ColorPickerComponent.prototype, \"gradientSettings\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerComponent.prototype, \"icon\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], ColorPickerComponent.prototype, \"iconClass\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], ColorPickerComponent.prototype, \"tabindex\", null);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], ColorPickerComponent.prototype, \"valueChange\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], ColorPickerComponent.prototype, \"open\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], ColorPickerComponent.prototype, \"close\", void 0);\n__decorate([\n    Output('focus'),\n    __metadata(\"design:type\", EventEmitter)\n], ColorPickerComponent.prototype, \"onFocus\", void 0);\n__decorate([\n    Output('blur'),\n    __metadata(\"design:type\", EventEmitter)\n], ColorPickerComponent.prototype, \"onBlur\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], ColorPickerComponent.prototype, \"activeColorClick\", void 0);\n__decorate([\n    ViewChild('container', { read: ViewContainerRef, static: true }),\n    __metadata(\"design:type\", ViewContainerRef)\n], ColorPickerComponent.prototype, \"container\", void 0);\n__decorate([\n    ViewChild('wrapper', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], ColorPickerComponent.prototype, \"wrapper\", void 0);\n__decorate([\n    ViewChild('popupTemplate', { static: true }),\n    __metadata(\"design:type\", TemplateRef)\n], ColorPickerComponent.prototype, \"popupTemplate\", void 0);\n__decorate([\n    ViewChild('palette', { read: ElementRef, static: false }),\n    __metadata(\"design:type\", ElementRef)\n], ColorPickerComponent.prototype, \"palette\", void 0);\n__decorate([\n    ViewChild('colorGradient', { static: false }),\n    __metadata(\"design:type\", ColorGradientComponent)\n], ColorPickerComponent.prototype, \"colorGradient\", void 0);\nColorPickerComponent = ColorPickerComponent_1 = __decorate([\n    Component({\n        selector: 'kendo-colorpicker',\n        providers: [{\n                multi: true,\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => ColorPickerComponent_1)\n            }, {\n                provide: KendoInput,\n                useExisting: forwardRef(() => ColorPickerComponent_1)\n            },\n            ColorPickerLocalizationService,\n            {\n                provide: LocalizationService,\n                useExisting: ColorPickerLocalizationService\n            },\n            {\n                provide: L10N_PREFIX,\n                useValue: 'kendo.colorpicker'\n            }\n        ],\n        template: `\n        <ng-container kendoColorPickerLocalizedMessages\n            i18n-colorGradient=\"kendo.colorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.\"\n            colorGradientNoColor=\"Colorgradient no color chosen\"\n            i18n-colorGradient=\"kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.\"\n            colorPaletteNoColor=\"Colorpalette no color chosen\"\n            i18n-colorGradientHandle=\"kendo.colorpicker.colorGradientHandle|The title for the gradient color drag handle chooser.\"\n            colorGradientHandle=\"Choose color\"\n            i18n-clearButton=\"kendo.colorpicker.clearButton|The title for the clear button.\"\n            clearButton=\"Clear value\"\n            i18n-hueSliderHandle=\"kendo.colorpicker.hueSliderHandle|The title for the hue slider handle.\"\n            hueSliderHandle=\"Set hue\"\n            i18n-opacitySliderHandle=\"kendo.colorpicker.opacitySliderHandle|The title for the opacity slider handle.\"\n            opacitySliderHandle=\"Set opacity\"\n            i18n-hexInputPlaceholder=\"kendo.colorpicker.hexInputPlaceholder|The placeholder for the HEX color input.\"\n            hexInputPlaceholder=\"HEX Color\"\n            i18n-redInputPlaceholder=\"kendo.colorpicker.redInputPlaceholder|The placeholder for the red color input.\"\n            redInputPlaceholder=\"Red\"\n            i18n-greenInputPlaceholder=\"kendo.colorpicker.greenInputPlaceholder|The placeholder for the green color input.\"\n            greenInputPlaceholder=\"Green\"\n            i18n-blueInputPlaceholder=\"kendo.colorpicker.blueInputPlaceholder|The placeholder for the blue color input.\"\n            blueInputPlaceholder=\"Blue\"\n            i18n-alphaInputPlaceholder=\"kendo.colorpicker.alphaInputPlaceholder|The placeholder for the alpha input.\"\n            alphaInputPlaceholder=\"Alpha\">\n        </ng-container>\n        <span\n            #wrapper\n            [ngClass]=\"{\n                'k-picker-wrap': true,\n                'k-state-disabled': this.disabled,\n                'k-state-focused': this.isFocused\n            }\"\n            role=\"listbox\"\n            [attr.aria-expanded]=\"isOpen\"\n            [attr.aria-readonly]=\"readonly\"\n            [attr.aria-disabled]=\"disabled\"\n            [attr.aria-label]=\"value\"\n            [id]=\"focusableId\"\n            [attr.tabindex]=\"tabindex\"\n            (focus)=\"handleWrapperFocus()\"\n            (blur)=\"handleWrapperBlur()\"\n            (mousedown)=\"$event.preventDefault()\"\n            (keydown)=\"handleWrapperKeyDown($event)\"\n        >\n            <span *ngIf=\"!iconStyles\" class=\"k-selected-color\" [style.background-color]=\"value\" (click)=\"handleActiveColorClick()\">\n                <span class=\"k-icon k-i-line\" *ngIf=\"!value\"></span>\n            </span>\n            <span *ngIf=\"iconStyles\" class=\"k-tool-icon\" [ngClass]=\"iconStyles\" (click)=\"handleActiveColorClick()\">\n                <span class=\"k-selected-color\" [style.background-color]=\"value\"></span>\n            </span>\n            <span class=\"k-select\" (click)=\"handleWrapperClick()\">\n                <span class=\"k-icon k-i-arrow-s\"></span>\n            </span>\n        </span>\n        <ng-template #popupTemplate>\n            <kendo-colorgradient  #colorGradient\n                *ngIf=\"view === 'gradient' || view === 'combo'\"\n                [value]=\"value\"\n                [format]=\"format\"\n                [opacity]=\"gradientSettings.opacity\"\n                [clearButton]=\"gradientSettings.clearButton\"\n                [delay]=\"gradientSettings.delay\"\n                (focusout)=\"handlePopupBlur($event)\"\n                (valueChange)=\"handleValueChange($event, false)\"\n                (keydown)=\"handlePopupKeyDown($event)\"\n            >\n            </kendo-colorgradient>\n            <kendo-colorpalette\n                #palette\n                *ngIf=\"view === 'palette' || view === 'combo'\"\n                kendoFocusOnDomReady\n                [palette]=\"paletteSettings.palette\"\n                [columns]=\"paletteSettings.columns\"\n                [tileSize]=\"paletteSettings.tileSize\"\n                [format]=\"format\"\n                [value]=\"value\"\n                (blur)=\"handlePopupBlur($event)\"\n                (cellSelection)=\"handleValueChange($event, true)\"\n                (mousedown)=\"$event.preventDefault()\"\n                (keydown)=\"handlePopupKeyDown($event)\"\n            >\n            </kendo-colorpalette>\n        </ng-template>\n        <ng-container #container></ng-container>\n    `\n    }),\n    __metadata(\"design:paramtypes\", [PopupService,\n        ChangeDetectorRef,\n        LocalizationService,\n        NgZone])\n], ColorPickerComponent);\n\n/**\n * @hidden\n */\nlet ColorPaletteService = class ColorPaletteService {\n    /**\n     * @hidden\n     */\n    constructor() {\n        this.colorRows = [];\n    }\n    setColorMatrix(palette, columns) {\n        this.colorRows = [];\n        if (!(isPresent(palette) && palette.length)) {\n            return;\n        }\n        columns = columns || palette.length;\n        for (let start = 0; start < palette.length; start += columns) {\n            const row = palette.slice(start, columns + start);\n            this.colorRows.push(row);\n        }\n    }\n    getCellCoordsFor(color) {\n        if (!isPresent(color)) {\n            return;\n        }\n        for (let row = 0; row < this.colorRows.length; row++) {\n            for (let col = 0; col < this.colorRows[row].length; col++) {\n                if (this.colorRows[row][col] === color) {\n                    return { row, col };\n                }\n            }\n        }\n    }\n    getColorAt(cellCoords) {\n        if (!(isPresent(cellCoords) && isPresent(this.colorRows[cellCoords.row]))) {\n            return;\n        }\n        return this.colorRows[cellCoords.row][cellCoords.col];\n    }\n    getNextCell(current, horizontalStep, verticalStep) {\n        if (!(isPresent(current) && isPresent(current.row) && isPresent(current.col))) {\n            return { row: 0, col: 0 };\n        }\n        const row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);\n        const col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);\n        return { row, col };\n    }\n    clampIndex(index, max) {\n        const minArrayIndex = 0;\n        if (index < minArrayIndex) {\n            return minArrayIndex;\n        }\n        if (index > max) {\n            return max;\n        }\n        return index;\n    }\n};\nColorPaletteService = __decorate([\n    Injectable()\n], ColorPaletteService);\n\n/**\n * @hidden\n */\nlet ColorPaletteLocalizationService = class ColorPaletteLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, _rtl, colorPickerLocalization) {\n        super(prefix, messageService, _rtl);\n        this.colorPickerLocalization = colorPickerLocalization;\n    }\n    get(shortKey) {\n        if (this.colorPickerLocalization) {\n            return this.colorPickerLocalization.get(shortKey);\n        }\n        return super.get(shortKey);\n    }\n};\nColorPaletteLocalizationService = __decorate([\n    __param(0, Inject(L10N_PREFIX)),\n    __param(1, Optional()),\n    __param(2, Optional()), __param(2, Inject(RTL)),\n    __param(3, Optional()), __param(3, Inject(ColorPickerLocalizationService)),\n    __metadata(\"design:paramtypes\", [String, MessageService, Boolean, ColorPickerLocalizationService])\n], ColorPaletteLocalizationService);\n\nvar ColorPaletteComponent_1;\nconst DEFAULT_TILE_SIZE = 24;\nconst DEFAULT_COLUMNS_COUNT = 10;\nconst DEFAULT_PRESET$1 = 'office';\nconst DEFAULT_ACCESSIBLE_PRESET$1 = 'accessible';\nlet serial$2 = 0;\n/**\n * The ColorPalette component provides a set of predefined palette presets and enables you to implement a custom color palette.\n * The ColorPalette is independently used by `kendo-colorpicker` and can be directly added to the page.\n */\nlet ColorPaletteComponent = ColorPaletteComponent_1 = class ColorPaletteComponent {\n    constructor(host, service, cdr, renderer, localizationService) {\n        this.host = host;\n        this.service = service;\n        this.cdr = cdr;\n        this.renderer = renderer;\n        this.localizationService = localizationService;\n        /**\n         * @hidden\n         */\n        this.id = `k-colorpalette-${serial$2++}`;\n        /**\n         * Specifies the output format of the ColorPaletteComponent.\n         * The input value may be in a different format. However, it will be parsed into the output `format`\n         * after the component processes it.\n         *\n         * The supported values are:\n         * * (Default) `hex`\n         * * `rgba`\n         * * `name`\n         */\n        this.format = 'hex';\n        /**\n         * Sets the disabled state of the ColorPalette.\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the ColorPalette.\n         */\n        this.readonly = false;\n        /**\n         * Specifies the size of a color cell.\n         *\n         * The possible values are:\n         * * (Default) `tileSize = 24`\n         * * `{ width: number, height: number }`\n         */\n        this.tileSize = { width: DEFAULT_TILE_SIZE, height: DEFAULT_TILE_SIZE };\n        /**\n         * Fires each time the color selection is changed.\n         */\n        this.selectionChange = new EventEmitter();\n        /**\n         * Fires each time the value is changed.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user selects a cell with the mouse or presses `Enter`.\n         *\n         * @hidden\n         */\n        this.cellSelection = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.hostClasses = true;\n        this._tabindex = 0;\n        this.notifyNgTouched = () => { };\n        this.notifyNgChanged = () => { };\n        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n    }\n    /**\n     * @hidden\n     */\n    get paletteId() {\n        return this.id;\n    }\n    /**\n     * Specifies the value of the initially selected color.\n     */\n    set value(value) {\n        this._value = parseColor$1(value, this.format);\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Specifies the number of columns that will be displayed.\n     * Defaults to `10`.\n     */\n    set columns(value) {\n        const minColumnsCount = 1;\n        this._columns = value > minColumnsCount ? value : minColumnsCount;\n    }\n    get columns() {\n        return this._columns;\n    }\n    /**\n     * The color palette that will be displayed.\n     *\n     * The supported values are:\n     * * The name of the predefined palette preset (for example, `office`, `basic`, and `apex`).\n     * * A string with comma-separated colors.\n     * * A string array.\n     */\n    set palette(value) {\n        if (!isPresent(value)) {\n            value = DEFAULT_PRESET$1;\n        }\n        if (typeof value === 'string' && isPresent(PALETTEPRESETS[value])) {\n            this.columns = this.columns || PALETTEPRESETS[value].columns;\n            value = PALETTEPRESETS[value].colors;\n        }\n        const colors = (typeof value === 'string') ? value.split(',') : value;\n        this._palette = colors.map(color => parseColor$1(color, this.format, false));\n    }\n    get palette() {\n        return this._palette;\n    }\n    /**\n     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n    set tabindex(value) {\n        const tabindex = Number(value);\n        const defaultValue = 0;\n        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n    get tabindex() {\n        return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get tileLayout() {\n        if (typeof this.tileSize !== 'number') {\n            return this.tileSize;\n        }\n        return { width: this.tileSize, height: this.tileSize };\n    }\n    /**\n     * @hidden\n     */\n    get colorRows() {\n        return this.service.colorRows;\n    }\n    /**\n     * @hidden\n     */\n    get hostTabindex() { return this.tabindex; }\n    /**\n     * @hidden\n     */\n    get disabledClass() { return this.disabled; }\n    /**\n     * @hidden\n     */\n    get readonlyAttribute() { return this.readonly; }\n    ngOnInit() {\n        if (this.colorRows.length === 0) {\n            const defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;\n            this.palette = this.palette || defaultPreset;\n            this.setRows();\n            this.focusedCell = this.service.getCellCoordsFor(this.value);\n        }\n    }\n    ngAfterViewInit() {\n        this.setHostElementAriaLabel();\n    }\n    ngOnDestroy() {\n        if (this.dynamicRTLSubscription) {\n            this.dynamicRTLSubscription.unsubscribe();\n        }\n    }\n    ngOnChanges(changes) {\n        if (changes.palette || changes.columns) {\n            this.setRows();\n        }\n        if (changes.palette || changes.value || changes.columns) {\n            this.focusedCell = this.service.getCellCoordsFor(this.value);\n            this.setHostElementAriaLabel();\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleKeydown(event) {\n        const isRTL = this.direction === 'rtl';\n        switch (event.keyCode) {\n            case Keys.ArrowDown:\n                this.handleCellNavigation(0, 1);\n                break;\n            case Keys.ArrowUp:\n                this.handleCellNavigation(0, -1);\n                break;\n            case Keys.ArrowRight:\n                this.handleCellNavigation(isRTL ? -1 : 1, 0);\n                break;\n            case Keys.ArrowLeft:\n                this.handleCellNavigation(isRTL ? 1 : -1, 0);\n                break;\n            case Keys.Enter:\n                this.handleEnter();\n                break;\n            default: return;\n        }\n        event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    handleHostBlur() {\n        this.notifyNgTouched();\n        this.handleCellFocusOnBlur();\n    }\n    /**\n     * @hidden\n     */\n    handleCellSelection(value, cell) {\n        if (this.readonly) {\n            return;\n        }\n        this.selectedCell = cell;\n        this.focusedCell = this.selectedCell;\n        this.focusInComponent = true;\n        const parsedColor = parseColor$1(value, this.format, false);\n        this.cellSelection.emit(parsedColor);\n        if (this.value !== parsedColor) {\n            this.value = parsedColor;\n            this.valueChange.emit(parsedColor);\n            this.notifyNgChanged(parsedColor);\n            this.setHostElementAriaLabel();\n        }\n        if (this.selection !== parsedColor) {\n            this.selection = parsedColor;\n            this.selectionChange.emit(parsedColor);\n        }\n        if (cell) {\n            this.activeCellId = `${this.selectedCell.row}-${this.selectedCell.col}`;\n        }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.value = value;\n        this.focusedCell = this.service.getCellCoordsFor(this.value);\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.cdr.markForCheck();\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    /**\n     * Clears the color value of the ColorPalette.\n     */\n    reset() {\n        this.focusedCell = null;\n        if (isPresent(this.value)) {\n            this._value = undefined;\n            this.notifyNgChanged(undefined);\n        }\n    }\n    handleCellFocusOnBlur() {\n        this.focusInComponent = false;\n        this.focusedCell = this.selectedCell;\n    }\n    setRows() {\n        if (!isPresent(this.palette)) {\n            return;\n        }\n        this.columns = this.columns || DEFAULT_COLUMNS_COUNT;\n        this.service.setColorMatrix(this.palette, this.columns);\n    }\n    handleCellNavigation(horizontalStep, verticalStep) {\n        if (this.readonly) {\n            return;\n        }\n        this.focusedCell = this.service.getNextCell(this.focusedCell, horizontalStep, verticalStep);\n        this.focusInComponent = true;\n    }\n    setHostElementAriaLabel() {\n        const parsed = parseColor$1(this.value, this.format);\n        this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorPaletteNoColor')}`);\n    }\n    handleEnter() {\n        if (!isPresent(this.focusedCell)) {\n            return;\n        }\n        const selectedColor = this.service.getColorAt(this.focusedCell);\n        this.handleCellSelection(selectedColor, this.focusedCell);\n    }\n};\n__decorate([\n    HostBinding('attr.dir'),\n    __metadata(\"design:type\", String)\n], ColorPaletteComponent.prototype, \"direction\", void 0);\n__decorate([\n    HostBinding('attr.id'),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [])\n], ColorPaletteComponent.prototype, \"paletteId\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPaletteComponent.prototype, \"id\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPaletteComponent.prototype, \"format\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], ColorPaletteComponent.prototype, \"value\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], ColorPaletteComponent.prototype, \"columns\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object),\n    __metadata(\"design:paramtypes\", [Object])\n], ColorPaletteComponent.prototype, \"palette\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], ColorPaletteComponent.prototype, \"tabindex\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], ColorPaletteComponent.prototype, \"disabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], ColorPaletteComponent.prototype, \"readonly\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], ColorPaletteComponent.prototype, \"tileSize\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], ColorPaletteComponent.prototype, \"selectionChange\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], ColorPaletteComponent.prototype, \"valueChange\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], ColorPaletteComponent.prototype, \"cellSelection\", void 0);\n__decorate([\n    HostBinding('attr.tabindex'),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [])\n], ColorPaletteComponent.prototype, \"hostTabindex\", null);\n__decorate([\n    HostBinding('class.k-colorpalette'),\n    __metadata(\"design:type\", Boolean)\n], ColorPaletteComponent.prototype, \"hostClasses\", void 0);\n__decorate([\n    HostBinding('attr.aria-disabled'),\n    HostBinding('class.k-state-disabled'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], ColorPaletteComponent.prototype, \"disabledClass\", null);\n__decorate([\n    HostBinding('attr.aria-readonly'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], ColorPaletteComponent.prototype, \"readonlyAttribute\", null);\n__decorate([\n    HostListener('keydown', ['$event']),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object]),\n    __metadata(\"design:returntype\", void 0)\n], ColorPaletteComponent.prototype, \"handleKeydown\", null);\n__decorate([\n    HostListener('blur'),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", void 0)\n], ColorPaletteComponent.prototype, \"handleHostBlur\", null);\nColorPaletteComponent = ColorPaletteComponent_1 = __decorate([\n    Component({\n        selector: 'kendo-colorpalette',\n        providers: [\n            {\n                multi: true,\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => ColorPaletteComponent_1) // tslint:disable-line:no-forward-ref\n            }, {\n                provide: KendoInput,\n                useExisting: forwardRef(() => ColorPaletteComponent_1)\n            },\n            ColorPaletteService,\n            ColorPaletteLocalizationService,\n            {\n                provide: LocalizationService,\n                useExisting: ColorPaletteLocalizationService\n            },\n            {\n                provide: L10N_PREFIX,\n                useValue: 'kendo.colorpalette'\n            }\n        ],\n        template: `\n        <ng-container kendoColorPaletteLocalizedMessages\n            i18n-colorPaletteNoColor=\"kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.\"\n            colorPaletteNoColor=\"Colorpalette no color chosen\">\n        </ng-container>\n        <div role=\"listbox\" class=\"k-colorpalette-table-wrap\"\n            [attr.aria-activedescendant]=\"activeCellId\">\n            <table class=\"k-colorpalette-table k-palette\">\n                <tbody>\n                    <tr *ngFor=\"let row of colorRows; let rowIndex = index\">\n                        <td *ngFor=\"let color of row; let colIndex = index\"\n                            role=\"option\"\n                            [class.k-state-selected]=\"selectedCell?.row === rowIndex && selectedCell?.col === colIndex\"\n                            [class.k-state-focus]=\"focusInComponent && focusedCell?.row === rowIndex && focusedCell?.col === colIndex\"\n                            [attr.aria-selected]=\"selectedCell?.row === rowIndex && selectedCell?.col === colIndex\"\n                            [attr.aria-label]=\"color\"\n                            class=\"k-colorpalette-tile\"\n                            [id]=\"rowIndex + '-' + colIndex\"\n                            [attr.value]=\"color\"\n                            (click)=\"handleCellSelection(color, { row: rowIndex, col: colIndex })\"\n                            [ngStyle]=\"{\n                                backgroundColor: color,\n                                width: tileLayout.width + 'px',\n                                height: tileLayout.height + 'px',\n                                minWidth: tileLayout.width + 'px'\n                            }\">\n                        </td>\n                    </tr>\n                </tbody>\n            </table>\n        </div>\n    `\n    }),\n    __metadata(\"design:paramtypes\", [ElementRef,\n        ColorPaletteService,\n        ChangeDetectorRef,\n        Renderer2,\n        LocalizationService])\n], ColorPaletteComponent);\n\n/**\n * @hidden\n */\nclass ColorPickerMessages extends ComponentMessages {\n}\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"colorPaletteNoColor\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"colorGradientNoColor\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"colorGradientHandle\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"clearButton\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"hueSliderHandle\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"opacitySliderHandle\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"hexInputPlaceholder\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"redInputPlaceholder\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"greenInputPlaceholder\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"blueInputPlaceholder\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"alphaInputPlaceholder\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"passContrast\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"failContrast\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ColorPickerMessages.prototype, \"contrastRatio\", void 0);\n\nvar ColorPickerCustomMessagesComponent_1;\n/**\n * Custom component messages override default component messages.\n */\nlet ColorPickerCustomMessagesComponent = ColorPickerCustomMessagesComponent_1 = class ColorPickerCustomMessagesComponent extends ColorPickerMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n};\nColorPickerCustomMessagesComponent = ColorPickerCustomMessagesComponent_1 = __decorate([\n    Component({\n        providers: [\n            {\n                provide: ColorPickerMessages,\n                useExisting: forwardRef(() => ColorPickerCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref\n            }\n        ],\n        selector: 'kendo-colorpicker-messages, kendo-colorgradient-messages, kendo-colorpalette-messages',\n        template: ``\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], ColorPickerCustomMessagesComponent);\n\nvar LocalizedColorPickerMessagesDirective_1;\n/**\n * @hidden\n */\nlet LocalizedColorPickerMessagesDirective = LocalizedColorPickerMessagesDirective_1 = class LocalizedColorPickerMessagesDirective extends ColorPickerMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n};\nLocalizedColorPickerMessagesDirective = LocalizedColorPickerMessagesDirective_1 = __decorate([\n    Directive({\n        providers: [\n            {\n                provide: ColorPickerMessages,\n                useExisting: forwardRef(() => LocalizedColorPickerMessagesDirective_1) // tslint:disable-line:no-forward-ref\n            }\n        ],\n        selector: '[kendoColorPickerLocalizedMessages], [kendoColorGradientLocalizedMessages], [kendoColorPaletteLocalizedMessages]'\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], LocalizedColorPickerMessagesDirective);\n\n/**\n * @hidden\n */\nlet FocusOnDomReadyDirective = class FocusOnDomReadyDirective {\n    constructor(host, ngZone) {\n        this.host = host;\n        this.ngZone = ngZone;\n    }\n    ngAfterContentInit() {\n        this.focusOnNextTick();\n    }\n    focusOnNextTick() {\n        this.ngZone.runOutsideAngular(() => setTimeout(() => this.host.nativeElement.focus()));\n    }\n};\nFocusOnDomReadyDirective = __decorate([\n    Directive({\n        selector: '[kendoFocusOnDomReady]'\n    }),\n    __metadata(\"design:paramtypes\", [ElementRef,\n        NgZone])\n], FocusOnDomReadyDirective);\n\n/**\n * @hidden\n */\nlet ContrastValidationComponent = class ContrastValidationComponent {\n    constructor(localization) {\n        this.localization = localization;\n    }\n    get passMessage() {\n        return this.localization.get('passContrast');\n    }\n    get failMessage() {\n        return this.localization.get('failContrast');\n    }\n    get contrastText() {\n        return `${this.type}: ${this.ratio.toFixed(1)}`;\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ContrastValidationComponent.prototype, \"type\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], ContrastValidationComponent.prototype, \"ratio\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], ContrastValidationComponent.prototype, \"pass\", void 0);\nContrastValidationComponent = __decorate([\n    Component({\n        selector: '[kendoContrastValidation]',\n        template: `\n        <span>{{contrastText}}</span>\n                <span class=\"k-contrast-validation k-text-success\" *ngIf=\"pass\">\n                    {{passMessage}}\n                    <span class=\"k-icon k-i-check\"></span>\n                </span>\n                <span class=\"k-contrast-validation k-text-error\" *ngIf=\"!pass\">\n                    {{failMessage}}\n                <span class=\"k-icon k-i-close\"></span>\n        </span>\n    `\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], ContrastValidationComponent);\n\n/**\n * @hidden\n */\nlet ContrastComponent = class ContrastComponent {\n    constructor(localization) {\n        this.localization = localization;\n        this.aaRatio = AA_RATIO;\n        this.aaaRatio = AAA_RATIO;\n    }\n    get formatedRatio() {\n        return this.contrastRatio.toFixed(2);\n    }\n    get contrastRatioMessage() {\n        return this.localization.get('contrastRatio');\n    }\n    get satisfiesAACondition() {\n        return this.contrastRatio >= this.aaRatio;\n    }\n    get satisfiesAAACondition() {\n        return this.contrastRatio >= this.aaaRatio;\n    }\n    get contrastRatio() {\n        let contrast = getContrastFromTwoRGBAs(getRGBA(this.value), getRGBA(this.ratio));\n        return contrast;\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ContrastComponent.prototype, \"value\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ContrastComponent.prototype, \"ratio\", void 0);\nContrastComponent = __decorate([\n    Component({\n        selector: '[kendoContrastTool]',\n        template: `\n        <div class=\"k-contrast-ratio\">\n            <span class=\"k-contrast-ratio-text\">{{contrastRatioMessage}}: {{formatedRatio}}</span>\n            <span class=\"k-contrast-validation k-text-success\" *ngIf=\"satisfiesAACondition\">\n                <span class=\"k-icon k-i-check\"></span>\n                <span class=\"k-icon k-i-check\" *ngIf=\"satisfiesAAACondition\"></span>\n            </span>\n            <span class=\"k-contrast-validation k-text-error\" *ngIf=\"!satisfiesAACondition\">\n                <span class=\"k-icon k-i-close\"></span>\n            </span>\n        </div>\n        <div kendoContrastValidation\n            type=\"AA\"\n            [ratio]=\"aaaRatio\"\n            [pass]=\"satisfiesAACondition\">\n        </div>\n        <div kendoContrastValidation\n            type=\"AAA\"\n            [ratio]=\"aaaRatio\"\n            [pass]=\"satisfiesAAACondition\">\n        </div>\n    `\n    }),\n    __metadata(\"design:paramtypes\", [LocalizationService])\n], ContrastComponent);\n\nconst PUBLIC_DIRECTIVES = [\n    ColorPickerComponent,\n    ColorPaletteComponent,\n    ColorGradientComponent,\n    LocalizedColorPickerMessagesDirective,\n    ColorPickerCustomMessagesComponent\n];\nconst INTERNAL_DIRECTIVES = [\n    ColorInputComponent,\n    FocusOnDomReadyDirective,\n    ContrastComponent,\n    ContrastValidationComponent\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the ColorPicker.\n */\nlet ColorPickerModule = class ColorPickerModule {\n};\nColorPickerModule = __decorate([\n    NgModule({\n        declarations: [\n            PUBLIC_DIRECTIVES,\n            INTERNAL_DIRECTIVES\n        ],\n        exports: [PUBLIC_DIRECTIVES],\n        imports: [\n            SliderModule,\n            NumericTextBoxModule,\n            CommonModule,\n            PopupModule,\n            DraggableModule\n        ]\n    })\n], ColorPickerModule);\n\n/**\n * Represents the directive that renders the [Kendo UI CheckBox]({% slug overview_checkbox %}) input component.\n * The directive is placed on input type=\"checkbox\" elements.\n *\n * @example\n * ```ts-no-run\n * <input type=\"checkbox\" kendoCheckBox />\n * ```\n */\nlet CheckBoxDirective = class CheckBoxDirective {\n    /**\n     * Represents the directive that renders the [Kendo UI CheckBox]({% slug overview_checkbox %}) input component.\n     * The directive is placed on input type=\"checkbox\" elements.\n     *\n     * @example\n     * ```ts-no-run\n     * <input type=\"checkbox\" kendoCheckBox />\n     * ```\n     */\n    constructor() {\n        this.kendoClass = true;\n    }\n};\n__decorate([\n    HostBinding('class.k-checkbox'),\n    __metadata(\"design:type\", Boolean)\n], CheckBoxDirective.prototype, \"kendoClass\", void 0);\nCheckBoxDirective = __decorate([\n    Directive({\n        selector: 'input[kendoCheckBox]'\n    })\n], CheckBoxDirective);\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the CheckBox directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the CheckBox module\n * import { CheckBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, CheckBoxModule], // import CheckBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet CheckBoxModule = class CheckBoxModule {\n};\nCheckBoxModule = __decorate([\n    NgModule({\n        declarations: [CheckBoxDirective],\n        exports: [CheckBoxDirective],\n        imports: [CommonModule]\n    })\n], CheckBoxModule);\n\n/**\n * Represents the directive that renders the [Kendo UI RadioButton]({% slug overview_checkbox %}) input component.\n * The directive is placed on input type=\"radio\" elements.\n *\n * @example\n * ```ts-no-run\n * <input type=\"radio\" kendoRadioButton />\n * ```\n */\nlet RadioButtonDirective = class RadioButtonDirective {\n    /**\n     * Represents the directive that renders the [Kendo UI RadioButton]({% slug overview_checkbox %}) input component.\n     * The directive is placed on input type=\"radio\" elements.\n     *\n     * @example\n     * ```ts-no-run\n     * <input type=\"radio\" kendoRadioButton />\n     * ```\n     */\n    constructor() {\n        this.kendoClass = true;\n    }\n};\n__decorate([\n    HostBinding('class.k-radio'),\n    __metadata(\"design:type\", Boolean)\n], RadioButtonDirective.prototype, \"kendoClass\", void 0);\nRadioButtonDirective = __decorate([\n    Directive({\n        selector: 'input[kendoRadioButton]'\n    })\n], RadioButtonDirective);\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the RadioButton directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the RadioButton module\n * import { RadioButtonModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, RadioButtonModule], // import RadioButton module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet RadioButtonModule = class RadioButtonModule {\n};\nRadioButtonModule = __decorate([\n    NgModule({\n        declarations: [RadioButtonDirective],\n        exports: [RadioButtonDirective],\n        imports: [CommonModule]\n    })\n], RadioButtonModule);\n\nlet serial$3 = 0;\n/**\n * Represents an error message that will be shown underneath\n * a Kendo control or native HTML form-bound component after a validation.\n */\nlet ErrorComponent = class ErrorComponent {\n    /**\n     * Represents an error message that will be shown underneath\n     * a Kendo control or native HTML form-bound component after a validation.\n     */\n    constructor() {\n        this.hostClass = true;\n        /**\n         * Specifies the alignment of the Error message.\n         *\n         * The possible values are:\n         * * (Default) `start`\n         * * `end`\n         */\n        this.align = 'start';\n        /**\n         * @hidden\n         */\n        this.id = `kendo-error-${serial$3++}`;\n        this.roleAttribute = 'alert';\n    }\n    get startClass() {\n        return this.align === 'start';\n    }\n    get endClass() {\n        return this.align === 'end';\n    }\n    get idAttribute() {\n        return this.id;\n    }\n};\n__decorate([\n    HostBinding('class.k-form-error'),\n    __metadata(\"design:type\", Boolean)\n], ErrorComponent.prototype, \"hostClass\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], ErrorComponent.prototype, \"align\", void 0);\n__decorate([\n    HostBinding('attr.role'),\n    __metadata(\"design:type\", String)\n], ErrorComponent.prototype, \"roleAttribute\", void 0);\n__decorate([\n    HostBinding('class.k-text-start'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], ErrorComponent.prototype, \"startClass\", null);\n__decorate([\n    HostBinding('class.k-text-end'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], ErrorComponent.prototype, \"endClass\", null);\n__decorate([\n    HostBinding('attr.id'),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [])\n], ErrorComponent.prototype, \"idAttribute\", null);\nErrorComponent = __decorate([\n    Component({\n        selector: 'kendo-formerror',\n        template: `\n        <ng-content></ng-content>\n    `\n    })\n], ErrorComponent);\n\nlet serial$4 = 0;\n/**\n * Represents a hint message that will be shown underneath a form-bound component.\n */\nlet HintComponent = class HintComponent {\n    /**\n     * Represents a hint message that will be shown underneath a form-bound component.\n     */\n    constructor() {\n        /**\n         * Specifies the alignment of the Hint message.\n         *\n         * The possible values are:\n         * * (Default) `start`\n         * * `end`\n         */\n        this.align = 'start';\n        /**\n         * @hidden\n         */\n        this.id = `kendo-hint-${serial$4++}`;\n        this.hostClass = true;\n    }\n    get startClass() {\n        return this.align === 'start';\n    }\n    get endClass() {\n        return this.align === 'end';\n    }\n    get idAttribute() {\n        return this.id;\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], HintComponent.prototype, \"align\", void 0);\n__decorate([\n    HostBinding('class.k-form-hint'),\n    __metadata(\"design:type\", Boolean)\n], HintComponent.prototype, \"hostClass\", void 0);\n__decorate([\n    HostBinding('class.k-text-start'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], HintComponent.prototype, \"startClass\", null);\n__decorate([\n    HostBinding('class.k-text-end'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], HintComponent.prototype, \"endClass\", null);\n__decorate([\n    HostBinding('attr.id'),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [])\n], HintComponent.prototype, \"idAttribute\", null);\nHintComponent = __decorate([\n    Component({\n        selector: 'kendo-formhint',\n        template: `\n        <ng-content></ng-content>\n    `\n    })\n], HintComponent);\n\n/**\n * Specifies a container for form-bound controls (Kendo controls or native HTML controls).\n * Applies styling and behavior rules.\n */\nlet FormFieldComponent = class FormFieldComponent {\n    constructor(renderer, localizationService, hostElement) {\n        this.renderer = renderer;\n        this.localizationService = localizationService;\n        this.hostElement = hostElement;\n        this.hostClass = true;\n        /**\n         *\n         * Specifies when the Hint messages will be shown.\n         *\n         * The possible values are:\n         *\n         * * (Default) `initial`&mdash;Allows displaying hints when the form-bound component state is\n         * `valid` or `untouched` and `pristine`.\n         * * `always`&mdash;Allows full control over the visibility of the hints.\n         *\n         */\n        this.showHints = 'initial';\n        /**\n         * Specifies the layout orientation of the form field.\n         *\n         * * The possible values are:\n         *\n         * * (Default) `vertical`\n         * * `horizontal`\n         */\n        this.orientation = 'vertical';\n        /**\n         * Specifies when the Error messages will be shown.\n         *\n         * The possible values are:\n         *\n         * * (Default) `initial`&mdash;Allows displaying errors when the form-bound component state is\n         * `invalid` and `touched` or `dirty`.\n         * * `always`&mdash;Allows full control over the visibility of the errors.\n         *\n         */\n        this.showErrors = 'initial';\n        this.subscriptions = new Subscription();\n        this.rtl = false;\n        validatePackage(packageMetadata);\n        this.subscriptions.add(this.localizationService.changes.subscribe(({ rtl }) => {\n            this.rtl = rtl;\n            this.direction = this.rtl ? 'rtl' : 'ltr';\n        }));\n    }\n    get errorClass() {\n        if (!this.control) {\n            return false;\n        }\n        return this.control.invalid && (this.control.touched || this.control.dirty);\n    }\n    get disabledClass() {\n        if (!this.control) {\n            return false;\n        }\n        // radiobutton group\n        if (this.isRadioControl(this.control)) {\n            return false;\n        }\n        return this.disabledControl() ||\n            this.disabledElement() ||\n            this.disabledKendoInput();\n    }\n    set formControls(formControls) {\n        this.validateFormControl(formControls);\n        this.control = formControls.first;\n    }\n    /**\n     * @hidden\n     */\n    get horizontal() {\n        return this.orientation === 'horizontal';\n    }\n    /**\n     * @hidden\n     */\n    get hasHints() {\n        return this.showHints === 'always' ? true : this.showHintsInitial();\n    }\n    /**\n     * @hidden\n     */\n    get hasErrors() {\n        return this.showErrors === 'always' ? true : this.showErrorsInitial();\n    }\n    ngAfterViewInit() {\n        this.setDescription();\n    }\n    ngOnDestroy() {\n        this.subscriptions.unsubscribe();\n    }\n    disabledKendoInput() {\n        return this.kendoInput && this.kendoInput.disabled;\n    }\n    disabledControl() {\n        return this.control.disabled;\n    }\n    disabledElement() {\n        const elements = this.controlElementRefs.toArray();\n        return elements.every(e => e.nativeElement.hasAttribute('disabled'));\n    }\n    validateFormControl(formControls) {\n        if (isDevMode() && formControls.length !== 1 && !this.isControlGroup(formControls)) {\n            throw new Error('The `kendo-formfield` component should contain ' +\n                'only one control of type NgControl with a formControlName(https://angular.io/api/forms/FormControlName)' +\n                'or an ngModel(https://angular.io/api/forms/NgModel) binding.');\n        }\n    }\n    isControlGroup(formControls) {\n        if (!formControls.length) {\n            return false;\n        }\n        const name = formControls.first.name;\n        return formControls.toArray().every(c => c.name === name && (this.isRadioControl(c)));\n    }\n    isRadioControl(control) {\n        return control.valueAccessor instanceof RadioControlValueAccessor;\n    }\n    updateDescription() {\n        const controls = this.findControlElements();\n        if (!controls) {\n            return;\n        }\n        controls.forEach((control) => {\n            if (this.errorChildren.length > 0 || this.hintChildren.length > 0) {\n                const ariaIds = this.generateDescriptionIds(control);\n                this.renderer.setAttribute(control, 'aria-describedby', ariaIds);\n            }\n        });\n    }\n    findControlElements() {\n        if (!this.controlElementRefs) {\n            return;\n        }\n        // if the control is KendoInput and has focusableId - dropdowns, dateinputs\n        if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {\n            return [this.hostElement.nativeElement.querySelector(`#${this.kendoInput.focusableId}`)];\n        }\n        return this.controlElementRefs.map(el => el.nativeElement);\n    }\n    generateDescriptionIds(control) {\n        const ids = new Set();\n        if (control.hasAttribute('aria-describedby')) {\n            const attributes = control.getAttribute('aria-describedby').split(' ');\n            attributes.forEach((attr) => {\n                if (attr.includes('kendo-hint-') || attr.includes('kendo-error-')) {\n                    return;\n                }\n                ids.add(attr);\n            });\n        }\n        this.hintChildren.forEach((hint) => {\n            ids.add(hint.id);\n        });\n        this.errorChildren.forEach((error) => {\n            ids.add(error.id);\n        });\n        return Array.from(ids).join(' ');\n    }\n    showHintsInitial() {\n        if (!this.control) {\n            return true;\n        }\n        const { valid, untouched, pristine } = this.control;\n        return valid || (untouched && pristine);\n    }\n    showErrorsInitial() {\n        if (!this.control) {\n            return false;\n        }\n        const { invalid, dirty, touched } = this.control;\n        return invalid && (dirty || touched);\n    }\n    setDescription() {\n        this.updateDescription();\n        this.subscriptions.add(this.errorChildren.changes.subscribe(() => this.updateDescription()));\n        this.subscriptions.add(this.hintChildren.changes.subscribe(() => this.updateDescription()));\n    }\n};\n__decorate([\n    HostBinding('class.k-form-field'),\n    __metadata(\"design:type\", Boolean)\n], FormFieldComponent.prototype, \"hostClass\", void 0);\n__decorate([\n    HostBinding('attr.dir'),\n    __metadata(\"design:type\", String)\n], FormFieldComponent.prototype, \"direction\", void 0);\n__decorate([\n    HostBinding('class.k-form-field-error'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], FormFieldComponent.prototype, \"errorClass\", null);\n__decorate([\n    HostBinding('class.k-form-field-disabled'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [])\n], FormFieldComponent.prototype, \"disabledClass\", null);\n__decorate([\n    ContentChildren(NgControl, { descendants: true }),\n    __metadata(\"design:type\", QueryList),\n    __metadata(\"design:paramtypes\", [QueryList])\n], FormFieldComponent.prototype, \"formControls\", null);\n__decorate([\n    ContentChildren(NgControl, { read: ElementRef, descendants: true }),\n    __metadata(\"design:type\", QueryList)\n], FormFieldComponent.prototype, \"controlElementRefs\", void 0);\n__decorate([\n    ContentChild(KendoInput, { static: true }),\n    __metadata(\"design:type\", Object)\n], FormFieldComponent.prototype, \"kendoInput\", void 0);\n__decorate([\n    ContentChildren(ErrorComponent, { descendants: true }),\n    __metadata(\"design:type\", QueryList)\n], FormFieldComponent.prototype, \"errorChildren\", void 0);\n__decorate([\n    ContentChildren(HintComponent, { descendants: true }),\n    __metadata(\"design:type\", QueryList)\n], FormFieldComponent.prototype, \"hintChildren\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], FormFieldComponent.prototype, \"showHints\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], FormFieldComponent.prototype, \"orientation\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], FormFieldComponent.prototype, \"showErrors\", void 0);\nFormFieldComponent = __decorate([\n    Component({\n        selector: 'kendo-formfield',\n        template: `\n        <ng-content select=\"label, kendo-label\"></ng-content>\n        <div [class.k-form-field-wrap]=\"horizontal\">\n            <ng-content></ng-content>\n            <ng-content select=\"kendo-formhint\" *ngIf=\"hasHints\"></ng-content>\n            <ng-content select=\"kendo-formerror\" *ngIf=\"hasErrors\"></ng-content>\n        </div>\n    `,\n        providers: [\n            LocalizationService,\n            {\n                provide: L10N_PREFIX,\n                useValue: 'kendo.formfield'\n            }\n        ]\n    }),\n    __metadata(\"design:paramtypes\", [Renderer2,\n        LocalizationService,\n        ElementRef])\n], FormFieldComponent);\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the FormField, Error and Hint components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the FormField module\n * import { FormFieldModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, FormFieldModule], // import FormField module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet FormFieldModule = class FormFieldModule {\n};\nFormFieldModule = __decorate([\n    NgModule({\n        declarations: [HintComponent, ErrorComponent, FormFieldComponent],\n        exports: [HintComponent, ErrorComponent, FormFieldComponent],\n        imports: [CommonModule]\n    })\n], FormFieldModule);\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Inputs components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Inputs module\n * import { InputsModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, InputsModule], // import Inputs module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nlet InputsModule = class InputsModule {\n};\nInputsModule = __decorate([\n    NgModule({\n        exports: [\n            TextAreaModule,\n            TextBoxModule,\n            SliderModule,\n            RangeSliderModule,\n            SwitchModule,\n            NumericTextBoxModule,\n            MaskedTextBoxModule,\n            ColorPickerModule,\n            CheckBoxModule,\n            RadioButtonModule,\n            FormFieldModule\n        ],\n        imports: [CommonModule]\n    })\n], InputsModule);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CheckBoxModule, ColorInputComponent, ContrastValidationComponent, ContrastComponent, FocusOnDomReadyDirective, ColorGradientLocalizationService, ColorPaletteLocalizationService, ColorPickerLocalizationService, ColorPickerCustomMessagesComponent, ColorPickerMessages, ColorPaletteService, MaskingService, NumericTextBoxMessages, RadioButtonModule, RangeSliderCustomMessagesComponent, RangeSliderMessages, SHARED_DIRECTIVES, SliderCustomMessagesComponent, SliderMessages, SliderBase, SlidersCommonModule, SwitchCustomMessagesComponent, Messages, TextFieldsBase, TextBoxCustomMessagesComponent, TextBoxMessages, SliderComponent, RangeSliderComponent, LabelTemplateDirective, SwitchComponent, TextBoxContainerComponent, TextBoxDirective, TextAreaDirective, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, MaskedTextBoxComponent, InputsModule, SliderTicksComponent, SliderModule, RangeSliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule, TextBoxModule, TextAreaModule, ColorPickerComponent, ColorPaletteComponent, ColorGradientComponent, ColorPickerModule, ActiveColorClickEvent, CheckBoxDirective, RadioButtonDirective, HintComponent, ErrorComponent, FormFieldComponent, FormFieldModule, TextBoxComponent, TextBoxPrefixTemplateDirective, TextBoxSuffixTemplateDirective, TextAreaComponent, TextAreaSuffixComponent, InputSeparatorComponent, SharedModule, LocalizedColorPickerMessagesDirective, LocalizedNumericTextBoxMessagesDirective, LocalizedTextBoxMessagesDirective, LocalizedSliderMessagesDirective, LocalizedRangeSliderMessagesDirective, LocalizedSwitchMessagesDirective };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4DAudC;qCACoC,AAG9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WA6KN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAqdA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDA8CiD,AA2F3C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAmcN;;;;;;;;;;;;;4DAa2D,AAkFrD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cA2QN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDA+EiD,AAwC3C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+CA0MN;;;;;;;;;;;;;;;;;;;;;;;;;sDAyBqD,AAW/C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAiMN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wCA6CuC,AAOjC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+EAyFN;;;;;;;;;;oDAUmD,AAO7C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAk5BN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kEA6GiE,AAyE3D;;;;;;;;;;;;;;;uHAcN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iHAsBA;8FAC6F,AAUvF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6cAwaN,CAAC,AAGiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAyclB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gEAqG+D,AA2CzD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAgEN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mCAqCkC,AAsB5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6OASN,CAAC,AAgBsB;;;;;;;yIAMvB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mGAuBA;oFACmF,AAS7E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iHAgBN;8EAC6E,AAUvE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0LAqCN,CAAC,AAgBe;;;;;;;wIAMhB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mGAmBA;8FAC6F,AASvF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iHAgBN;wFACuF,AAUjF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yMAqCN,CAAC,AAgBoB;;;;;;;+EAMrB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mGAmBA;oFACmF,AAS7E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iHAgBN;8EAC6E,AAUvE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uMAoCN,CAAC,AAee;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mGAWhB;oGACmG,AAS7F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2MAoCN,CAAC,AAcuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wMAkCxB,CAAC,AAOsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4DA0CvB;6CAC4C,AAGtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4DA0BN;6CAC4C,AAGtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAwdN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oDA+GmD,AA+D7C;;;;;;;;;;;;;;gFAaN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iHAkBA;gFAC+E,AAUzE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mGAaN;sFACqF,AAS/E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cA4CN;;;;2DAI0D,AAM/B;;;;;;;;;;;;;;;;;;;;;;;;;0IAa3B,CAAC,AAMe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oMAkChB,CAAC,AAyBgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WAoFjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAwZA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDA4DqD,AAuC/C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cA+CN;;;;2DAI0D,AAO/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uMAkC3B,CAAC,AAeiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cA6alB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAsCiC,AA+F3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAidN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gEA2F+D,AAkJzD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAmaN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4DA2G2D,AA0GrD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mKAgEN,CAAC,AAGsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2UAmVvB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8DA8F6D,AAuDvD;;;;;;;;;;;;;wnBAYN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iHAsEA;wFACuF,AAUjF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mGAaN;8FAC6F,AASvF;;;;;;;;;;;;;;;;;;;;;;;;;kKAkBN;uCACsC,AAGhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAqBN;;;;;;;;;;;;;0CAayC,AAcnC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cA6BN;;;;;;;;;gCAS+B,AAyBzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAsBN,CAAC,AAgBoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAwBrB;;;;sDAIqD,AAKhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2KAkCrB,CAAC,AAOiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAwBlB;;;;yDAIwD,AAKhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oLAkCxB,CAAC,AAOoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAqCrB;;;;;;;;;;;;;;;;;;;;;;;;;;;kDA2BiD,AAQ/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAkClB;;;;;;;;;;;;;;;;;;;;;;;iDAuBgD,AAQ/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAyLjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iCAoDgC,AAkB1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8KAsCN,CAAC,AAOkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qKAmCnB,CAAC,AAkBe;;;;;;;"}