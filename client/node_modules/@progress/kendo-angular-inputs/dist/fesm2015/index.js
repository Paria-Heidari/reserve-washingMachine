/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __param, __metadata } from 'tslib';
import { isDevMode, Directive, Optional, TemplateRef, EventEmitter, Input, Output, HostBinding, ViewChild, ElementRef, ContentChild, Component, forwardRef, Injector, Renderer2, NgZone, ChangeDetectorRef, Inject, Injectable, HostListener, ViewChildren, QueryList, NgModule, ViewContainerRef, ContentChildren } from '@angular/core';
import { NgControl, NG_VALUE_ACCESSOR, NG_VALIDATORS, RadioControlValueAccessor } from '@angular/forms';
import { Subscription, fromEvent, interval, merge, Observable, Subject } from 'rxjs';
import { take, filter, concatMap, startWith, takeUntil, skip, debounceTime, throttleTime } from 'rxjs/operators';
import { LocalizationService, L10N_PREFIX, RTL, ComponentMessages, MessageService } from '@progress/kendo-angular-l10n';
import { Keys, guid, hasObservers, anyChanged, isDocumentAvailable, KendoInput, isChanged, DraggableModule, EventsModule, ResizeSensorModule } from '@progress/kendo-angular-common';
import { validatePackage } from '@progress/kendo-licensing';
import { browser, mobileOS, detectDesktopBrowser, detectMobileOS } from '@progress/kendo-common';
import { IntlService } from '@progress/kendo-angular-intl';
import { CommonModule } from '@angular/common';
import { PopupService, PopupModule } from '@progress/kendo-angular-popup';
import { Color, parseColor, namedColors } from '@progress/kendo-drawing';

/**
 * @hidden
 *
 * Checks if the value is `null` or `undefined`. Falsy values like '', 0, false, NaN, etc. are regarded as present.
 */
import * as ɵngcc0 from '@angular/core';

const _c0 = ["wrap"];
const _c1 = ["track"];
const _c2 = ["sliderSelection"];
const _c3 = ["ticks"];
const _c4 = ["draghandle"];
const _c5 = ["decreaseButton"];
const _c6 = ["increaseButton"];
const _c7 = ["kendoSliderLocalizedMessages", "", 6, "increment", "decrement", "dragHandle"];
var I18N_8;
if (ngI18nClosureMode) {
    /**
     * @desc The title of the **Increase** button of the Slider.
     * @meaning kendo.slider.increment
     */ 
    const MSG_EXTERNAL_8302125540024939132$$DIST_FESM2015_INDEX_JS_9 = goog.getMsg("increment");
    I18N_8 = MSG_EXTERNAL_8302125540024939132$$DIST_FESM2015_INDEX_JS_9;
}
else {
    I18N_8 = ɵngcc0.ɵɵi18nLocalize("increment");
}
var I18N_10;
if (ngI18nClosureMode) {
    /**
     * @desc The title of the **Decrease** button of the Slider.
     * @meaning kendo.slider.decrement
     */ 
    const MSG_EXTERNAL_652458644240352212$$DIST_FESM2015_INDEX_JS_11 = goog.getMsg("decrement");
    I18N_10 = MSG_EXTERNAL_652458644240352212$$DIST_FESM2015_INDEX_JS_11;
}
else {
    I18N_10 = ɵngcc0.ɵɵi18nLocalize("decrement");
}
var I18N_12;
if (ngI18nClosureMode) {
    /**
     * @desc The title of the drag handle of the Slider.
     * @meaning kendo.slider.dragHandle
     */ 
    const MSG_EXTERNAL_9117416417579607469$$DIST_FESM2015_INDEX_JS_13 = goog.getMsg("Drag");
    I18N_12 = MSG_EXTERNAL_9117416417579607469$$DIST_FESM2015_INDEX_JS_13;
}
else {
    I18N_12 = ɵngcc0.ɵɵi18nLocalize("Drag");
}
const _c14 = ["increment", I18N_8, "decrement", I18N_10, "dragHandle", I18N_12];
const _c15 = [1, "k-slider-wrap", 3, "kendoEventsOutsideAngular"];
const _c16 = ["wrap", ""];
const _c17 = ["class", "k-button k-button-decrease", "role", "presentation", 3, "title", 4, "ngIf"];
const _c18 = ["class", "k-button k-button-increase", 3, "title", "click", 4, "ngIf"];
const _c19 = ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate", 4, "ngIf"];
const _c20 = [1, "k-slider-track"];
const _c21 = ["track", ""];
const _c22 = [1, "k-slider-selection"];
const _c23 = ["sliderSelection", ""];
const _c24 = ["role", "slider", "kendoDraggable", "", 1, "k-draghandle", 3, "title", "id", "kendoPress", "kendoDrag", "kendoRelease"];
const _c25 = ["draghandle", ""];
const _c26 = [3, "resize"];
const _c27 = ["role", "presentation", 1, "k-button", "k-button-decrease", 3, "title"];
const _c28 = ["decreaseButton", ""];
const _c29 = [1, "k-icon"];
function SliderComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", _c27, _c28);
    ɵngcc0.ɵɵelementStart(2, "span", _c29);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r11.decrementMessage);
    ɵngcc0.ɵɵselect(2);
    ɵngcc0.ɵɵclassProp("k-i-arrow-w", !ctx_r11.vertical);
    ɵngcc0.ɵɵclassProp("k-i-arrow-s", ctx_r11.vertical);
    ɵngcc0.ɵɵstylingApply();
} }
const _c30 = [1, "k-button", "k-button-increase", 3, "title", "click"];
const _c31 = ["increaseButton", ""];
function SliderComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    const _r20 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", _c30, _c31);
    ɵngcc0.ɵɵlistener("click", function SliderComponent_span_5_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r20); return $event.preventDefault(); });
    ɵngcc0.ɵɵelementStart(2, "span", _c29);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r12.incrementMessage);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r12.currentValue);
    ɵngcc0.ɵɵselect(2);
    ɵngcc0.ɵɵclassProp("k-i-arrow-e", !ctx_r12.vertical);
    ɵngcc0.ɵɵclassProp("k-i-arrow-n", ctx_r12.vertical);
    ɵngcc0.ɵɵstylingApply();
} }
const _c32 = ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate"];
const _c33 = ["ticks", ""];
function SliderComponent_ul_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", _c32, _c33);
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tickTitle", ctx_r13.title)("vertical", ctx_r13.vertical)("step", ctx_r13.smallStep)("largeStep", ctx_r13.largeStep)("min", ctx_r13.min)("max", ctx_r13.max)("labelTemplate", ctx_r13.labelTemplate == null ? null : ctx_r13.labelTemplate.templateRef);
    ɵngcc0.ɵɵattribute("aria-hidden", true);
} }
const _c34 = function (a0, a1) { return { click: a0, keydown: a1 }; };
const _c35 = ["draghandleStart"];
const _c36 = ["draghandleEnd"];
const _c37 = ["kendoSliderLocalizedMessages", "", 6, "dragHandleStart", "dragHandleEnd"];
var I18N_38;
if (ngI18nClosureMode) {
    /**
     * @desc The title of the **Start** drag handle of the Slider.
     * @meaning kendo.rangeslider.dragHandleStart
     */ 
    const MSG_EXTERNAL_1512034289801794423$$DIST_FESM2015_INDEX_JS_39 = goog.getMsg("Drag");
    I18N_38 = MSG_EXTERNAL_1512034289801794423$$DIST_FESM2015_INDEX_JS_39;
}
else {
    I18N_38 = ɵngcc0.ɵɵi18nLocalize("Drag");
}
var I18N_40;
if (ngI18nClosureMode) {
    /**
     * @desc The title of the **End** drag handle of the Slider.
     * @meaning kendo.rangeslider.dragHandleEnd
     */ 
    const MSG_EXTERNAL_6915505327582510906$$DIST_FESM2015_INDEX_JS_41 = goog.getMsg("Drag");
    I18N_40 = MSG_EXTERNAL_6915505327582510906$$DIST_FESM2015_INDEX_JS_41;
}
else {
    I18N_40 = ɵngcc0.ɵɵi18nLocalize("Drag");
}
const _c42 = ["dragHandleStart", I18N_38, "dragHandleEnd", I18N_40];
const _c43 = ["role", "slider", "kendoDraggable", "", 1, "k-draghandle", 3, "id", "title", "kendoPress", "kendoDrag", "kendoRelease"];
const _c44 = ["draghandleStart", ""];
const _c45 = ["draghandleEnd", ""];
function RangeSliderComponent_ul_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", _c32, _c33);
} if (rf & 2) {
    const ctx_r23 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tickTitle", ctx_r23.title)("vertical", ctx_r23.vertical)("step", ctx_r23.smallStep)("largeStep", ctx_r23.largeStep)("min", ctx_r23.min)("max", ctx_r23.max)("labelTemplate", ctx_r23.labelTemplate == null ? null : ctx_r23.labelTemplate.templateRef);
    ɵngcc0.ɵɵattribute("aria-hidden", true);
} }
const _c46 = ["wrapper"];
const _c47 = ["kendoSwitchLocalizedMessages", "", 6, "on", "off"];
var I18N_48;
if (ngI18nClosureMode) {
    /**
     * @desc The **On** label of the Switch.
     * @meaning kendo.switch.on
     */ 
    const MSG_EXTERNAL_818154782831456441$$DIST_FESM2015_INDEX_JS_49 = goog.getMsg("ON");
    I18N_48 = MSG_EXTERNAL_818154782831456441$$DIST_FESM2015_INDEX_JS_49;
}
else {
    I18N_48 = ɵngcc0.ɵɵi18nLocalize("ON");
}
var I18N_50;
if (ngI18nClosureMode) {
    /**
     * @desc The **Off** label of the Switch.
     * @meaning kendo.switch.off
     */ 
    const MSG_EXTERNAL_759820891948194060$$DIST_FESM2015_INDEX_JS_51 = goog.getMsg("OFF");
    I18N_50 = MSG_EXTERNAL_759820891948194060$$DIST_FESM2015_INDEX_JS_51;
}
else {
    I18N_50 = ɵngcc0.ɵɵi18nLocalize("OFF");
}
const _c52 = ["on", I18N_48, "off", I18N_50];
const _c53 = ["role", "switch", 1, "k-switch-container", 3, "id", "kendoEventsOutsideAngular"];
const _c54 = ["wrapper", ""];
const _c55 = [1, "k-switch-label-on"];
const _c56 = [1, "k-switch-label-off"];
const _c57 = [1, "k-switch-handle"];
const _c58 = function (a0, a1, a2, a3) { return { click: a0, keydown: a1, focus: a2, blur: a3 }; };
const _c59 = ["class", "k-label", 3, "for", 4, "ngIf"];
const _c60 = [1, "k-label", 3, "for"];
function TextBoxContainerComponent_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", _c60);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r30 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("for", ctx_r30.id);
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r30.floatingLabel);
} }
const _c61 = ["*"];
const _c62 = ["numericInput"];
const _c63 = ["numericWrap"];
const _c64 = ["kendoNumericTextBoxLocalizedMessages", "", 6, "increment", "decrement"];
var I18N_65;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the **Increment** button in the NumericTextBox
     * @meaning kendo.numerictextbox.increment
     */ 
    const MSG_EXTERNAL_4467784268438010275$$DIST_FESM2015_INDEX_JS_66 = goog.getMsg("Increase value");
    I18N_65 = MSG_EXTERNAL_4467784268438010275$$DIST_FESM2015_INDEX_JS_66;
}
else {
    I18N_65 = ɵngcc0.ɵɵi18nLocalize("Increase value");
}
var I18N_67;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the **Decrement** button in the NumericTextBox
     * @meaning kendo.numerictextbox.decrement
     */ 
    const MSG_EXTERNAL_3960022057994897997$$DIST_FESM2015_INDEX_JS_68 = goog.getMsg("Decrease value");
    I18N_67 = MSG_EXTERNAL_3960022057994897997$$DIST_FESM2015_INDEX_JS_68;
}
else {
    I18N_67 = ɵngcc0.ɵɵi18nLocalize("Decrease value");
}
const _c69 = ["increment", I18N_65, "decrement", I18N_67];
const _c70 = [1, "k-numeric-wrap", 3, "kendoEventsOutsideAngular"];
const _c71 = ["numericWrap", ""];
const _c72 = ["role", "spinbutton", "autocomplete", "off", "autocorrect", "off", 1, "k-input", "k-formatted-value", 3, "id", "tabindex", "disabled", "readonly", "kendoEventsOutsideAngular"];
const _c73 = ["numericInput", ""];
const _c74 = ["class", "k-select", 3, "kendoEventsOutsideAngular", 4, "ngIf"];
const _c75 = [1, "k-select", 3, "kendoEventsOutsideAngular"];
const _c76 = ["role", "button", 1, "k-link", "k-link-increase", 3, "kendoEventsOutsideAngular", "title"];
const _c77 = [1, "k-icon", "k-i-arrow-n"];
const _c78 = ["role", "button", 1, "k-link", "k-link-decrease", 3, "kendoEventsOutsideAngular", "title"];
const _c79 = [1, "k-icon", "k-i-arrow-s"];
const _c80 = function (a0, a1) { return { mouseup: a0, mouseleave: a1 }; };
const _c81 = function (a0) { return { mousedown: a0 }; };
function NumericTextBoxComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", _c75);
    ɵngcc0.ɵɵelementStart(1, "span", _c76);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵelement(2, "span", _c77);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "span", _c78);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵelement(4, "span", _c79);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r33 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(9, _c80, ctx_r33.releaseArrow, ctx_r33.releaseArrow));
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵclassProp("k-state-active", ctx_r33.arrowDirection === ctx_r33.ArrowDirection.Up);
    ɵngcc0.ɵɵstylingApply();
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(12, _c81, ctx_r33.increasePress))("title", ctx_r33.incrementTitle);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r33.incrementTitle);
    ɵngcc0.ɵɵselect(3);
    ɵngcc0.ɵɵclassProp("k-state-active", ctx_r33.arrowDirection === ctx_r33.ArrowDirection.Down);
    ɵngcc0.ɵɵstylingApply();
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(14, _c81, ctx_r33.decreasePress))("title", ctx_r33.decrementTitle);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r33.decrementTitle);
} }
const _c82 = function (a0, a1) { return { mousewheel: a0, DOMMouseScroll: a1 }; };
const _c83 = function (a0, a1, a2, a3, a4, a5, a6) { return { mousedown: a0, dragenter: a1, keydown: a2, input: a3, focus: a4, blur: a5, paste: a6 }; };
const _c84 = ["input"];
const _c85 = ["type", "text", "autocomplete", "off", "autocorrect", "off", "autocapitalize", "off", "spellcheck", "false", 1, "k-textbox", 3, "id", "tabindex", "disabled", "readonly", "kendoEventsOutsideAngular"];
const _c86 = ["input", ""];
const _c87 = function (a0, a1, a2, a3, a4) { return { focus: a0, blur: a1, click: a2, dragstart: a3, drop: a4 }; };
const _c88 = ["tickElement"];
const _c89 = ["kendoSliderTicks", ""];
const _c90 = ["role", "presentation", 3, "ngClass", "title", 4, "ngFor", "ngForOf"];
const _c91 = ["defaultLabel", ""];
const _c92 = ["role", "presentation", 3, "ngClass", "title"];
const _c93 = ["tickElement", ""];
const _c94 = [3, "ngSwitch"];
const _c95 = ["class", "k-label", 4, "ngSwitchCase"];
const _c96 = [4, "ngSwitchCase"];
const _c97 = [1, "k-label"];
const _c98 = [3, "ngTemplateOutlet", "ngTemplateOutletContext"];
function SliderTicksComponent_li_0_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", _c97);
    ɵngcc0.ɵɵelementContainer(1, _c98);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tick_r38 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r40 = ɵngcc0.ɵɵnextContext();
    const _r36 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r40.labelTemplate || _r36)("ngTemplateOutletContext", tick_r38);
} }
function SliderTicksComponent_li_0_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1, "\u00A0");
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SliderTicksComponent_li_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", _c92, _c93);
    ɵngcc0.ɵɵelementContainerStart(2, _c94);
    ɵngcc0.ɵɵtemplate(3, SliderTicksComponent_li_0_span_3_Template, 2, 2, "span", _c95);
    ɵngcc0.ɵɵtemplate(4, SliderTicksComponent_li_0_ng_container_4_Template, 2, 0, "ng-container", _c96);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tick_r38 = ctx.$implicit;
    const ctx_r35 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵpropertyInterpolate("title", ctx_r35.tickTitle(tick_r38.value));
    ɵngcc0.ɵɵproperty("ngClass", tick_r38.classes);
    ɵngcc0.ɵɵselect(2);
    ɵngcc0.ɵɵproperty("ngSwitch", tick_r38.large);
    ɵngcc0.ɵɵselect(3);
    ɵngcc0.ɵɵproperty("ngSwitchCase", true);
    ɵngcc0.ɵɵselect(4);
    ɵngcc0.ɵɵproperty("ngSwitchCase", false);
} }
function SliderTicksComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const value_r43 = ctx.value;
    const ctx_r37 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r37.tickTitle(value_r43), " ");
} }
const _c99 = ["kendoTextBoxLocalizedMessages", "", 6, "clear"];
var I18N_100;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the **Clear** button in the TextBox.
     * @meaning kendo.textbox.clear
     */ 
    const MSG_EXTERNAL_2651889799249671820$$DIST_FESM2015_INDEX_JS_101 = goog.getMsg("Clear");
    I18N_100 = MSG_EXTERNAL_2651889799249671820$$DIST_FESM2015_INDEX_JS_101;
}
else {
    I18N_100 = ɵngcc0.ɵɵi18nLocalize("Clear");
}
const _c102 = ["clear", I18N_100];
const _c103 = [1, "k-input-prefix"];
const _c104 = [4, "ngIf"];
const _c105 = [1, "k-input", 3, "id", "disabled", "readonly", "value", "kendoEventsOutsideAngular"];
const _c106 = [1, "k-input-suffix"];
const _c107 = [3, "ngClass", 4, "ngIf"];
const _c108 = ["role", "button", "class", "k-clear-value", 3, "tabindex", "title", "click", "mousedown", "keydown.enter", "keydown.space", 4, "ngIf"];
const _c109 = [3, "ngTemplateOutlet"];
function TextBoxComponent_3_ng_template_0_Template(rf, ctx) { }
function TextBoxComponent_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TextBoxComponent_3_ng_template_0_Template, 0, 0, "ng-template", _c109);
} if (rf & 2) {
    const ctx_r44 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r44.prefixTemplate == null ? null : ctx_r44.prefixTemplate.templateRef);
} }
const _c110 = [3, "ngClass"];
function TextBoxComponent_span_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", _c110);
} if (rf & 2) {
    const ctx_r46 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r46.errorIconClasses);
} }
function TextBoxComponent_span_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", _c110);
} if (rf & 2) {
    const ctx_r47 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r47.successIconClasses);
} }
const _c111 = ["role", "button", 1, "k-clear-value", 3, "tabindex", "title", "click", "mousedown", "keydown.enter", "keydown.space"];
function TextBoxComponent_span_9_Template(rf, ctx) { if (rf & 1) {
    const _r52 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", _c111);
    ɵngcc0.ɵɵlistener("click", function TextBoxComponent_span_9_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r52); const ctx_r51 = ɵngcc0.ɵɵnextContext(); return ctx_r51.clearValue(); });
    ɵngcc0.ɵɵlistener("mousedown", function TextBoxComponent_span_9_Template_span_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r52); return $event.preventDefault(); });
    ɵngcc0.ɵɵlistener("keydown.enter", function TextBoxComponent_span_9_Template_span_keydown_enter_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r52); const ctx_r54 = ɵngcc0.ɵɵnextContext(); return ctx_r54.clearValue($event); });
    ɵngcc0.ɵɵlistener("keydown.space", function TextBoxComponent_span_9_Template_span_keydown_space_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r52); const ctx_r55 = ɵngcc0.ɵɵnextContext(); return ctx_r55.clearValue($event); });
    ɵngcc0.ɵɵelement(1, "span", _c110);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r48 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tabindex", ctx_r48.tabIndex)("title", ctx_r48.clearTitle());
    ɵngcc0.ɵɵattribute("aria-label", ctx_r48.clearTitle());
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r48.clearButtonClasses);
} }
function TextBoxComponent_10_ng_template_0_Template(rf, ctx) { }
function TextBoxComponent_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TextBoxComponent_10_ng_template_0_Template, 0, 0, "ng-template", _c109);
} if (rf & 2) {
    const ctx_r49 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r49.suffixTemplate == null ? null : ctx_r49.suffixTemplate.templateRef);
} }
const _c112 = function (a0, a1, a2) { return { focus: a0, blur: a1, input: a2 }; };
const _c113 = [1, "k-input", 3, "ngClass", "id", "value", "disabled", "readonly", "kendoEventsOutsideAngular"];
const _c114 = [[["kendo-textarea-suffix"]]];
const _c115 = ["kendo-textarea-suffix"];
const _c116 = ["opacityInput"];
const _c117 = ["toggleFormatButton"];
const _c118 = [1, "k-vstack"];
const _c119 = [1, "k-colorgradient-toggle-mode", "k-button", "k-icon-button", "k-flat"];
const _c120 = ["toggleFormatButton", ""];
const _c121 = [1, "k-button-icon", "k-icon", "k-i-arrows-kpi"];
const _c122 = ["class", "k-textbox k-hex-value", 3, "disabled", "readonly", "value", "placeholder", "blur", "input", 4, "ngIf"];
const _c123 = [1, "k-textbox", "k-hex-value", 3, "disabled", "readonly", "value", "placeholder", "blur", "input"];
const _c124 = ["hexInput", ""];
function ColorInputComponent_input_4_Template(rf, ctx) { if (rf & 1) {
    const _r63 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "input", _c123, _c124);
    ɵngcc0.ɵɵlistener("blur", function ColorInputComponent_input_4_Template_input_blur_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r63); const ctx_r62 = ɵngcc0.ɵɵnextContext(); return ctx_r62.handleHexInputBlur(); });
    ɵngcc0.ɵɵlistener("input", function ColorInputComponent_input_4_Template_input_input_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r63); const _r61 = ɵngcc0.ɵɵreference(1); const ctx_r64 = ɵngcc0.ɵɵnextContext(); return ctx_r64.handleHexValueChange(_r61.value); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r59 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r59.disabled)("readonly", ctx_r59.readonly)("value", ctx_r59.hex || "")("placeholder", ctx_r59.textFor("hexInputPlaceholder"));
} }
const _c125 = [3, "disabled", "readonly", "min", "max", "placeholder", "value", "autoCorrect", "spinners", "format", "decimals", "valueChange", "blur"];
const _c126 = ["red", ""];
const _c127 = [1, "k-colorgradient-input-label", 3, "for"];
const _c128 = ["green", ""];
const _c129 = ["blue", ""];
const _c130 = ["class", "k-vstack", 4, "ngIf"];
const _c131 = [3, "disabled", "readonly", "min", "max", "placeholder", "value", "autoCorrect", "spinners", "step", "format", "decimals", "valueChange", "blur"];
const _c132 = ["opacityInput", "", "alpha", ""];
function ColorInputComponent_ng_container_5_div_16_Template(rf, ctx) { if (rf & 1) {
    const _r72 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", _c118);
    ɵngcc0.ɵɵelementStart(1, "kendo-numerictextbox", _c131, _c132);
    ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_ng_container_5_div_16_Template_kendo_numerictextbox_valueChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r72); const ctx_r71 = ɵngcc0.ɵɵnextContext(2); return ctx_r71.rgba.a = $event; });
    ɵngcc0.ɵɵlistener("blur", function ColorInputComponent_ng_container_5_div_16_Template_kendo_numerictextbox_blur_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r72); const ctx_r73 = ɵngcc0.ɵɵnextContext(2); return ctx_r73.handleRgbaInputBlur(); });
    ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_ng_container_5_div_16_Template_kendo_numerictextbox_valueChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r72); const ctx_r74 = ɵngcc0.ɵɵnextContext(2); return ctx_r74.handleRgbaValueChange(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "label", _c127);
    ɵngcc0.ɵɵtext(5, "A");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r70 = ɵngcc0.ɵɵreference(3);
    const ctx_r68 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵproperty("disabled", ctx_r68.disabled)("readonly", ctx_r68.readonly)("min", 0)("max", 1)("placeholder", ctx_r68.textFor("alphaInputPlaceholder"))("value", ctx_r68.rgba.a)("autoCorrect", true)("spinners", false)("step", 0.01)("format", "n2")("decimals", 2);
    ɵngcc0.ɵɵselect(4);
    ɵngcc0.ɵɵproperty("for", _r70.focusableId);
} }
function ColorInputComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    const _r76 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", _c118);
    ɵngcc0.ɵɵelementStart(2, "kendo-numerictextbox", _c125, _c126);
    ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r76); const ctx_r75 = ɵngcc0.ɵɵnextContext(); return ctx_r75.rgba.r = $event; });
    ɵngcc0.ɵɵlistener("blur", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_blur_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r76); const ctx_r77 = ɵngcc0.ɵɵnextContext(); return ctx_r77.handleRgbaInputBlur(); });
    ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r76); const ctx_r78 = ɵngcc0.ɵɵnextContext(); return ctx_r78.handleRgbaValueChange(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "label", _c127);
    ɵngcc0.ɵɵtext(5, "R");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "div", _c118);
    ɵngcc0.ɵɵelementStart(7, "kendo-numerictextbox", _c125, _c128);
    ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r76); const ctx_r79 = ɵngcc0.ɵɵnextContext(); return ctx_r79.rgba.g = $event; });
    ɵngcc0.ɵɵlistener("blur", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_blur_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r76); const ctx_r80 = ɵngcc0.ɵɵnextContext(); return ctx_r80.handleRgbaInputBlur(); });
    ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r76); const ctx_r81 = ɵngcc0.ɵɵnextContext(); return ctx_r81.handleRgbaValueChange(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "label", _c127);
    ɵngcc0.ɵɵtext(10, "G");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(11, "div", _c118);
    ɵngcc0.ɵɵelementStart(12, "kendo-numerictextbox", _c125, _c129);
    ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_12_listener($event) { ɵngcc0.ɵɵrestoreView(_r76); const ctx_r82 = ɵngcc0.ɵɵnextContext(); return ctx_r82.rgba.b = $event; });
    ɵngcc0.ɵɵlistener("blur", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_blur_12_listener($event) { ɵngcc0.ɵɵrestoreView(_r76); const ctx_r83 = ɵngcc0.ɵɵnextContext(); return ctx_r83.handleRgbaInputBlur(); });
    ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_12_listener($event) { ɵngcc0.ɵɵrestoreView(_r76); const ctx_r84 = ɵngcc0.ɵɵnextContext(); return ctx_r84.handleRgbaValueChange(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(14, "label", _c127);
    ɵngcc0.ɵɵtext(15, "B");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(16, ColorInputComponent_ng_container_5_div_16_Template, 6, 12, "div", _c130);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const _r65 = ɵngcc0.ɵɵreference(3);
    const _r66 = ɵngcc0.ɵɵreference(8);
    const _r67 = ɵngcc0.ɵɵreference(13);
    const ctx_r60 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵselect(2);
    ɵngcc0.ɵɵproperty("disabled", ctx_r60.disabled)("readonly", ctx_r60.readonly)("min", 0)("max", 255)("placeholder", ctx_r60.textFor("redInputPlaceholder"))("value", ctx_r60.rgba.r)("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
    ɵngcc0.ɵɵselect(4);
    ɵngcc0.ɵɵproperty("for", _r65.focusableId);
    ɵngcc0.ɵɵselect(7);
    ɵngcc0.ɵɵproperty("disabled", ctx_r60.disabled)("readonly", ctx_r60.readonly)("min", 0)("max", 255)("placeholder", ctx_r60.textFor("greenInputPlaceholder"))("value", ctx_r60.rgba.g)("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
    ɵngcc0.ɵɵselect(9);
    ɵngcc0.ɵɵproperty("for", _r66.focusableId);
    ɵngcc0.ɵɵselect(12);
    ɵngcc0.ɵɵproperty("disabled", ctx_r60.disabled)("readonly", ctx_r60.readonly)("min", 0)("max", 255)("placeholder", ctx_r60.textFor("blueInputPlaceholder"))("value", ctx_r60.rgba.b)("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
    ɵngcc0.ɵɵselect(14);
    ɵngcc0.ɵɵproperty("for", _r67.focusableId);
    ɵngcc0.ɵɵselect(16);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r60.opacity);
} }
const _c133 = ["gradientDragHandle"];
const _c134 = ["inputs"];
const _c135 = ["alphaSlider"];
const _c136 = ["gradientWrapper"];
const _c137 = ["kendoColorGradientLocalizedMessages", "", 6, "colorGradientNoColor", "colorGradientHandle", "clearButton", "hueSliderHandle", "opacitySliderHandle", "hexInputPlaceholder", "redInputPlaceholder", "greenInputPlaceholder", "blueInputPlaceholder", "alphaInputPlaceholder", "passContrast", "failContrast", "contrastRatio"];
var I18N_138;
if (ngI18nClosureMode) {
    /**
     * @desc The aria-label applied to the ColorGradient component when the value is empty.
     * @meaning kendo.colorgradient.colorGradientNoColor
     */ 
    const MSG_EXTERNAL_3796155240301823948$$DIST_FESM2015_INDEX_JS_139 = goog.getMsg("Colorgradient no color chosen");
    I18N_138 = MSG_EXTERNAL_3796155240301823948$$DIST_FESM2015_INDEX_JS_139;
}
else {
    I18N_138 = ɵngcc0.ɵɵi18nLocalize("Colorgradient no color chosen");
}
var I18N_140;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the gradient color drag handle chooser.
     * @meaning kendo.colorgradient.colorGradientHandle
     */ 
    const MSG_EXTERNAL_8537406358423916512$$DIST_FESM2015_INDEX_JS_141 = goog.getMsg("Choose color");
    I18N_140 = MSG_EXTERNAL_8537406358423916512$$DIST_FESM2015_INDEX_JS_141;
}
else {
    I18N_140 = ɵngcc0.ɵɵi18nLocalize("Choose color");
}
var I18N_142;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the clear button.
     * @meaning kendo.colorgradient.clearButton
     */ 
    const MSG_EXTERNAL_7605097752673642325$$DIST_FESM2015_INDEX_JS_143 = goog.getMsg("Clear value");
    I18N_142 = MSG_EXTERNAL_7605097752673642325$$DIST_FESM2015_INDEX_JS_143;
}
else {
    I18N_142 = ɵngcc0.ɵɵi18nLocalize("Clear value");
}
var I18N_144;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the hue slider handle.
     * @meaning kendo.colorgradient.hueSliderHandle
     */ 
    const MSG_EXTERNAL_8568799441668530127$$DIST_FESM2015_INDEX_JS_145 = goog.getMsg("Set hue");
    I18N_144 = MSG_EXTERNAL_8568799441668530127$$DIST_FESM2015_INDEX_JS_145;
}
else {
    I18N_144 = ɵngcc0.ɵɵi18nLocalize("Set hue");
}
var I18N_146;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the opacity slider handle.
     * @meaning kendo.colorgradient.opacitySliderHandle
     */ 
    const MSG_EXTERNAL_2665102430468067218$$DIST_FESM2015_INDEX_JS_147 = goog.getMsg("Set opacity");
    I18N_146 = MSG_EXTERNAL_2665102430468067218$$DIST_FESM2015_INDEX_JS_147;
}
else {
    I18N_146 = ɵngcc0.ɵɵi18nLocalize("Set opacity");
}
var I18N_148;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the HEX color input.
     * @meaning kendo.colorgradient.hexInputPlaceholder
     */ 
    const MSG_EXTERNAL_1551996638068326100$$DIST_FESM2015_INDEX_JS_149 = goog.getMsg("HEX Color");
    I18N_148 = MSG_EXTERNAL_1551996638068326100$$DIST_FESM2015_INDEX_JS_149;
}
else {
    I18N_148 = ɵngcc0.ɵɵi18nLocalize("HEX Color");
}
var I18N_150;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the red color input.
     * @meaning kendo.colorgradient.redInputPlaceholder
     */ 
    const MSG_EXTERNAL_865798719701025148$$DIST_FESM2015_INDEX_JS_151 = goog.getMsg("Red");
    I18N_150 = MSG_EXTERNAL_865798719701025148$$DIST_FESM2015_INDEX_JS_151;
}
else {
    I18N_150 = ɵngcc0.ɵɵi18nLocalize("Red");
}
var I18N_152;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the green color input.
     * @meaning kendo.colorgradient.greenInputPlaceholder
     */ 
    const MSG_EXTERNAL_7119549617208224702$$DIST_FESM2015_INDEX_JS_153 = goog.getMsg("Green");
    I18N_152 = MSG_EXTERNAL_7119549617208224702$$DIST_FESM2015_INDEX_JS_153;
}
else {
    I18N_152 = ɵngcc0.ɵɵi18nLocalize("Green");
}
var I18N_154;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the blue color input.
     * @meaning kendo.colorgradient.blueInputPlaceholder
     */ 
    const MSG_EXTERNAL_8925567330503382499$$DIST_FESM2015_INDEX_JS_155 = goog.getMsg("Blue");
    I18N_154 = MSG_EXTERNAL_8925567330503382499$$DIST_FESM2015_INDEX_JS_155;
}
else {
    I18N_154 = ɵngcc0.ɵɵi18nLocalize("Blue");
}
var I18N_156;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the alpha input.
     * @meaning kendo.colorgradient.alphaInputPlaceholder
     */ 
    const MSG_EXTERNAL_6303797935938211585$$DIST_FESM2015_INDEX_JS_157 = goog.getMsg("Alpha");
    I18N_156 = MSG_EXTERNAL_6303797935938211585$$DIST_FESM2015_INDEX_JS_157;
}
else {
    I18N_156 = ɵngcc0.ɵɵi18nLocalize("Alpha");
}
var I18N_158;
if (ngI18nClosureMode) {
    /**
     * @desc The pass message for the contrast tool.
     * @meaning kendo.colorgradient.passContrast
     */ 
    const MSG_EXTERNAL_200461871469242251$$DIST_FESM2015_INDEX_JS_159 = goog.getMsg("Pass");
    I18N_158 = MSG_EXTERNAL_200461871469242251$$DIST_FESM2015_INDEX_JS_159;
}
else {
    I18N_158 = ɵngcc0.ɵɵi18nLocalize("Pass");
}
var I18N_160;
if (ngI18nClosureMode) {
    /**
     * @desc The fail message for the contrast tool.
     * @meaning kendo.colorgradient.failContrast
     */ 
    const MSG_EXTERNAL_2780397365913372676$$DIST_FESM2015_INDEX_JS_161 = goog.getMsg("Fail");
    I18N_160 = MSG_EXTERNAL_2780397365913372676$$DIST_FESM2015_INDEX_JS_161;
}
else {
    I18N_160 = ɵngcc0.ɵɵi18nLocalize("Fail");
}
var I18N_162;
if (ngI18nClosureMode) {
    /**
     * @desc The contrast ratio message for the contrast tool.
     * @meaning kendo.colorgradient.contrastRatio
     */ 
    const MSG_EXTERNAL_713630549826115578$$DIST_FESM2015_INDEX_JS_163 = goog.getMsg("Contrast ratio");
    I18N_162 = MSG_EXTERNAL_713630549826115578$$DIST_FESM2015_INDEX_JS_163;
}
else {
    I18N_162 = ɵngcc0.ɵɵi18nLocalize("Contrast ratio");
}
const _c164 = ["colorGradientNoColor", I18N_138, "colorGradientHandle", I18N_140, "clearButton", I18N_142, "hueSliderHandle", I18N_144, "opacitySliderHandle", I18N_146, "hexInputPlaceholder", I18N_148, "redInputPlaceholder", I18N_150, "greenInputPlaceholder", I18N_152, "blueInputPlaceholder", I18N_154, "alphaInputPlaceholder", I18N_156, "passContrast", I18N_158, "failContrast", I18N_160, "contrastRatio", I18N_162];
const _c165 = [1, "k-colorgradient-canvas", "k-hstack"];
const _c166 = [1, "k-hsv-rectangle"];
const _c167 = ["kendoDraggable", "", 1, "k-hsv-gradient", 3, "click", "kendoPress", "kendoDrag", "kendoRelease"];
const _c168 = ["gradientWrapper", ""];
const _c169 = ["tabindex", "0", 1, "k-hsv-draghandle", "k-draghandle"];
const _c170 = ["gradientDragHandle", ""];
const _c171 = ["class", "k-clear-color k-button k-flat k-button-icon", "tabindex", "0", 3, "click", "keydown.enter", "keydown.space", 4, "ngIf"];
const _c172 = [1, "k-hue-slider", "k-colorgradient-slider", 3, "ngClass", "dragHandleTitle", "disabled", "readonly", "showButtons", "tickPlacement", "vertical", "min", "max", "smallStep", "largeStep", "value", "valueChange"];
const _c173 = ["class", "k-alpha-slider k-colorgradient-slider", 3, "ngClass", "dragHandleTitle", "disabled", "readonly", "showButtons", "tickPlacement", "vertical", "min", "max", "smallStep", "largeStep", "value", "valueChange", 4, "ngIf"];
const _c174 = [3, "opacity", "formatView", "value", "disabled", "readonly", "valueChange"];
const _c175 = ["inputs", ""];
const _c176 = ["class", "k-colorgradient-color-contrast k-vbox", "kendoContrastTool", "", 3, "value", "ratio", 4, "ngIf"];
const _c177 = ["tabindex", "0", 1, "k-clear-color", "k-button", "k-flat", "k-button-icon", 3, "click", "keydown.enter", "keydown.space"];
const _c178 = [1, "k-icon", "k-i-reset-color"];
function ColorGradientComponent_span_9_Template(rf, ctx) { if (rf & 1) {
    const _r92 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", _c177);
    ɵngcc0.ɵɵlistener("click", function ColorGradientComponent_span_9_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r92); const ctx_r91 = ɵngcc0.ɵɵnextContext(); return ctx_r91.reset(); });
    ɵngcc0.ɵɵlistener("keydown.enter", function ColorGradientComponent_span_9_Template_span_keydown_enter_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r92); const ctx_r93 = ɵngcc0.ɵɵnextContext(); return ctx_r93.reset(); });
    ɵngcc0.ɵɵlistener("keydown.space", function ColorGradientComponent_span_9_Template_span_keydown_space_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r92); const ctx_r94 = ɵngcc0.ɵɵnextContext(); return ctx_r94.reset(); });
    ɵngcc0.ɵɵelement(1, "span", _c178);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r87 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r87.clearButtonTitle)("title", ctx_r87.clearButtonTitle);
} }
const _c179 = [1, "k-alpha-slider", "k-colorgradient-slider", 3, "ngClass", "dragHandleTitle", "disabled", "readonly", "showButtons", "tickPlacement", "vertical", "min", "max", "smallStep", "largeStep", "value", "valueChange"];
const _c180 = ["alphaSlider", ""];
const _c181 = function (a0) { return { "k-align-self-end": a0 }; };
function ColorGradientComponent_kendo_slider_11_Template(rf, ctx) { if (rf & 1) {
    const _r97 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-slider", _c179, _c180);
    ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_kendo_slider_11_Template_kendo_slider_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r97); const ctx_r96 = ɵngcc0.ɵɵnextContext(); return ctx_r96.handleAlphaSliderChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r88 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(12, _c181, ctx_r88.clearButton))("dragHandleTitle", ctx_r88.opacitySliderTitle)("disabled", ctx_r88.disabled)("readonly", ctx_r88.readonly)("showButtons", false)("tickPlacement", "none")("vertical", true)("min", 0)("max", 100)("smallStep", 1)("largeStep", 10)("value", ctx_r88.alphaSliderValue);
} }
const _c182 = ["kendoContrastTool", "", 1, "k-colorgradient-color-contrast", "k-vbox", 3, "value", "ratio"];
function ColorGradientComponent_div_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", _c182);
} if (rf & 2) {
    const ctx_r90 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", ctx_r90.value)("ratio", ctx_r90.contrastTool);
} }
const _c183 = ["palette"];
const _c184 = ["container"];
const _c185 = ["popupTemplate"];
const _c186 = ["colorGradient"];
const _c187 = ["kendoColorPickerLocalizedMessages", "", "colorGradientNoColor", "Colorgradient no color chosen", "colorPaletteNoColor", "Colorpalette no color chosen", 6, "colorGradientHandle", "clearButton", "hueSliderHandle", "opacitySliderHandle", "hexInputPlaceholder", "redInputPlaceholder", "greenInputPlaceholder", "blueInputPlaceholder", "alphaInputPlaceholder"];
var I18N_188;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the gradient color drag handle chooser.
     * @meaning kendo.colorpicker.colorGradientHandle
     */ 
    const MSG_EXTERNAL_8067778471922495440$$DIST_FESM2015_INDEX_JS_189 = goog.getMsg("Choose color");
    I18N_188 = MSG_EXTERNAL_8067778471922495440$$DIST_FESM2015_INDEX_JS_189;
}
else {
    I18N_188 = ɵngcc0.ɵɵi18nLocalize("Choose color");
}
var I18N_190;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the clear button.
     * @meaning kendo.colorpicker.clearButton
     */ 
    const MSG_EXTERNAL_935472034136733879$$DIST_FESM2015_INDEX_JS_191 = goog.getMsg("Clear value");
    I18N_190 = MSG_EXTERNAL_935472034136733879$$DIST_FESM2015_INDEX_JS_191;
}
else {
    I18N_190 = ɵngcc0.ɵɵi18nLocalize("Clear value");
}
var I18N_192;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the hue slider handle.
     * @meaning kendo.colorpicker.hueSliderHandle
     */ 
    const MSG_EXTERNAL_1739045502529621844$$DIST_FESM2015_INDEX_JS_193 = goog.getMsg("Set hue");
    I18N_192 = MSG_EXTERNAL_1739045502529621844$$DIST_FESM2015_INDEX_JS_193;
}
else {
    I18N_192 = ɵngcc0.ɵɵi18nLocalize("Set hue");
}
var I18N_194;
if (ngI18nClosureMode) {
    /**
     * @desc The title for the opacity slider handle.
     * @meaning kendo.colorpicker.opacitySliderHandle
     */ 
    const MSG_EXTERNAL_1818720388700598438$$DIST_FESM2015_INDEX_JS_195 = goog.getMsg("Set opacity");
    I18N_194 = MSG_EXTERNAL_1818720388700598438$$DIST_FESM2015_INDEX_JS_195;
}
else {
    I18N_194 = ɵngcc0.ɵɵi18nLocalize("Set opacity");
}
var I18N_196;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the HEX color input.
     * @meaning kendo.colorpicker.hexInputPlaceholder
     */ 
    const MSG_EXTERNAL_67581802130075115$$DIST_FESM2015_INDEX_JS_197 = goog.getMsg("HEX Color");
    I18N_196 = MSG_EXTERNAL_67581802130075115$$DIST_FESM2015_INDEX_JS_197;
}
else {
    I18N_196 = ɵngcc0.ɵɵi18nLocalize("HEX Color");
}
var I18N_198;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the red color input.
     * @meaning kendo.colorpicker.redInputPlaceholder
     */ 
    const MSG_EXTERNAL_1242921922786989001$$DIST_FESM2015_INDEX_JS_199 = goog.getMsg("Red");
    I18N_198 = MSG_EXTERNAL_1242921922786989001$$DIST_FESM2015_INDEX_JS_199;
}
else {
    I18N_198 = ɵngcc0.ɵɵi18nLocalize("Red");
}
var I18N_200;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the green color input.
     * @meaning kendo.colorpicker.greenInputPlaceholder
     */ 
    const MSG_EXTERNAL_564969508273982379$$DIST_FESM2015_INDEX_JS_201 = goog.getMsg("Green");
    I18N_200 = MSG_EXTERNAL_564969508273982379$$DIST_FESM2015_INDEX_JS_201;
}
else {
    I18N_200 = ɵngcc0.ɵɵi18nLocalize("Green");
}
var I18N_202;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the blue color input.
     * @meaning kendo.colorpicker.blueInputPlaceholder
     */ 
    const MSG_EXTERNAL_2815824305218491249$$DIST_FESM2015_INDEX_JS_203 = goog.getMsg("Blue");
    I18N_202 = MSG_EXTERNAL_2815824305218491249$$DIST_FESM2015_INDEX_JS_203;
}
else {
    I18N_202 = ɵngcc0.ɵɵi18nLocalize("Blue");
}
var I18N_204;
if (ngI18nClosureMode) {
    /**
     * @desc The placeholder for the alpha input.
     * @meaning kendo.colorpicker.alphaInputPlaceholder
     */ 
    const MSG_EXTERNAL_7522085117867122625$$DIST_FESM2015_INDEX_JS_205 = goog.getMsg("Alpha");
    I18N_204 = MSG_EXTERNAL_7522085117867122625$$DIST_FESM2015_INDEX_JS_205;
}
else {
    I18N_204 = ɵngcc0.ɵɵi18nLocalize("Alpha");
}
const _c206 = ["colorGradientHandle", I18N_188, "clearButton", I18N_190, "hueSliderHandle", I18N_192, "opacitySliderHandle", I18N_194, "hexInputPlaceholder", I18N_196, "redInputPlaceholder", I18N_198, "greenInputPlaceholder", I18N_200, "blueInputPlaceholder", I18N_202, "alphaInputPlaceholder", I18N_204];
const _c207 = ["role", "listbox", 3, "ngClass", "id", "focus", "blur", "mousedown", "keydown"];
const _c208 = ["class", "k-selected-color", 3, "background-color", "click", 4, "ngIf"];
const _c209 = ["class", "k-tool-icon", 3, "ngClass", "click", 4, "ngIf"];
const _c210 = [1, "k-select", 3, "click"];
const _c211 = ["popupTemplate", ""];
const _c212 = ["container", ""];
const _c213 = [1, "k-selected-color", 3, "click"];
const _c214 = ["class", "k-icon k-i-line", 4, "ngIf"];
const _c215 = [1, "k-icon", "k-i-line"];
function ColorPickerComponent_span_4_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", _c215);
} }
function ColorPickerComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    const _r106 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", _c213);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵlistener("click", function ColorPickerComponent_span_4_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r106); const ctx_r105 = ɵngcc0.ɵɵnextContext(); return ctx_r105.handleActiveColorClick(); });
    ɵngcc0.ɵɵtemplate(1, ColorPickerComponent_span_4_span_1_Template, 1, 0, "span", _c214);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r99 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("background-color", ctx_r99.value);
    ɵngcc0.ɵɵstylingApply();
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r99.value);
} }
const _c216 = [1, "k-tool-icon", 3, "ngClass", "click"];
const _c217 = [1, "k-selected-color"];
function ColorPickerComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    const _r108 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", _c216);
    ɵngcc0.ɵɵlistener("click", function ColorPickerComponent_span_5_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r108); const ctx_r107 = ɵngcc0.ɵɵnextContext(); return ctx_r107.handleActiveColorClick(); });
    ɵngcc0.ɵɵelementStart(1, "span", _c217);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r100 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r100.iconStyles);
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵstyleProp("background-color", ctx_r100.value);
    ɵngcc0.ɵɵstylingApply();
} }
const _c218 = [3, "value", "format", "opacity", "clearButton", "delay", "focusout", "valueChange", "keydown", 4, "ngIf"];
const _c219 = ["kendoFocusOnDomReady", "", 3, "palette", "columns", "tileSize", "format", "value", "blur", "cellSelection", "mousedown", "keydown", 4, "ngIf"];
const _c220 = [3, "value", "format", "opacity", "clearButton", "delay", "focusout", "valueChange", "keydown"];
const _c221 = ["colorGradient", ""];
function ColorPickerComponent_ng_template_8_kendo_colorgradient_0_Template(rf, ctx) { if (rf & 1) {
    const _r113 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-colorgradient", _c220, _c221);
    ɵngcc0.ɵɵlistener("focusout", function ColorPickerComponent_ng_template_8_kendo_colorgradient_0_Template_kendo_colorgradient_focusout_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r113); const ctx_r112 = ɵngcc0.ɵɵnextContext(2); return ctx_r112.handlePopupBlur($event); });
    ɵngcc0.ɵɵlistener("valueChange", function ColorPickerComponent_ng_template_8_kendo_colorgradient_0_Template_kendo_colorgradient_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r113); const ctx_r114 = ɵngcc0.ɵɵnextContext(2); return ctx_r114.handleValueChange($event, false); });
    ɵngcc0.ɵɵlistener("keydown", function ColorPickerComponent_ng_template_8_kendo_colorgradient_0_Template_kendo_colorgradient_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r113); const ctx_r115 = ɵngcc0.ɵɵnextContext(2); return ctx_r115.handlePopupKeyDown($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r109 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("value", ctx_r109.value)("format", ctx_r109.format)("opacity", ctx_r109.gradientSettings.opacity)("clearButton", ctx_r109.gradientSettings.clearButton)("delay", ctx_r109.gradientSettings.delay);
} }
const _c222 = ["kendoFocusOnDomReady", "", 3, "palette", "columns", "tileSize", "format", "value", "blur", "cellSelection", "mousedown", "keydown"];
const _c223 = ["palette", ""];
function ColorPickerComponent_ng_template_8_kendo_colorpalette_1_Template(rf, ctx) { if (rf & 1) {
    const _r118 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-colorpalette", _c222, _c223);
    ɵngcc0.ɵɵlistener("blur", function ColorPickerComponent_ng_template_8_kendo_colorpalette_1_Template_kendo_colorpalette_blur_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r118); const ctx_r117 = ɵngcc0.ɵɵnextContext(2); return ctx_r117.handlePopupBlur($event); });
    ɵngcc0.ɵɵlistener("cellSelection", function ColorPickerComponent_ng_template_8_kendo_colorpalette_1_Template_kendo_colorpalette_cellSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r118); const ctx_r119 = ɵngcc0.ɵɵnextContext(2); return ctx_r119.handleValueChange($event, true); });
    ɵngcc0.ɵɵlistener("mousedown", function ColorPickerComponent_ng_template_8_kendo_colorpalette_1_Template_kendo_colorpalette_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r118); return $event.preventDefault(); });
    ɵngcc0.ɵɵlistener("keydown", function ColorPickerComponent_ng_template_8_kendo_colorpalette_1_Template_kendo_colorpalette_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r118); const ctx_r121 = ɵngcc0.ɵɵnextContext(2); return ctx_r121.handlePopupKeyDown($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r110 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("palette", ctx_r110.paletteSettings.palette)("columns", ctx_r110.paletteSettings.columns)("tileSize", ctx_r110.paletteSettings.tileSize)("format", ctx_r110.format)("value", ctx_r110.value);
} }
function ColorPickerComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ColorPickerComponent_ng_template_8_kendo_colorgradient_0_Template, 2, 5, "kendo-colorgradient", _c218);
    ɵngcc0.ɵɵtemplate(1, ColorPickerComponent_ng_template_8_kendo_colorpalette_1_Template, 2, 5, "kendo-colorpalette", _c219);
} if (rf & 2) {
    const ctx_r102 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r102.view === "gradient" || ctx_r102.view === "combo");
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r102.view === "palette" || ctx_r102.view === "combo");
} }
const _c224 = function (a1, a2) { return { "k-picker-wrap": true, "k-state-disabled": a1, "k-state-focused": a2 }; };
const _c225 = ["kendoColorPaletteLocalizedMessages", "", 6, "colorPaletteNoColor"];
var I18N_226;
if (ngI18nClosureMode) {
    /**
     * @desc The aria-label applied to the ColorPalette component when the value is empty.
     * @meaning kendo.colorpalette.colorPaletteNoColor
     */ 
    const MSG_EXTERNAL_4885193165402402447$$DIST_FESM2015_INDEX_JS_227 = goog.getMsg("Colorpalette no color chosen");
    I18N_226 = MSG_EXTERNAL_4885193165402402447$$DIST_FESM2015_INDEX_JS_227;
}
else {
    I18N_226 = ɵngcc0.ɵɵi18nLocalize("Colorpalette no color chosen");
}
const _c228 = ["colorPaletteNoColor", I18N_226];
const _c229 = ["role", "listbox", 1, "k-colorpalette-table-wrap"];
const _c230 = [1, "k-colorpalette-table", "k-palette"];
const _c231 = [4, "ngFor", "ngForOf"];
const _c232 = ["role", "option", "class", "k-colorpalette-tile", 3, "k-state-selected", "k-state-focus", "id", "ngStyle", "click", 4, "ngFor", "ngForOf"];
const _c233 = ["role", "option", 1, "k-colorpalette-tile", 3, "id", "ngStyle", "click"];
const _c234 = function (a0, a1, a2, a3) { return { backgroundColor: a0, width: a1, height: a2, minWidth: a3 }; };
function ColorPaletteComponent_tr_5_td_1_Template(rf, ctx) { if (rf & 1) {
    const _r130 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", _c233);
    ɵngcc0.ɵɵstyling();
    ɵngcc0.ɵɵlistener("click", function ColorPaletteComponent_tr_5_td_1_Template_td_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r130); const color_r126 = ctx.$implicit; const colIndex_r127 = ctx.index; const rowIndex_r124 = ɵngcc0.ɵɵnextContext().index; const ctx_r128 = ɵngcc0.ɵɵnextContext(); return ctx_r128.handleCellSelection(color_r126, { row: rowIndex_r124, col: colIndex_r127 }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const color_r126 = ctx.$implicit;
    const colIndex_r127 = ctx.index;
    const rowIndex_r124 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r125 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-state-selected", (ctx_r125.selectedCell == null ? null : ctx_r125.selectedCell.row) === rowIndex_r124 && (ctx_r125.selectedCell == null ? null : ctx_r125.selectedCell.col) === colIndex_r127);
    ɵngcc0.ɵɵclassProp("k-state-focus", ctx_r125.focusInComponent && (ctx_r125.focusedCell == null ? null : ctx_r125.focusedCell.row) === rowIndex_r124 && (ctx_r125.focusedCell == null ? null : ctx_r125.focusedCell.col) === colIndex_r127);
    ɵngcc0.ɵɵstylingApply();
    ɵngcc0.ɵɵproperty("id", rowIndex_r124 + "-" + colIndex_r127)("ngStyle", ɵngcc0.ɵɵpureFunction4(7, _c234, color_r126, ctx_r125.tileLayout.width + "px", ctx_r125.tileLayout.height + "px", ctx_r125.tileLayout.width + "px"));
    ɵngcc0.ɵɵattribute("aria-selected", (ctx_r125.selectedCell == null ? null : ctx_r125.selectedCell.row) === rowIndex_r124 && (ctx_r125.selectedCell == null ? null : ctx_r125.selectedCell.col) === colIndex_r127)("aria-label", color_r126)("value", color_r126);
} }
function ColorPaletteComponent_tr_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵtemplate(1, ColorPaletteComponent_tr_5_td_1_Template, 1, 12, "td", _c232);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const row_r123 = ctx.$implicit;
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵproperty("ngForOf", row_r123);
} }
const _c235 = ["kendoContrastValidation", ""];
const _c236 = ["class", "k-contrast-validation k-text-success", 4, "ngIf"];
const _c237 = ["class", "k-contrast-validation k-text-error", 4, "ngIf"];
const _c238 = [1, "k-contrast-validation", "k-text-success"];
const _c239 = [1, "k-icon", "k-i-check"];
function ContrastValidationComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", _c238);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelement(2, "span", _c239);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r132 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r132.passMessage, " ");
} }
const _c240 = [1, "k-contrast-validation", "k-text-error"];
const _c241 = [1, "k-icon", "k-i-close"];
function ContrastValidationComponent_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", _c240);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelement(2, "span", _c241);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r133 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r133.failMessage, " ");
} }
const _c242 = ["kendoContrastTool", ""];
const _c243 = [1, "k-contrast-ratio"];
const _c244 = [1, "k-contrast-ratio-text"];
const _c245 = ["kendoContrastValidation", "", "type", "AA", 3, "ratio", "pass"];
const _c246 = ["kendoContrastValidation", "", "type", "AAA", 3, "ratio", "pass"];
const _c247 = ["class", "k-icon k-i-check", 4, "ngIf"];
function ContrastComponent_span_3_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", _c239);
} }
function ContrastComponent_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", _c238);
    ɵngcc0.ɵɵelement(1, "span", _c239);
    ɵngcc0.ɵɵtemplate(2, ContrastComponent_span_3_span_2_Template, 1, 0, "span", _c247);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r134 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵselect(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r134.satisfiesAAACondition);
} }
function ContrastComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", _c240);
    ɵngcc0.ɵɵelement(1, "span", _c241);
    ɵngcc0.ɵɵelementEnd();
} }
function FormFieldComponent_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "hasHints"]);
} }
function FormFieldComponent_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "hasErrors"]);
} }
const _c248 = [[["label"], ["kendo-label"]], "*", [["kendo-formhint"]], [["kendo-formerror"]]];
const _c249 = ["label, kendo-label", "*", "kendo-formhint", "kendo-formerror"];
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
const areSame = (value1, value2) => value1 === value2 || (value1 === null && value2 === undefined) || (value1 === undefined && value2 === null);
/**
 * @hidden
 */
const requiresZoneOnBlur = (ngControl) => ngControl &&
    (!ngControl.touched || (ngControl.control && ngControl.control.updateOn === 'blur'));
/**
 * @hidden
 *
 * Fits the contender number into the specified bounds. If the number is NaN or null, the min is returned.
 *
 * @param contender Represents the number you want to fit into specified bounds.
 * @param min The inclusive lower bound number.
 * @param max The inclusive upper bound number.
 */
const fitIntoBounds = (contender, min, max) => {
    if (!isPresent(contender) || isNaN(contender)) {
        return min;
    }
    return contender <= min ? min : contender >= max ? max : contender;
};

/**
 * @hidden
 */
const MAX_PRECISION = 20;
/**
 * @hidden
 */
const limitPrecision = (precision) => Math.min(precision, MAX_PRECISION);
/**
 * @hidden
 */
const fractionLength = (value) => {
    return (String(value).split('.')[1] || "").length;
};
const maxFractionLength = (value1, value2) => {
    return Math.max(fractionLength(value1), fractionLength(value2));
};
/**
 * @hidden
 */
const toFixedPrecision = (value, precision) => {
    const maxPrecision = limitPrecision(precision);
    return parseFloat(value.toFixed(maxPrecision));
};
/**
 * @hidden
 */
const add = (value1, value2) => {
    const maxPrecision = maxFractionLength(value1, value2);
    return toFixedPrecision(value1 + value2, maxPrecision);
};
/**
 * @hidden
 */
const subtract = (value1, value2) => {
    return add(value1, -value2);
};
/**
 * @hidden
 */
const multiply = (value1, value2) => {
    const maxPrecision = fractionLength(value1) + fractionLength(value2);
    return toFixedPrecision(value1 * value2, maxPrecision);
};
/**
 * @hidden
 */
const divide = (dividend, divisor) => {
    if (divisor === 0) {
        return NaN;
    }
    const power = maxFractionLength(dividend, divisor);
    const correctionValue = Math.pow(10, power);
    return ((correctionValue * dividend) / (correctionValue * divisor));
};
/**
 * @hidden
 */
const remainder = (dividend, divisor) => {
    return Math.abs(subtract(dividend, multiply(divisor, Math.floor(divide(dividend, divisor)))));
};

/**
 * @hidden
 */
const calculateFixedTrackSize = ({ max, min, smallStep, fixedTickWidth }) => ((max - min) / smallStep) * fixedTickWidth;
/**
 * @hidden
 */
const calculateTrackSize = (wrapperWidth, offset, showButtons = true) => {
    const BUTTONS_COUNT = 2;
    const trackOffset = showButtons ? parseFloat(offset) * BUTTONS_COUNT : 0;
    const trackWidth = wrapperWidth - trackOffset;
    return Math.floor(trackWidth);
};
/**
 * @hidden
 */
const calculateTicksCount = (min = 0, max = 0, smallStep = 1) => {
    if (smallStep <= 0) {
        throw new Error('Invalid argument: smallStep must be a positive number');
    }
    const adjustedRange = Math.abs(subtract(max, min));
    const adjustedRatio = Math.floor(divide(adjustedRange, smallStep));
    const result = add(adjustedRatio, 1);
    return result;
};
/**
 * @hidden
 */
const calculateValueFromTick = (index, { max, min, smallStep, reverse, vertical }) => {
    const value = add(min, multiply(index, smallStep));
    return vertical || reverse ? Math.abs(subtract(value, max)) : value;
};
/**
 * @hidden
 */
const calculateHandlePosition = ({ handleWidth, trackWidth, min, max, reverse, value }) => {
    const halfHandleWidth = Math.floor(handleWidth / 2);
    const step = trackWidth / Math.abs(max - min);
    let pos = isPresent(value) ? step * (value - min) : min;
    if (reverse) {
        pos = trackWidth - pos;
    }
    return Math.floor(pos - halfHandleWidth);
};
/**
 * @hidden
 */
const decreaseValueToStep = (value, { max, min, smallStep, largeStep }, large = false) => {
    const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;
    const stepValue = subtract(value, min);
    let result;
    const stepRemainder = remainder(stepValue, step);
    if (stepRemainder === 0) {
        result = subtract(stepValue, step);
    }
    else {
        result = subtract(stepValue, stepRemainder);
    }
    return limitValue(add(result, min), min, max);
};
/**
 * @hidden
 */
const increaseValueToStep = (value, { max, min, smallStep, largeStep }, large = false) => {
    const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;
    const stepValue = subtract(value, min);
    const stepRemainder = remainder(stepValue, step);
    const result = add(subtract(stepValue, stepRemainder), step);
    return limitValue(add(result, min), min, max);
};
/**
 * @hidden
 */
const isStartHandle = (dragHandle) => dragHandle.id.indexOf('k-start-handle') > -1;
/**
 * @hidden
 */
const snapValue = (value, options) => {
    const { smallStep, min, max } = options;
    const limited = limitValue(value, min, max);
    if (value !== limited) {
        return limited;
    }
    const left = decreaseValueToStep(value, options);
    const right = increaseValueToStep(value, options);
    if ((value - min) % smallStep === 0) {
        return value;
    }
    if (right - value <= (right - left) / 2) {
        return right;
    }
    return left;
};
/**
 * @hidden
 */
const trimValue = (max, min, value) => {
    if (value > max) {
        return max;
    }
    if (value < min) {
        return min;
    }
    return value;
};
/**
 * @hidden
 */
const trimValueRange = (max, min, value) => {
    return value ? [trimValue(max, min, value[0]), trimValue(max, min, value[1])] : [min, min];
};
/**
 * @hidden
 */
const identity = (value) => value;
/**
 * @hidden
 */
const isSameRange = (value1, value2) => areSame(value1[0], value2[0]) && areSame(value1[1], value2[1]);
/**
 * @hidden
 */
const elementOffset = (element) => {
    const box = element.getBoundingClientRect();
    const documentElement = document.documentElement;
    return {
        left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),
        top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0)
    };
};
/**
 * @hidden
 */
const limitValue = (value, min, max) => {
    return Math.max(Math.min(value, max), min);
};
/**
 * @hidden
 */
const eventValue = (eventArgs, scaleElement, options) => {
    const { min, max, vertical, rtl } = options;
    const trackOffset = elementOffset(scaleElement);
    const offset = vertical ? eventArgs.pageY - trackOffset.top : eventArgs.pageX - trackOffset.left;
    const scale = (max - min) / (vertical ? scaleElement.clientHeight : scaleElement.clientWidth);
    const offsetValue = offset * scale;
    let value = rtl || vertical ? max - offsetValue : min + offsetValue;
    const stepFractionLength = fractionLength(options.smallStep);
    value = toFixedPrecision(value, stepFractionLength + 1);
    return snapValue(value, options);
};
/**
 * @hidden
 */
const isButton = (element) => {
    return element.className.indexOf('k-button-increase') >= 0 || element.className.indexOf('k-button-decrease') >= 0;
};
/**
 * @hidden
 */
const increment = (options) => {
    return increaseValueToStep(options.value, options);
};
/**
 * @hidden
 */
const decrement = (options) => {
    return decreaseValueToStep(options.value, options);
};
/**
 * @hidden
 */
const incrementLarge = (options) => {
    return increaseValueToStep(options.value, options, true);
};
/**
 * @hidden
 */
const decrementLarge = (options) => {
    return decreaseValueToStep(options.value, options, true);
};
/**
 * @hidden
 */
const validateValue = (value) => {
    if (isDevMode && value && value[0] > value[1]) {
        throw new Error('[RangeSlider] The start value should not be greater than the end value.');
    }
};

/**
 * @hidden
 */
class SliderModelBase {
    constructor(props, wrapper, track, renderer) {
        this.props = props;
        this.wrapper = wrapper;
        this.track = track;
        this.renderer = renderer;
        this.props = props;
        this.wrapper = wrapper;
        this.track = track;
        this.tickSizes = this.getTickSizes();
    }
    resizeTrack() {
        const orientation = this.props.vertical ? 'height' : 'width';
        const trackWidth = this.trackWidth();
        this.track.style[orientation] = `${trackWidth}px`;
    }
    resizeTicks(ticksContainer, ticks) {
        const dimension = this.props.vertical ? "height" : "width";
        [...ticks].map((tick, index) => tick.style[dimension] = `${this.tickSizes[index]}px`);
        if (this.props.vertical) {
            this.adjustPadding(ticksContainer);
        }
    }
    resizeWrapper() {
        const dimension = this.props.vertical ? "height" : "width";
        const wrapperSize = this.elementSize(this.wrapper);
        const trackWidth = calculateTrackSize(wrapperSize, this.elementOffset(this.track));
        const fixedTrackWidth = calculateFixedTrackSize(this.props);
        const wrapperParentEl = this.wrapper.parentElement;
        if (trackWidth > fixedTrackWidth) {
            wrapperParentEl.style[dimension] = `${wrapperSize - (trackWidth - fixedTrackWidth)}px`;
        }
        else {
            wrapperParentEl.style[dimension] = `${wrapperSize + (fixedTrackWidth - trackWidth)}px`;
        }
    }
    trackWidth() {
        if (this.props.fixedTickWidth) {
            return calculateFixedTrackSize(this.props);
        }
        return calculateTrackSize(this.elementSize(this.wrapper), this.elementOffset(this.track), this.props.buttons);
    }
    getTickSizes() {
        const { min, max, smallStep } = this.props;
        const count = calculateTicksCount(min, max, smallStep);
        const trackSize = this.trackWidth();
        const distStep = trackSize / subtract(max, min);
        const result = [];
        let usedSpace = 0;
        let endPoint = 0;
        for (let i = 0; i < count; i++) {
            if (i === 0 || i === count - 1) {
                endPoint += (smallStep / 2) * distStep;
            }
            else {
                endPoint += smallStep * distStep;
            }
            // ensure that the sum of the tick sizes does not exceed the track width
            endPoint = +endPoint.toFixed(2) - 0.01;
            const size = Math.round(endPoint - usedSpace);
            result.push(size);
            usedSpace += size;
        }
        if (usedSpace >= trackSize) {
            result[result.length - 1] -= 1;
        }
        return result;
    }
    adjustPadding(ticksContainer) {
        const totalTickSize = this.tickSizes.reduce((prev, curr) => prev + curr, 0);
        const trackWidth = this.trackWidth();
        const reminder = trackWidth - totalTickSize;
        if (reminder !== 0) {
            const padding = reminder + this.elementOffset(this.track);
            ticksContainer.style.paddingTop = `${padding}px`;
        }
    }
    elementOffset(element) {
        const { vertical } = this.props;
        const style = getComputedStyle(element);
        return parseInt(vertical ? style.bottom : style.left, 10);
    }
    elementSize(element) {
        const { vertical } = this.props;
        return vertical ? element.clientHeight : element.clientWidth;
    }
}

/**
 * @hidden
 */
class SliderModel extends SliderModelBase {
    positionHandle(dragHandle) {
        const { max, min, reverse, vertical } = this.props;
        const position = vertical ? 'bottom' : 'left';
        const trackWidth = this.trackWidth();
        const value = trimValue(max, min, this.props.value);
        this.handlePosition = calculateHandlePosition({
            min,
            max,
            reverse,
            value,
            trackWidth,
            handleWidth: dragHandle.offsetWidth
        });
        this.renderer.setStyle(dragHandle, position, `${this.handlePosition}px`);
    }
    positionSelection(dragHandle, selection) {
        const { reverse, vertical } = this.props;
        const dimension = vertical ? 'height' : 'width';
        const handleWidth = Math.floor(dragHandle.offsetWidth / 2);
        let size = this.handlePosition + handleWidth;
        if (reverse) {
            size = this.trackWidth() - size;
        }
        this.renderer.setStyle(selection, dimension, `${size}px`);
    }
}

const UNTOUCHED = 'ng-untouched';
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const hasClass = (element, className) => Boolean(toClassList(element.className).find((name) => name === className));
/**
 * @hidden
 */
function invokeElementMethod(element, name, ...args) {
    if (element && element.nativeElement) {
        return element.nativeElement[name].apply(element.nativeElement, args);
    }
}
/**
 * @hidden
 */
const isUntouched = (element) => element && element.nativeElement && hasClass(element.nativeElement, UNTOUCHED);
/**
 * @hidden
 */
const containsFocus = (hostElement, contender) => hostElement && contender && (hostElement === contender || hostElement.contains(contender));
/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-inputs',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1637576485,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * Represents the template for the labels of the Slider.
 * To define the labels template, nest an `<ng-template>` tag with the `kendoSliderLabelTemplate` directive inside
 * the `<kendo-slider>` tag. The template context is passed to the `label` value.
 *
 * @example
 * ```ts-no-run
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-slider [largeStep]="2">
 *           <ng-template kendoSliderLabelTemplate let-value="value">
 *             <b>{{value}}</b>
 *           </ng-template>
 *         </kendo-slider>
 *     `
 * })
 *
 * class AppComponent {
 * }
 *
 * ```
 */
let LabelTemplateDirective = class LabelTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
LabelTemplateDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: LabelTemplateDirective, selectors: [["", "kendoSliderLabelTemplate", ""]], factory: function LabelTemplateDirective_Factory(t) { return new (t || LabelTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(TemplateRef, 8)); } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(LabelTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoSliderLabelTemplate]'
            }]
    }], function () { return [{ type: TemplateRef, decorators: [{
                type: Optional
            }] }]; }, { constructor: [], templateRef: [] });;
LabelTemplateDirective = __decorate([
    __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], LabelTemplateDirective);

/**
 * @hidden
 */
class SliderBase {
    constructor(localizationService, injector, renderer, ngZone, changeDetector, hostElement) {
        this.localizationService = localizationService;
        this.injector = injector;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * Defines the title of the ticks ([see example]({% slug ticks_slider %}#toc-titles)). The default title
         * for each tick is its Slider value. If you use a callback function, the function accepts an argument
         * that holds the value of the component and returns a string with the new title.
         */
        this.title = identity;
        /**
         * Denotes the location of the tick marks in the Slider ([see example]({% slug ticks_slider %}#toc-placement)).
         *
         * The available options are:
         * * `before`&mdash;The tick marks are located to the top side of the horizontal track or to the left side of a vertical track.
         * * `after`&mdash;The tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.
         * * `both`&mdash; (Default) The tick marks are located on both sides of the track.
         * * `none`&mdash;The tick marks are not visible. The actual elements are not added to the DOM tree.
         */
        this.tickPlacement = 'both';
        /**
         * If `vertical` is set to `true`, the orientation of the Slider changes from horizontal to vertical
         * ([see example]({% slug orientation_slider %})).
         */
        this.vertical = false;
        /**
         * The minimum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
         * The attribute accepts both integers and floating-point numbers.
         */
        this.min = 0;
        /**
         * The maximum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
         * The attribute accepts both integers and floating-point numbers.
         */
        this.max = 10;
        /**
         * The step value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
         * Accepts positive values only. Can be an integer or a floating-point number.
         */
        this.smallStep = 1;
        /**
         * Specifies that every n<sup>th</sup> tick will be large and will have a label
         * ([see example]({% slug predefinedsteps_slider %}#toc-large-steps)).
         * Accepts positive integer values only.
         */
        this.largeStep = null;
        /**
         * Determines whether the Slider is disabled ([see example]({% slug disabledstate_slider %})).
         */
        this.disabled = false;
        /**
         * Determines whether the Slider is in its read-only state ([see example]({% slug readonly_slider %})).
         */
        this.readonly = false;
        /**
         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Slider.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the component.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the component is blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the user selects a new value.
         */
        this.valueChange = new EventEmitter();
        this.sliderClass = true;
        this.widgetClass = true;
        this.subscriptions = new Subscription();
        /**
         * @hidden
         */
        this.ifEnabled = (callback, event) => {
            if (!this.isDisabled) {
                callback.call(this, event);
            }
        };
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    get horizontalClass() {
        return !this.vertical;
    }
    get verticalClass() {
        return this.vertical;
    }
    get disabledClass() {
        return this.disabled;
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.changeDetector.markForCheck();
        this.disabled = isDisabled;
    }
    ngOnInit() {
        this.subscriptions.add(this.localizationService
            .changes
            .subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
            this.sizeComponent();
        }));
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.control = this.injector.get(NgControl, null);
    }
    /**
     * @hidden
     */
    get isDisabled() {
        return this.disabled || this.readonly;
    }
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    get reverse() {
        return this.localizationService.rtl && !this.vertical;
    }
    get keyBinding() {
        const reverse = this.reverse;
        return {
            [Keys.ArrowLeft]: reverse ? increment : decrement,
            [Keys.ArrowRight]: reverse ? decrement : increment,
            [Keys.ArrowDown]: decrement,
            [Keys.ArrowUp]: increment,
            [Keys.PageUp]: incrementLarge,
            [Keys.PageDown]: decrementLarge,
            [Keys.Home]: ({ min }) => min,
            [Keys.End]: ({ max }) => max
        };
    }
    resetStyles(elements) {
        elements.forEach(el => {
            if (el) {
                if (this.vertical) {
                    this.renderer.removeStyle(el, 'width');
                    this.renderer.removeStyle(el, 'left');
                    this.renderer.removeStyle(el, 'right');
                }
                else {
                    this.renderer.removeStyle(el, 'height');
                    this.renderer.removeStyle(el, 'bottom');
                }
                this.renderer.removeStyle(el, 'padding-top');
            }
        });
    }
}
SliderBase.ngBaseDef = ɵngcc0.ɵɵdefineBase({ inputs: { title: "title", tickPlacement: "tickPlacement", vertical: "vertical", min: "min", max: "max", smallStep: "smallStep", largeStep: "largeStep", disabled: "disabled", readonly: "readonly", tabindex: "tabindex", fixedTickWidth: "fixedTickWidth" }, outputs: { onFocus: "focus", onBlur: "blur", valueChange: "valueChange" }, viewQuery: function (rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
        ɵngcc0.ɵɵstaticViewQuery(_c1, true);
        ɵngcc0.ɵɵstaticViewQuery(_c2, true);
        ɵngcc0.ɵɵviewQuery(_c3, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c3, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.wrapper = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.track = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.sliderSelection = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.ticksContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.ticks = _t.first);
    } }, contentQueries: function (rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, LabelTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.labelTemplate = _t.first);
    } }, hostBindings: function (rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(6);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-slider", ctx.sliderClass);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.widgetClass);
        ɵngcc0.ɵɵclassProp("k-slider-horizontal", ctx.horizontalClass);
        ɵngcc0.ɵɵclassProp("k-slider-vertical", ctx.verticalClass);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabledClass);
        ɵngcc0.ɵɵstylingApply();
    } } });
__decorate([
    Input(),
    __metadata("design:type", Function)
], SliderBase.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderBase.prototype, "tickPlacement", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SliderBase.prototype, "vertical", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderBase.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderBase.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderBase.prototype, "smallStep", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderBase.prototype, "largeStep", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderBase.prototype, "fixedTickWidth", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SliderBase.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SliderBase.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderBase.prototype, "tabindex", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], SliderBase.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], SliderBase.prototype, "onBlur", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], SliderBase.prototype, "valueChange", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], SliderBase.prototype, "direction", void 0);
__decorate([
    HostBinding('class.k-slider-horizontal'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SliderBase.prototype, "horizontalClass", null);
__decorate([
    HostBinding('class.k-slider-vertical'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SliderBase.prototype, "verticalClass", null);
__decorate([
    HostBinding('class.k-slider'),
    __metadata("design:type", Boolean)
], SliderBase.prototype, "sliderClass", void 0);
__decorate([
    HostBinding('class.k-widget'),
    __metadata("design:type", Boolean)
], SliderBase.prototype, "widgetClass", void 0);
__decorate([
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SliderBase.prototype, "disabledClass", null);
__decorate([
    ViewChild('wrap', { static: true }),
    __metadata("design:type", ElementRef)
], SliderBase.prototype, "wrapper", void 0);
__decorate([
    ViewChild('track', { static: true }),
    __metadata("design:type", ElementRef)
], SliderBase.prototype, "track", void 0);
__decorate([
    ViewChild('sliderSelection', { static: true }),
    __metadata("design:type", ElementRef)
], SliderBase.prototype, "sliderSelection", void 0);
__decorate([
    ViewChild('ticks', { read: ElementRef, static: false }),
    __metadata("design:type", ElementRef)
], SliderBase.prototype, "ticksContainer", void 0);
__decorate([
    ViewChild('ticks', { static: false }),
    __metadata("design:type", Object)
], SliderBase.prototype, "ticks", void 0);
__decorate([
    ContentChild(LabelTemplateDirective, { static: false }),
    __metadata("design:type", LabelTemplateDirective)
], SliderBase.prototype, "labelTemplate", void 0);

var SliderComponent_1;
const PRESSED = 'k-pressed';
/**
 * Represents the [Kendo UI Slider component for Angular]({% slug overview_slider %}).
 */
let SliderComponent = SliderComponent_1 = class SliderComponent extends SliderBase {
    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {
        super(localization, injector, renderer, ngZone, changeDetector, hostElement);
        this.localization = localization;
        this.injector = injector;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Determines if the animation will be played on value change.
         * Regardless of this setting, no animation will be played during the initial rendering.
         */
        this.animate = true;
        /**
         * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).
         * When `showButtons` is set to `false`, the buttons are not displayed.
         */
        this.showButtons = true;
        /**
         * The current value of the Slider when it is initially displayed.
         * The component can use either NgModel or the `value` binding but not both of them at the same time.
         */
        this.value = this.min;
        this.focusChangedProgrammatically = false;
        /**
         * @hidden
         */
        this.onWrapClick = (args) => {
            const target = args.target;
            if (!this.isDisabled && !(isButton(target) || isButton(target.parentNode))) {
                const value = eventValue(args, this.track.nativeElement, this.getProps());
                this.changeValue(value);
            }
            invokeElementMethod(this.draghandle, 'focus');
        };
        /**
         * @hidden
         */
        this.onKeyDown = (e) => {
            const options = this.getProps();
            const { max, min } = options;
            const handler = this.keyBinding[e.keyCode];
            if (this.isDisabled || !handler) {
                return;
            }
            const value = handler(options);
            this.changeValue(trimValue(max, min, value));
            e.preventDefault();
        };
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        this.decreaseValue = () => {
            this.changeValue(decreaseValueToStep(this.value, this.getProps()));
        };
        this.increaseValue = () => {
            this.changeValue(increaseValueToStep(this.value, this.getProps()));
        };
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    if (!this.focusChangedProgrammatically) {
                        this.onBlur.emit();
                    }
                });
            }
        };
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * @hidden
     */
    get currentValue() {
        return isPresent(this.value) ? this.value.toString() : '';
    }
    /**
     * Focuses the Slider.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="slider.focus()">Focus</button>
     *  <kendo-slider #slider></kendo-slider>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.disabled) {
            this.focusChangedProgrammatically = true;
            invokeElementMethod(this.draghandle, 'focus');
            this.focusChangedProgrammatically = false;
        }
    }
    /**
     * Blurs the Slider.
     */
    blur() {
        this.focusChangedProgrammatically = true;
        invokeElementMethod(this.draghandle, 'blur');
        this.handleBlur();
        this.focusChangedProgrammatically = false;
    }
    ngOnChanges(changes) {
        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {
            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                this.sizeComponent(false);
            });
        }
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.showButtons) {
            this.setValueChangeInterval(this.increaseButton.nativeElement, () => this.increaseValue());
            this.setValueChangeInterval(this.decreaseButton.nativeElement, () => this.decreaseValue());
        }
        this.sizeComponent(false);
        if (this.ticks) {
            this.ticks.tickElements
                .changes
                .subscribe(() => this.sizeComponent(false));
        }
        this.attachElementEventHandlers();
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get incrementMessage() {
        return this.incrementTitle || this.localizationService.get('increment');
    }
    /**
     * @hidden
     */
    get decrementMessage() {
        return this.decrementTitle || this.localizationService.get('decrement');
    }
    /**
     * @hidden
     */
    get dragHandleMessage() {
        return this.dragHandleTitle || this.localizationService.get('dragHandle');
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (args.originalEvent) {
            args.originalEvent.preventDefault();
        }
        this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        this.dragging = true;
        this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));
    }
    /**
     * @hidden
     */
    onHandleRelease() {
        this.dragging = false; //needed for animation
        this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');
    }
    //ngModel binding
    /**
     * @hidden
     */
    writeValue(value) {
        this.changeDetector.markForCheck();
        this.value = value;
        this.sizeComponent(this.animate);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    changeValue(value) {
        if (!areSame(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.sizeComponent(this.animate);
                this.changeDetector.markForCheck();
            });
        }
    }
    /**
     * @hidden
     */
    sizeComponent(animate) {
        if (!isDocumentAvailable()) {
            return;
        }
        const wrapper = this.wrapper.nativeElement;
        const track = this.track.nativeElement;
        const selectionEl = this.sliderSelection.nativeElement;
        const dragHandleEl = this.draghandle.nativeElement;
        const ticks = this.ticks ? this.ticksContainer.nativeElement : null;
        if (!animate) {
            this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');
        }
        this.resetStyles([track, selectionEl, dragHandleEl, ticks, this.hostElement.nativeElement]);
        const props = this.getProps();
        const model = new SliderModel(props, wrapper, track, this.renderer);
        model.resizeTrack();
        if (this.ticks) { //for case when tickPlacement: none
            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));
        }
        model.positionHandle(dragHandleEl);
        model.positionSelection(dragHandleEl, selectionEl);
        if (!animate) {
            this.hostElement.nativeElement.getBoundingClientRect();
            this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');
        }
        if (this.fixedTickWidth) {
            model.resizeWrapper();
        }
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            this.isFocused = value;
        }
    }
    set dragging(value) {
        if (this.isDragged !== value && this.sliderSelection && this.draghandle) {
            const sliderSelection = this.sliderSelection.nativeElement;
            const draghandle = this.draghandle.nativeElement;
            if (value) {
                this.renderer.addClass(sliderSelection, PRESSED);
                this.renderer.addClass(draghandle, PRESSED);
            }
            else {
                this.renderer.removeClass(sliderSelection, PRESSED);
                this.renderer.removeClass(draghandle, PRESSED);
            }
            this.isDragged = value;
        }
    }
    setValueChangeInterval(element, callback) {
        this.ngZone.runOutsideAngular(() => {
            const mousedown = fromEvent(element, 'mousedown');
            const mouseup = fromEvent(element, 'mouseup');
            const mouseout = fromEvent(element, 'mouseout');
            const subscription = mousedown.pipe(filter((e) => e.button === 0 && !this.isDisabled), concatMap(() => interval(150).pipe(startWith(-1), takeUntil(merge(mouseup, mouseout))))).subscribe(() => {
                if (!this.isFocused) {
                    invokeElementMethod(this.draghandle, 'focus');
                }
                callback();
            });
            this.subscriptions.add(subscription);
        });
    }
    getProps() {
        return {
            buttons: this.showButtons,
            disabled: this.disabled,
            fixedTickWidth: this.fixedTickWidth,
            largeStep: this.largeStep,
            max: this.max,
            min: this.min,
            readonly: this.readonly,
            reverse: this.reverse,
            rtl: this.localizationService.rtl,
            smallStep: this.smallStep,
            value: trimValue(this.max, this.min, this.value),
            vertical: this.vertical
        };
    }
    attachElementEventHandlers() {
        const hostElement = this.hostElement.nativeElement;
        let tabbing = false;
        let cursorInsideWrapper = false;
        this.ngZone.runOutsideAngular(() => {
            // focusIn and focusOut are relative to the host element
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {
                if (!this.isFocused) {
                    this.ngZone.run(() => {
                        if (!this.focusChangedProgrammatically) {
                            this.onFocus.emit();
                        }
                        this.focused = true;
                    });
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {
                if (!this.isFocused) {
                    return;
                }
                if (tabbing) {
                    if (args.relatedTarget !== this.draghandle.nativeElement) {
                        this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper) {
                        this.handleBlur();
                    }
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {
                cursorInsideWrapper = true;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {
                cursorInsideWrapper = false;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
        });
    }
}
SliderComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: SliderComponent, selectors: [["kendo-slider"]], factory: function SliderComponent_Factory(t) { return new (t || SliderComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(Injector), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, viewQuery: function SliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c4, true);
        ɵngcc0.ɵɵviewQuery(_c5, true);
        ɵngcc0.ɵɵviewQuery(_c6, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.draghandle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.decreaseButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.increaseButton = _t.first);
    } }, inputs: { focusableId: "focusableId", animate: "animate", showButtons: "showButtons", value: "value", tabIndex: "tabIndex", dragHandleTitle: "dragHandleTitle", incrementTitle: "incrementTitle", decrementTitle: "decrementTitle" }, exportAs: ["kendoSlider"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.slider' },
            { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => SliderComponent_1) },
            { provide: KendoInput, useExisting: forwardRef(() => SliderComponent_1) }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature()], consts: 14, vars: 21, template: function SliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, _c7);
        ɵngcc0.ɵɵi18nAttributes(1, _c14);
        ɵngcc0.ɵɵelementStart(2, "div", _c15, _c16);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵtemplate(4, SliderComponent_span_4_Template, 3, 3, "span", _c17);
        ɵngcc0.ɵɵtemplate(5, SliderComponent_span_5_Template, 3, 4, "span", _c18);
        ɵngcc0.ɵɵtemplate(6, SliderComponent_ul_6_Template, 2, 8, "ul", _c19);
        ɵngcc0.ɵɵelementStart(7, "div", _c20, _c21);
        ɵngcc0.ɵɵelement(9, "div", _c22, _c23);
        ɵngcc0.ɵɵelementStart(11, "a", _c24, _c25);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵlistener("kendoPress", function SliderComponent_Template_a_kendoPress_11_listener($event) { return ctx.ifEnabled(ctx.handleDragPress, $event); });
        ɵngcc0.ɵɵlistener("kendoDrag", function SliderComponent_Template_a_kendoDrag_11_listener($event) { return ctx.ifEnabled(ctx.onHandleDrag, $event); });
        ɵngcc0.ɵɵlistener("kendoRelease", function SliderComponent_Template_a_kendoRelease_11_listener($event) { return ctx.ifEnabled(ctx.onHandleRelease, $event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(13, "kendo-resize-sensor", _c26);
        ɵngcc0.ɵɵlistener("resize", function SliderComponent_Template_kendo_resize_sensor_resize_13_listener($event) { return ctx.sizeComponent(false); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵclassProp("k-slider-buttons", ctx.showButtons);
        ɵngcc0.ɵɵclassProp("k-slider-topleft", ctx.tickPlacement === "before");
        ɵngcc0.ɵɵclassProp("k-slider-bottomright", ctx.tickPlacement === "after");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(18, _c34, ctx.onWrapClick, ctx.onKeyDown));
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showButtons);
        ɵngcc0.ɵɵselect(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showButtons);
        ɵngcc0.ɵɵselect(6);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tickPlacement !== "none");
        ɵngcc0.ɵɵselect(11);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵproperty("title", ctx.dragHandleMessage)("id", ctx.focusableId);
        ɵngcc0.ɵɵattribute("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.currentValue)("aria-valuetext", ctx.currentValue)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("aria-orientation", ctx.vertical ? "vertical" : "horizontal")("tabindex", ctx.disabled ? "-1" : ctx.tabIndex);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(SliderComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoSlider',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.slider' },
                    { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => SliderComponent_1) },
                    { provide: KendoInput, useExisting: forwardRef(() => SliderComponent_1) }
                ],
                selector: 'kendo-slider',
                template: `
        <ng-container kendoSliderLocalizedMessages
            i18n-increment="kendo.slider.increment|The title of the **Increase** button of the Slider."
            increment="increment"
            i18n-decrement="kendo.slider.decrement|The title of the **Decrease** button of the Slider."
            decrement="decrement"
            i18n-dragHandle="kendo.slider.dragHandle|The title of the drag handle of the Slider."
            dragHandle="Drag"
        >
        <div class="k-slider-wrap" #wrap
            [class.k-slider-buttons]="showButtons"
            [class.k-slider-topleft]="tickPlacement === 'before'"
            [class.k-slider-bottomright]="tickPlacement === 'after'"
            [kendoEventsOutsideAngular]="{ click: onWrapClick, keydown: onKeyDown }"
            >
            <span
                #decreaseButton
                *ngIf="showButtons"
                class="k-button k-button-decrease"
                [title]="decrementMessage"
                role="presentation"
            >
                <span class="k-icon"
                    [class.k-i-arrow-w]="!vertical"
                    [class.k-i-arrow-s]="vertical"
                >
                </span>
            </span>
            <span
                *ngIf="showButtons"
                #increaseButton
                class="k-button k-button-increase"
                [title]="incrementMessage"
                (click)="$event.preventDefault()"
                [attr.aria-label]="currentValue"
            >
                <span class="k-icon"
                    [class.k-i-arrow-e]="!vertical"
                    [class.k-i-arrow-n]="vertical"
                >
                </span>
            </span>
            <ul kendoSliderTicks
                #ticks
                *ngIf="tickPlacement !== 'none'"
                [tickTitle]="title"
                [vertical]="vertical"
                [step]="smallStep"
                [largeStep]="largeStep"
                [min]="min"
                [max]="max"
                [labelTemplate]="labelTemplate?.templateRef"
                [attr.aria-hidden]="true"
            >
            </ul>
            <div #track class="k-slider-track">
                <div #sliderSelection class="k-slider-selection">
                </div>
                <a #draghandle
                    role="slider"
                    [attr.aria-valuemin]="min"
                    [attr.aria-valuemax]="max"
                    [attr.aria-valuenow]="currentValue"
                    [attr.aria-valuetext]="currentValue"
                    [attr.aria-disabled]="disabled ? true : undefined"
                    [attr.aria-readonly]="readonly ? true : undefined"
                    [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                    [style.touch-action]="isDisabled ? '' : 'none'"
                    class="k-draghandle"
                    [title]="dragHandleMessage"
                    [attr.tabindex]="disabled ? '-1' : tabIndex"
                    [id]="focusableId"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress, $event)"
                    (kendoDrag)="ifEnabled(onHandleDrag, $event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                ></a>
            </div>
            <kendo-resize-sensor (resize)="sizeComponent(false)"></kendo-resize-sensor>
        </div>
  `
            }]
    }], function () { return [{ type: LocalizationService }, { type: Injector }, { type: Renderer2 }, { type: NgZone }, { type: ChangeDetectorRef }, { type: ElementRef }]; }, { constructor: [], localization: [], injector: [], renderer: [], ngZone: [], changeDetector: [], hostElement: [], focusableId: [{
            type: Input
        }], animate: [{
            type: Input
        }], showButtons: [{
            type: Input
        }], value: [{
            type: Input
        }], focusChangedProgrammatically: [], onWrapClick: [], onKeyDown: [], ngChange: [], ngTouched: [], decreaseValue: [], increaseValue: [], handleBlur: [], focused: [], tabIndex: [{
            type: Input
        }], tabIndex: [], tabindex: [], currentValue: [], focus: [], blur: [], ngOnChanges: [], ngAfterViewInit: [], ngOnDestroy: [], incrementMessage: [], decrementMessage: [], dragHandleMessage: [], handleDragPress: [], onHandleDrag: [], dragging: [], onHandleRelease: [], writeValue: [], registerOnChange: [], registerOnTouched: [], changeValue: [], sizeComponent: [], isFocused: [], isDragged: [], setValueChangeInterval: [], getProps: [], attachElementEventHandlers: [], dragHandleTitle: [{
            type: Input
        }], incrementTitle: [{
            type: Input
        }], decrementTitle: [{
            type: Input
        }], draghandle: [{
            type: ViewChild,
            args: ['draghandle', { static: true }]
        }], decreaseButton: [{
            type: ViewChild,
            args: ['decreaseButton', { static: false }]
        }], increaseButton: [{
            type: ViewChild,
            args: ['increaseButton', { static: false }]
        }] });;
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderComponent.prototype, "dragHandleTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderComponent.prototype, "incrementTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SliderComponent.prototype, "animate", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderComponent.prototype, "decrementTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SliderComponent.prototype, "showButtons", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], SliderComponent.prototype, "tabIndex", null);
__decorate([
    ViewChild('draghandle', { static: true }),
    __metadata("design:type", ElementRef)
], SliderComponent.prototype, "draghandle", void 0);
__decorate([
    ViewChild('decreaseButton', { static: false }),
    __metadata("design:type", ElementRef)
], SliderComponent.prototype, "decreaseButton", void 0);
__decorate([
    ViewChild('increaseButton', { static: false }),
    __metadata("design:type", ElementRef)
], SliderComponent.prototype, "increaseButton", void 0);
SliderComponent = SliderComponent_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService,
        Injector,
        Renderer2,
        NgZone,
        ChangeDetectorRef,
        ElementRef])
], SliderComponent);

/**
 * @hidden
 */
class RangeSliderModel extends SliderModelBase {
    positionHandle(dragHandle) {
        if (!dragHandle.id) {
            return;
        }
        const { max, min, reverse, vertical } = this.props;
        const position = vertical ? 'bottom' : 'left';
        const trackWidth = this.trackWidth();
        const value = isStartHandle(dragHandle) ? trimValueRange(max, min, this.props.value)[0]
            : trimValueRange(max, min, this.props.value)[1];
        if (isStartHandle(dragHandle)) {
            this.startHandlePosition = calculateHandlePosition({
                min,
                max,
                reverse,
                value,
                trackWidth,
                handleWidth: dragHandle.offsetWidth
            });
            this.renderer.setStyle(dragHandle, position, `${this.startHandlePosition}px`);
        }
        else {
            this.endHandlePosition = calculateHandlePosition({
                min,
                max,
                reverse,
                value,
                trackWidth,
                handleWidth: dragHandle.offsetWidth
            });
            this.renderer.setStyle(dragHandle, position, `${this.endHandlePosition}px`);
        }
    }
    positionSelection(dragHandle, selection) {
        const { reverse, vertical } = this.props;
        const dimension = vertical ? 'height' : 'width';
        const position = vertical ? 'bottom' : reverse ? 'right' : 'left';
        const handleWidth = Math.floor(dragHandle.offsetWidth / 2);
        const size = Math.abs(this.endHandlePosition - this.startHandlePosition);
        const currentSelectionPosition = vertical ? dragHandle.style.bottom : dragHandle.style.left;
        this.renderer.setStyle(selection, dimension, `${size}px`);
        this.renderer.setStyle(selection, position, reverse ? this.trackWidth() - parseFloat(currentSelectionPosition) - handleWidth + 'px'
            : parseFloat(currentSelectionPosition) + handleWidth + 'px');
    }
}

var RangeSliderComponent_1;
const PRESSED$1 = 'k-pressed';
/**
 * Represents the [Kendo UI RangeSlider component for Angular]({% slug overview_rangeslider %}).
 */
let RangeSliderComponent = RangeSliderComponent_1 = class RangeSliderComponent extends SliderBase {
    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {
        super(localization, injector, renderer, ngZone, changeDetector, hostElement);
        this.localization = localization;
        this.injector = injector;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.startHandleId = `k-start-handle-${guid()}`;
        /**
         * @hidden
         */
        this.endHandleId = `k-end-handle-${guid()}`;
        /**
         * @hidden
         */
        this.focusableId = this.startHandleId;
        this.handleZIndex = 0;
        this.activeHandle = 'startHandle';
        this.focusChangedProgrammatically = false;
        /**
         * @hidden
         */
        this.onWrapClick = (args) => {
            if (!this.isDisabled) {
                this.value = this.value || [this.min, this.min];
                const trackValue = eventValue(args, this.track.nativeElement, this.getProps());
                let newRangeValue;
                const [startValue, endValue] = newRangeValue = this.value;
                if (trackValue <= startValue) {
                    newRangeValue = [trackValue, endValue];
                    this.activeHandle = 'startHandle';
                }
                else if (startValue < trackValue && trackValue < endValue) {
                    if (trackValue < (startValue + endValue) / 2) {
                        newRangeValue = [trackValue, endValue];
                        this.activeHandle = 'startHandle';
                    }
                    else {
                        newRangeValue = [startValue, trackValue];
                        this.activeHandle = 'endHandle';
                    }
                }
                else if (trackValue >= endValue) {
                    newRangeValue = [startValue, trackValue];
                    this.activeHandle = 'endHandle';
                }
                const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;
                invokeElementMethod(activeHandle, 'focus');
                this.changeValue(newRangeValue);
            }
        };
        /**
         * @hidden
         */
        this.onKeyDown = (e) => {
            this.value = this.value || [this.min, this.min];
            const options = this.getProps();
            const { max, min } = options;
            const handler = this.keyBinding[e.keyCode];
            if (this.isDisabled || !handler) {
                return;
            }
            this.renderer.setStyle(e.target, 'zIndex', ++this.handleZIndex);
            const startHandleIsActive = isStartHandle(e.target);
            const value = handler(Object.assign({}, options, { value: startHandleIsActive ? this.value[0] : this.value[1] }));
            if (startHandleIsActive) {
                if (value > this.value[1]) {
                    this.value[1] = value;
                }
            }
            else {
                if (value < this.value[0]) {
                    this.value[0] = value;
                }
            }
            const trimmedValue = trimValue(max, min, value);
            const newValue = startHandleIsActive ? [trimmedValue, this.value[1]]
                : [this.value[0], trimmedValue];
            this.changeValue(newValue);
            e.preventDefault();
        };
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    if (!this.focusChangedProgrammatically) {
                        this.onBlur.emit();
                    }
                });
            }
        };
    }
    /**
     * Focuses the RangeSlider.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *     <div>
     *         <button class="k-button" (click)="slider.focus()">Focus</button>
     *     </div>
     *     <kendo-rangeslider #slider></kendo-rangeslider>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        this.focusChangedProgrammatically = true;
        invokeElementMethod(this.draghandleStart, 'focus');
        this.focusChangedProgrammatically = false;
    }
    /**
     * Blurs the RangeSlider.
     */
    blur() {
        this.focusChangedProgrammatically = true;
        const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;
        invokeElementMethod(activeHandle, 'blur');
        this.handleBlur();
        this.focusChangedProgrammatically = false;
    }
    ngOnInit() {
        if (!this.value) {
            this.value = [this.min, this.max];
        }
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {
            if (changes.value && changes.value.currentValue) {
                validateValue(changes.value.currentValue);
            }
            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                this.sizeComponent();
            });
        }
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.sizeComponent();
        if (this.ticks) {
            this.ticks.tickElements
                .changes
                .subscribe(() => this.sizeComponent());
        }
        this.attachElementEventHandlers();
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
    /**
     * @hidden
     */
    get valueText() {
        return this.value ? `${this.value[0]} - ${this.value[1]}` : '';
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (args.originalEvent) {
            args.originalEvent.preventDefault();
        }
        const target = args.originalEvent.target;
        this.draggedHandle = target;
        this.renderer.setStyle(target, 'zIndex', ++this.handleZIndex);
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        this.value = this.value || [this.min, this.min];
        const target = args.originalEvent.target;
        const lastCoords = this.draggedHandle.getBoundingClientRect();
        this.lastHandlePosition = { x: lastCoords.left, y: lastCoords.top };
        this.dragging = { value: true, target };
        const left = args.pageX < this.lastHandlePosition.x;
        const right = args.pageX > this.lastHandlePosition.x;
        const up = args.pageY > this.lastHandlePosition.y;
        const moveStartHandle = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), this.value[1]]);
        const moveEndHandle = () => this.changeValue([this.value[0], eventValue(args, this.track.nativeElement, this.getProps())]);
        const moveBothHandles = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), eventValue(args, this.track.nativeElement, this.getProps())]);
        const activeStartHandle = isStartHandle(this.draggedHandle);
        const vertical = this.vertical;
        const horizontal = !vertical;
        const forward = (vertical && up) || (this.reverse ? horizontal && right : horizontal && left);
        // const forward = (this.reverse ? (!this.vertical && !left) : (!this.vertical && left)) || (this.vertical && up);
        if (this.value[0] === this.value[1]) {
            if (forward) {
                activeStartHandle ? moveStartHandle() : moveBothHandles();
            }
            else {
                activeStartHandle ? moveBothHandles() : moveEndHandle();
            }
        }
        else {
            activeStartHandle ? moveStartHandle() : moveEndHandle();
        }
    }
    /**
     * @hidden
     */
    onHandleRelease(args) {
        this.dragging = { value: false, target: args.originalEvent.target }; //needed for animation
        this.draggedHandle = undefined;
    }
    //ngModel binding
    /**
     * @hidden
     */
    writeValue(value) {
        validateValue(value);
        this.value = value;
        this.sizeComponent();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    changeValue(value) {
        if (!this.value || !isSameRange(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                if (this.value) {
                    this.valueChange.emit(value);
                }
                this.sizeComponent();
            });
        }
    }
    /**
     * @hidden
     */
    sizeComponent() {
        if (!isDocumentAvailable()) {
            return;
        }
        const wrapper = this.wrapper.nativeElement;
        const track = this.track.nativeElement;
        const selectionEl = this.sliderSelection.nativeElement;
        const dragHandleStartEl = this.draghandleStart.nativeElement;
        const dragHandleEndEl = this.draghandleEnd.nativeElement;
        const ticks = this.ticks ? this.ticksContainer.nativeElement : null;
        this.resetStyles([track, selectionEl, dragHandleStartEl, dragHandleEndEl, ticks, this.hostElement.nativeElement]);
        const props = this.getProps();
        const model = new RangeSliderModel(props, wrapper, track, this.renderer);
        model.resizeTrack();
        if (this.ticks) { //for case when tickPlacement: none
            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));
        }
        model.positionHandle(dragHandleStartEl);
        model.positionHandle(dragHandleEndEl);
        model.positionSelection(dragHandleStartEl, selectionEl);
        if (this.fixedTickWidth) {
            model.resizeWrapper();
        }
    }
    /**
     * @hidden
     */
    get isDisabled() {
        return this.disabled || this.readonly;
    }
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            this.isFocused = value;
        }
    }
    set dragging(data) {
        if (this.isDragged !== data.value && this.sliderSelection && this.draghandleStart && this.draghandleEnd) {
            const sliderSelection = this.sliderSelection.nativeElement;
            const draghandle = data.target;
            if (data.value) {
                this.renderer.addClass(sliderSelection, PRESSED$1);
                this.renderer.addClass(draghandle, PRESSED$1);
            }
            else {
                this.renderer.removeClass(sliderSelection, PRESSED$1);
                this.renderer.removeClass(draghandle, PRESSED$1);
            }
            this.isDragged = data.value;
        }
    }
    getProps() {
        return {
            disabled: this.disabled,
            fixedTickWidth: this.fixedTickWidth,
            largeStep: this.largeStep,
            max: this.max,
            min: this.min,
            readonly: this.readonly,
            reverse: this.reverse,
            rtl: this.localizationService.rtl,
            smallStep: this.smallStep,
            value: trimValueRange(this.max, this.min, this.value),
            vertical: this.vertical,
            buttons: false
        };
    }
    attachElementEventHandlers() {
        const hostElement = this.hostElement.nativeElement;
        let tabbing = false;
        let cursorInsideWrapper = false;
        this.ngZone.runOutsideAngular(() => {
            // focusIn and focusOut are relative to the host element
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {
                if (!this.isFocused) {
                    this.ngZone.run(() => {
                        if (!this.focusChangedProgrammatically) {
                            this.onFocus.emit();
                        }
                        this.focused = true;
                    });
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {
                if (!this.isFocused) {
                    return;
                }
                if (tabbing) {
                    if (args.relatedTarget !== this.draghandleStart.nativeElement && args.relatedTarget !== this.draghandleEnd.nativeElement) {
                        this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper) {
                        this.handleBlur();
                    }
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {
                cursorInsideWrapper = true;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {
                cursorInsideWrapper = false;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
        });
    }
}
RangeSliderComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: RangeSliderComponent, selectors: [["kendo-rangeslider"]], factory: function RangeSliderComponent_Factory(t) { return new (t || RangeSliderComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(Injector), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, viewQuery: function RangeSliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c35, true);
        ɵngcc0.ɵɵstaticViewQuery(_c36, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.draghandleStart = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.draghandleEnd = _t.first);
    } }, inputs: { value: "value" }, exportAs: ["kendoRangeSlider"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.rangeslider' },
            { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => RangeSliderComponent_1) },
            { provide: KendoInput, useExisting: forwardRef(() => RangeSliderComponent_1) }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature()], consts: 14, vars: 29, template: function RangeSliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, _c37);
        ɵngcc0.ɵɵi18nAttributes(1, _c42);
        ɵngcc0.ɵɵelementStart(2, "div", _c15, _c16);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵtemplate(4, RangeSliderComponent_ul_4_Template, 2, 8, "ul", _c19);
        ɵngcc0.ɵɵelementStart(5, "div", _c20, _c21);
        ɵngcc0.ɵɵelement(7, "div", _c22, _c23);
        ɵngcc0.ɵɵelementStart(9, "a", _c43, _c44);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵlistener("kendoPress", function RangeSliderComponent_Template_a_kendoPress_9_listener($event) { return ctx.ifEnabled(ctx.handleDragPress, $event); });
        ɵngcc0.ɵɵlistener("kendoDrag", function RangeSliderComponent_Template_a_kendoDrag_9_listener($event) { return ctx.ifEnabled(ctx.onHandleDrag, $event); });
        ɵngcc0.ɵɵlistener("kendoRelease", function RangeSliderComponent_Template_a_kendoRelease_9_listener($event) { return ctx.ifEnabled(ctx.onHandleRelease, $event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "a", _c43, _c45);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵlistener("kendoPress", function RangeSliderComponent_Template_a_kendoPress_11_listener($event) { return ctx.ifEnabled(ctx.handleDragPress, $event); });
        ɵngcc0.ɵɵlistener("kendoDrag", function RangeSliderComponent_Template_a_kendoDrag_11_listener($event) { return ctx.ifEnabled(ctx.onHandleDrag, $event); });
        ɵngcc0.ɵɵlistener("kendoRelease", function RangeSliderComponent_Template_a_kendoRelease_11_listener($event) { return ctx.ifEnabled(ctx.onHandleRelease, $event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(13, "kendo-resize-sensor", _c26);
        ɵngcc0.ɵɵlistener("resize", function RangeSliderComponent_Template_kendo_resize_sensor_resize_13_listener($event) { return ctx.sizeComponent(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵclassProp("k-slider-topleft", ctx.tickPlacement === "before");
        ɵngcc0.ɵɵclassProp("k-slider-bottomright", ctx.tickPlacement === "after");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(26, _c34, ctx.onWrapClick, ctx.onKeyDown));
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tickPlacement !== "none");
        ɵngcc0.ɵɵselect(9);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵproperty("id", ctx.startHandleId)("title", ctx.textFor("dragHandleStart"));
        ɵngcc0.ɵɵattribute("tabindex", ctx.disabled ? undefined : ctx.tabindex)("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value ? ctx.value[0] : null)("aria-valuetext", ctx.valueText)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
        ɵngcc0.ɵɵselect(11);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵproperty("id", ctx.endHandleId)("title", ctx.textFor("dragHandleEnd"));
        ɵngcc0.ɵɵattribute("tabindex", ctx.disabled ? undefined : ctx.tabindex)("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value ? ctx.value[1] : null)("aria-valuetext", ctx.valueText)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(RangeSliderComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoRangeSlider',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.rangeslider' },
                    { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => RangeSliderComponent_1) },
                    { provide: KendoInput, useExisting: forwardRef(() => RangeSliderComponent_1) }
                ],
                selector: 'kendo-rangeslider',
                template: `
        <ng-container kendoSliderLocalizedMessages
            i18n-dragHandleStart="kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider."
            dragHandleStart="Drag"
            i18n-dragHandleEnd="kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider."
            dragHandleEnd="Drag"
        >

        <div class="k-slider-wrap" #wrap
            [class.k-slider-topleft]="tickPlacement === 'before'"
            [class.k-slider-bottomright]="tickPlacement === 'after'"
            [kendoEventsOutsideAngular]="{ click: onWrapClick, keydown: onKeyDown }"
            >
            <ul kendoSliderTicks
                #ticks
                *ngIf="tickPlacement !== 'none'"
                [tickTitle]="title"
                [vertical]="vertical"
                [step]="smallStep"
                [largeStep]="largeStep"
                [min]="min"
                [max]="max"
                [labelTemplate]="labelTemplate?.templateRef"
                [attr.aria-hidden]="true"
            >
            </ul>
            <div #track class="k-slider-track">
                <div #sliderSelection class="k-slider-selection">
                </div>
                <a #draghandleStart
                    role="slider"
                    [id]="startHandleId"
                    [attr.tabindex]="disabled ? undefined : tabindex"
                    [attr.aria-valuemin]="min"
                    [attr.aria-valuemax]="max"
                    [attr.aria-valuenow]="value ? value[0] : null"
                    [attr.aria-valuetext]="valueText"
                    [attr.aria-disabled]="disabled ? true : undefined"
                    [attr.aria-readonly]="readonly ? true : undefined"
                    [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                    [style.touch-action]="isDisabled ? '' : 'none'"
                    class="k-draghandle"
                    [title]="textFor('dragHandleStart')"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress ,$event)"
                    (kendoDrag)="ifEnabled(onHandleDrag ,$event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                ></a>
                <a #draghandleEnd
                    role="slider"
                    [id]="endHandleId"
                    [attr.tabindex]="disabled ? undefined : tabindex"
                    [attr.aria-valuemin]="min"
                    [attr.aria-valuemax]="max"
                    [attr.aria-valuenow]="value ? value[1] : null"
                    [attr.aria-valuetext]="valueText"
                    [attr.aria-disabled]="disabled ? true : undefined"
                    [attr.aria-readonly]="readonly ? true : undefined"
                    [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                    [style.touch-action]="isDisabled ? '' : 'none'"
                    class="k-draghandle"
                    [title]="textFor('dragHandleEnd')"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress ,$event)"
                    (kendoDrag)="ifEnabled(onHandleDrag ,$event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                ></a>
            </div>

            <kendo-resize-sensor (resize)="sizeComponent()"></kendo-resize-sensor>
        </div>
  `
            }]
    }], function () { return [{ type: LocalizationService }, { type: Injector }, { type: Renderer2 }, { type: NgZone }, { type: ChangeDetectorRef }, { type: ElementRef }]; }, { constructor: [], localization: [], injector: [], renderer: [], ngZone: [], changeDetector: [], hostElement: [], startHandleId: [], endHandleId: [], focusableId: [], handleZIndex: [], activeHandle: [], focusChangedProgrammatically: [], onWrapClick: [], value: [{
            type: Input
        }], onKeyDown: [], ngChange: [], ngTouched: [], handleBlur: [], focused: [], focus: [], blur: [], ngOnInit: [], ngOnChanges: [], ngAfterViewInit: [], ngOnDestroy: [], textFor: [], valueText: [], handleDragPress: [], draggedHandle: [], onHandleDrag: [], lastHandlePosition: [], dragging: [], onHandleRelease: [], writeValue: [], registerOnChange: [], registerOnTouched: [], changeValue: [], sizeComponent: [], isDisabled: [], isEmpty: [], isFocused: [], isDragged: [], getProps: [], attachElementEventHandlers: [], draghandleStart: [{
            type: ViewChild,
            args: ['draghandleStart', { static: true }]
        }], draghandleEnd: [{
            type: ViewChild,
            args: ['draghandleEnd', { static: true }]
        }] });;
__decorate([
    Input(),
    __metadata("design:type", Array)
], RangeSliderComponent.prototype, "value", void 0);
__decorate([
    ViewChild('draghandleStart', { static: true }),
    __metadata("design:type", ElementRef)
], RangeSliderComponent.prototype, "draghandleStart", void 0);
__decorate([
    ViewChild('draghandleEnd', { static: true }),
    __metadata("design:type", ElementRef)
], RangeSliderComponent.prototype, "draghandleEnd", void 0);
RangeSliderComponent = RangeSliderComponent_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService,
        Injector,
        Renderer2,
        NgZone,
        ChangeDetectorRef,
        ElementRef])
], RangeSliderComponent);

var SwitchComponent_1;
const FOCUSED = 'k-state-focused';
/**
 * Represents the [Kendo UI Switch component for Angular]({% slug overview_switch %}).
 */
let SwitchComponent = SwitchComponent_1 = class SwitchComponent {
    constructor(renderer, hostElement, localizationService, injector, changeDetector, ngZone) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.localizationService = localizationService;
        this.injector = injector;
        this.changeDetector = changeDetector;
        this.ngZone = ngZone;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Determines whether the Switch is disabled ([see example]({% slug disabled_switch %})).
         */
        this.disabled = false;
        /**
         * Determines whether the Switch is in its read-only state ([see example]({% slug readonly_switch %})).
         */
        this.readonly = false;
        /**
         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Switch.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the `input` element.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the `input` element gets blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the user selects a new value.
         */
        this.valueChange = new EventEmitter();
        this.hostClasses = true;
        /**
         * @hidden
         */
        this.initialized = false;
        this._checked = false;
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        /**
         * @hidden
         */
        this.handleFocus = () => {
            this.focused = true;
            if (hasObservers(this.onFocus)) {
                this.ngZone.run(() => {
                    this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    this.onBlur.emit();
                });
            }
        };
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
        this.keyDownHandler = this.keyDownHandler.bind(this);
        this.clickHandler = this.clickHandler.bind(this);
    }
    /**
     * Sets the value of the Switch when it is initially displayed.
     */
    set checked(value) {
        this.setHostClasses(value);
        this._checked = value;
    }
    get checked() {
        return this._checked;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    get ieClass() {
        return browser && browser.msie;
    }
    get ariaDisabled() {
        return this.disabled ? true : undefined;
    }
    get ariaReadonly() {
        return this.readonly;
    }
    get disabledClass() {
        return this.disabled;
    }
    /**
     * @hidden
     */
    get onLabelMessage() {
        return this.onLabel || this.localizationService.get('on');
    }
    /**
     * @hidden
     */
    get offLabelMessage() {
        return this.offLabel || this.localizationService.get('off');
    }
    get isEnabled() {
        return !this.disabled && !this.readonly;
    }
    ngOnInit() {
        if (this.hostElement) {
            const wrapper = this.hostElement.nativeElement;
            this.renderer.removeAttribute(wrapper, "tabindex");
        }
        this.localizationChangeSubscription = this.localizationService
            .changes
            .pipe(skip(1))
            .subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.control = this.injector.get(NgControl, null);
        this.ngZone.onStable.pipe(take(1)).subscribe(() => this.initialized = true);
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
    /**
     * Focuses the Switch.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="switch.focus()">Focus</button>
     *  <kendo-switch #switch></kendo-switch>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.wrapper) {
            return;
        }
        this.wrapper.nativeElement.focus();
    }
    /**
     * Blurs the Switch.
     */
    blur() {
        if (!this.wrapper) {
            return;
        }
        this.wrapper.nativeElement.blur();
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.changeDetector.markForCheck();
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.checked = value === null ? false : value;
        this.changeDetector.markForCheck();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    keyDownHandler(e) {
        const keyCode = e.keyCode;
        if (this.isEnabled && (keyCode === Keys.Space || keyCode === Keys.Enter)) {
            this.changeValue(!this.checked);
            e.preventDefault();
        }
    }
    /**
     * @hidden
     */
    clickHandler() {
        if (this.isEnabled) {
            this.changeValue(!this.checked);
        }
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    changeValue(value) {
        if (this.checked !== value) {
            this.ngZone.run(() => {
                this.checked = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.changeDetector.markForCheck();
            });
        }
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            const element = this.hostElement.nativeElement;
            if (value) {
                this.renderer.addClass(element, FOCUSED);
            }
            else {
                this.renderer.removeClass(element, FOCUSED);
            }
            this.isFocused = value;
        }
    }
    setHostClasses(value) {
        if (value) {
            this.renderer.removeClass(this.hostElement.nativeElement, 'k-switch-off');
            this.renderer.addClass(this.hostElement.nativeElement, 'k-switch-on');
        }
        else {
            this.renderer.removeClass(this.hostElement.nativeElement, 'k-switch-on');
            this.renderer.addClass(this.hostElement.nativeElement, 'k-switch-off');
        }
    }
}
SwitchComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: SwitchComponent, selectors: [["kendo-switch"]], factory: function SwitchComponent_Factory(t) { return new (t || SwitchComponent)(ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(Injector), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NgZone)); }, viewQuery: function SwitchComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c46, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.wrapper = _t.first);
    } }, hostBindings: function SwitchComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(6);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction)("aria-disabled", ctx.ariaDisabled)("aria-readonly", ctx.ariaReadonly);
        ɵngcc0.ɵɵclassProp("k-switch", ctx.hostClasses);
        ɵngcc0.ɵɵclassProp("k-ie", ctx.ieClass);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabledClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { focusableId: "focusableId", disabled: "disabled", readonly: "readonly", tabindex: "tabindex", checked: "checked", tabIndex: "tabIndex", onLabel: "onLabel", offLabel: "offLabel" }, outputs: { onFocus: "focus", onBlur: "blur", valueChange: "valueChange" }, exportAs: ["kendoSwitch"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.switch' },
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => SwitchComponent_1) /* tslint:disable-line */
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => SwitchComponent_1)
            }
        ])], consts: 9, vars: 15, template: function SwitchComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, _c47);
        ɵngcc0.ɵɵi18nAttributes(1, _c52);
        ɵngcc0.ɵɵelementStart(2, "span", _c53, _c54);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵelementStart(4, "span", _c55);
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "span", _c56);
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "span", _c57);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵstyleProp("transition-duration", ctx.initialized ? "200ms" : "0ms");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction4(10, _c58, ctx.clickHandler, ctx.keyDownHandler, ctx.handleFocus, ctx.handleBlur));
        ɵngcc0.ɵɵattribute("aria-checked", ctx.checked)("tabindex", ctx.disabled ? undefined : ctx.tabIndex);
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵattribute("aria-hidden", true);
        ɵngcc0.ɵɵselect(5);
        ɵngcc0.ɵɵtextInterpolate(ctx.onLabelMessage);
        ɵngcc0.ɵɵselect(6);
        ɵngcc0.ɵɵattribute("aria-hidden", true);
        ɵngcc0.ɵɵselect(7);
        ɵngcc0.ɵɵtextInterpolate(ctx.offLabelMessage);
        ɵngcc0.ɵɵselect(8);
        ɵngcc0.ɵɵstyleProp("transition-duration", ctx.initialized ? "200ms" : "0ms");
        ɵngcc0.ɵɵstylingApply();
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(SwitchComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoSwitch',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.switch' },
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => SwitchComponent_1) /* tslint:disable-line */
                    },
                    {
                        provide: KendoInput,
                        useExisting: forwardRef(() => SwitchComponent_1)
                    }
                ],
                selector: 'kendo-switch',
                template: `
        <ng-container kendoSwitchLocalizedMessages
            i18n-on="kendo.switch.on|The **On** label of the Switch."
            on="ON"
            i18n-off="kendo.switch.off|The **Off** label of the Switch."
            off="OFF"
        >

        <span
            #wrapper
            class="k-switch-container"
            [id]="focusableId"
            role="switch"
            [style.transitionDuration]="initialized ? '200ms' : '0ms'"
            [attr.aria-checked]="checked"
            [attr.tabindex]="(disabled ? undefined : tabIndex)"
            [kendoEventsOutsideAngular]="{ click: clickHandler, keydown: keyDownHandler, focus: handleFocus, blur: handleBlur }"
        >
            <span class="k-switch-label-on" [attr.aria-hidden]="true" >{{onLabelMessage}}</span>
            <span class="k-switch-label-off" [attr.aria-hidden]="true">{{offLabelMessage}}</span>
            <span class="k-switch-handle" [style.transitionDuration]="initialized ? '200ms' : '0ms'"></span>
        </span>
  `
            }]
    }], function () { return [{ type: Renderer2 }, { type: ElementRef }, { type: LocalizationService }, { type: Injector }, { type: ChangeDetectorRef }, { type: NgZone }]; }, { constructor: [], renderer: [], hostElement: [], localizationService: [], injector: [], changeDetector: [], ngZone: [], focusableId: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], valueChange: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-switch']
        }], initialized: [], _checked: [], ngChange: [], ngTouched: [], handleFocus: [], focused: [], handleBlur: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], keyDownHandler: [], clickHandler: [], checked: [{
            type: Input
        }], checked: [], tabIndex: [{
            type: Input
        }], tabIndex: [], ieClass: [{
            type: HostBinding,
            args: ['class.k-ie']
        }], ariaDisabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], ariaReadonly: [{
            type: HostBinding,
            args: ['attr.aria-readonly']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], onLabelMessage: [], offLabelMessage: [], isEnabled: [], ngOnInit: [], localizationChangeSubscription: [], control: [], ngOnDestroy: [], focus: [], blur: [], setDisabledState: [], writeValue: [], registerOnChange: [], registerOnTouched: [], isEmpty: [], changeValue: [], isFocused: [], setHostClasses: [], onLabel: [{
            type: Input
        }], offLabel: [{
            type: Input
        }], wrapper: [{
            type: ViewChild,
            args: ['wrapper', { static: true }]
        }] });;
__decorate([
    Input(),
    __metadata("design:type", String)
], SwitchComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SwitchComponent.prototype, "onLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SwitchComponent.prototype, "offLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], SwitchComponent.prototype, "checked", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SwitchComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SwitchComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SwitchComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], SwitchComponent.prototype, "tabIndex", null);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], SwitchComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], SwitchComponent.prototype, "onBlur", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], SwitchComponent.prototype, "valueChange", void 0);
__decorate([
    ViewChild('wrapper', { static: true }),
    __metadata("design:type", Object)
], SwitchComponent.prototype, "wrapper", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], SwitchComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('class.k-ie'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SwitchComponent.prototype, "ieClass", null);
__decorate([
    HostBinding('attr.aria-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SwitchComponent.prototype, "ariaDisabled", null);
__decorate([
    HostBinding('attr.aria-readonly'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SwitchComponent.prototype, "ariaReadonly", null);
__decorate([
    HostBinding('class.k-switch'),
    __metadata("design:type", Boolean)
], SwitchComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], SwitchComponent.prototype, "disabledClass", null);
SwitchComponent = SwitchComponent_1 = __decorate([
    __metadata("design:paramtypes", [Renderer2,
        ElementRef,
        LocalizationService,
        Injector,
        ChangeDetectorRef,
        NgZone])
], SwitchComponent);

var TextAreaDirective_1;
/**
 * Represents the [Kendo UI TextArea directive for the Inputs components for Angular]({% slug overview_textarea %}).
 * Provides floating labels to `textarea` elements.
 *
 * @example
 * ```ts-no-run
 * <textarea kendoTextArea></textarea>
 * ```
 */
let TextAreaDirective = TextAreaDirective_1 = class TextAreaDirective {
    constructor(renderer, element, zone, changeDetector, injector, rtl) {
        this.renderer = renderer;
        this.element = element;
        this.zone = zone;
        this.changeDetector = changeDetector;
        this.injector = injector;
        this.elementClass = true;
        this.autofillClass = true;
        /**
         * Fires each time the textarea value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Specifies if the `textarea` element will resize its height automatically
         * ([see example]({% slug overview_textarea %}#toc-auto-resizing)).
         *
         * @default false
         */
        this.autoSize = false;
        /**
         * @hidden
         */
        this.onFocus = new EventEmitter();
        /**
         * @hidden
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         */
        this.onValueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillStart = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillEnd = new EventEmitter();
        this.listeners = [];
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        this.direction = rtl ? 'rtl' : 'ltr';
    }
    get id() {
        return this.element.nativeElement.id;
    }
    set id(id) {
        this.renderer.setAttribute(this.element.nativeElement, 'id', id);
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.elementValue = value;
        this.resize();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.setElementProperty('disabled', isDisabled);
    }
    ngOnInit() {
        const element = this.element.nativeElement;
        this.zone.runOutsideAngular(() => {
            this.listeners = [
                this.renderer.listen(element, 'focus', this.handleFocus.bind(this)),
                this.renderer.listen(element, 'blur', this.handleBlur.bind(this)),
                this.renderer.listen(element, 'animationstart', (e) => {
                    if (e.animationName === 'autoFillStart') {
                        this.autoFillStart.emit();
                    }
                    else if (e.animationName === 'autoFillEnd') {
                        this.autoFillEnd.emit();
                    }
                })
            ];
            if (isDocumentAvailable() && this.autoSize) {
                this.resizeSubscription = fromEvent(window, 'resize')
                    .pipe((debounceTime(50)))
                    .subscribe(() => this.resize());
            }
            this.inputSubscription = fromEvent(element, 'input')
                .subscribe(this.handleInput.bind(this));
        });
        this.control = this.injector.get(NgControl, null);
    }
    ngOnChanges(changes) {
        const element = this.element.nativeElement;
        if (changes.value) {
            this.elementValue = this.value;
        }
        if (changes.autoSize) {
            if (this.autoSize) {
                this.initialHeight = element.offsetHeight;
                this.renderer.setStyle(element, 'resize', 'none');
            }
            else {
                this.renderer.setStyle(element, 'overflow-y', 'auto');
                this.renderer.setStyle(element, 'resize', 'both');
                element.style.height = `${this.initialHeight}px`;
            }
        }
        this.resize();
    }
    ngOnDestroy() {
        this.listeners.forEach(listener => listener());
        if (this.inputSubscription) {
            this.inputSubscription.unsubscribe();
        }
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
    get elementValue() {
        if (this.element) {
            return this.element.nativeElement.value;
        }
        return '';
    }
    set elementValue(value) {
        this.setElementProperty('value', (value === undefined || value === null) ? '' : value);
    }
    setElementProperty(name, value) {
        if (this.element) {
            this.renderer.setProperty(this.element.nativeElement, name, value);
        }
    }
    resize() {
        if (!this.autoSize) {
            return;
        }
        const element = this.element.nativeElement;
        this.renderer.setStyle(element, 'overflow-y', 'hidden');
        element.style.height = `${this.initialHeight}px`;
        const scrollHeight = element.scrollHeight;
        if (scrollHeight > this.initialHeight) {
            element.style.height = `${scrollHeight}px`;
        }
    }
    handleInput() {
        const value = this.elementValue;
        this.value = value;
        if (this.control || hasObservers(this.onValueChange) || hasObservers(this.valueChange)) {
            this.zone.run(() => {
                this.ngChange(value);
                this.onValueChange.emit(value);
                this.valueChange.emit(value);
                this.changeDetector.markForCheck();
            });
        }
        this.resize();
    }
    handleFocus() {
        if (hasObservers(this.onFocus)) {
            this.zone.run(() => {
                this.onFocus.emit();
            });
        }
    }
    handleBlur() {
        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
            this.zone.run(() => {
                this.ngTouched();
                this.onBlur.emit();
                this.changeDetector.markForCheck();
            });
        }
    }
}
TextAreaDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: TextAreaDirective, selectors: [["textarea", "kendoTextArea", ""]], factory: function TextAreaDirective_Factory(t) { return new (t || TextAreaDirective)(ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(Injector), ɵngcc0.ɵɵdirectiveInject(RTL, 8)); }, hostBindings: function TextAreaDirective_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(3);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-textarea", ctx.elementClass);
        ɵngcc0.ɵɵclassProp("k-autofill", ctx.autofillClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { autoSize: "autoSize", value: "value" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => TextAreaDirective_1),
                multi: true
            }, {
                provide: KendoInput,
                useExisting: forwardRef(() => TextAreaDirective_1)
            }]), ɵngcc0.ɵɵNgOnChangesFeature()] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextAreaDirective, [{
        type: Directive,
        args: [{
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => TextAreaDirective_1),
                        multi: true
                    }, {
                        provide: KendoInput,
                        useExisting: forwardRef(() => TextAreaDirective_1)
                    }],
                selector: 'textarea[kendoTextArea]'
            }]
    }], function () { return [{ type: Renderer2 }, { type: ElementRef }, { type: NgZone }, { type: ChangeDetectorRef }, { type: Injector }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [RTL]
            }] }]; }, { constructor: [], renderer: [], element: [], zone: [], changeDetector: [], injector: [], elementClass: [{
            type: HostBinding,
            args: ['class.k-textarea']
        }], autofillClass: [{
            type: HostBinding,
            args: ['class.k-autofill']
        }], valueChange: [{
            type: Output
        }], autoSize: [{
            type: Input
        }], onFocus: [], onBlur: [], onValueChange: [], autoFillStart: [], autoFillEnd: [], listeners: [], ngChange: [], ngTouched: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], id: [], id: [], writeValue: [], elementValue: [], elementValue: [], registerOnChange: [], registerOnTouched: [], setDisabledState: [], ngOnInit: [], resizeSubscription: [], inputSubscription: [], control: [], ngOnChanges: [], initialHeight: [], ngOnDestroy: [], setElementProperty: [], resize: [], handleInput: [], value: [{
            type: Input
        }], handleFocus: [], handleBlur: [] });;
__decorate([
    HostBinding('class.k-textarea'),
    __metadata("design:type", Boolean)
], TextAreaDirective.prototype, "elementClass", void 0);
__decorate([
    HostBinding('class.k-autofill'),
    __metadata("design:type", Boolean)
], TextAreaDirective.prototype, "autofillClass", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], TextAreaDirective.prototype, "direction", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextAreaDirective.prototype, "valueChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextAreaDirective.prototype, "autoSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextAreaDirective.prototype, "value", void 0);
TextAreaDirective = TextAreaDirective_1 = __decorate([
    __param(5, Optional()), __param(5, Inject(RTL)),
    __metadata("design:paramtypes", [Renderer2,
        ElementRef,
        NgZone,
        ChangeDetectorRef,
        Injector, Boolean])
], TextAreaDirective);

/**
 * @hidden
 */
class FloatingLabelInputAdapter {
    constructor(component, formControl) {
        this.component = component;
        const isObservableOrEventEmitter = (event) => event instanceof Observable || event instanceof EventEmitter;
        if (isObservableOrEventEmitter(component.onFocus)) {
            this.onFocus = component.onFocus;
        }
        if (isObservableOrEventEmitter(component.autoFillStart)) {
            this.autoFillStart = component.autoFillStart;
        }
        if (isObservableOrEventEmitter(component.autoFillEnd)) {
            this.autoFillEnd = component.autoFillEnd;
        }
        if (isObservableOrEventEmitter(component.onBlur)) {
            this.onBlur = component.onBlur;
        }
        if (formControl) {
            this.onValueChange = formControl.valueChanges;
        }
        else if (component.onValueChange) {
            this.onValueChange = component.onValueChange;
        }
    }
    get focusableId() {
        const component = this.component;
        if ('focusableId' in component) {
            return component.focusableId;
        }
        else if ('id' in component) {
            return component.id;
        }
        return "";
    }
    set focusableId(value) {
        const component = this.component;
        if ('focusableId' in component) {
            component.focusableId = value;
        }
        else if ('id' in component) {
            component.id = value;
        }
    }
}

const isFunction = (x) => Object.prototype.toString.call(x) === '[object Function]';
/**
 * @hidden
 */
let TextBoxContainerComponent = class TextBoxContainerComponent {
    constructor(elementRef, renderer, changeDetectorRef, rtl) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.changeDetectorRef = changeDetectorRef;
        /**
         * @hidden
         */
        this.focused = false;
        /**
         * @hidden
         */
        this.empty = true;
        /**
         * @hidden
         */
        this.invalid = false;
        this._subscriptions = [];
        this.autoFillStarted = false;
        this.direction = rtl ? 'rtl' : 'ltr';
        this.renderer.removeAttribute(this.elementRef.nativeElement, "id");
    }
    get hostClasses() {
        return true;
    }
    get textareaElementClass() {
        return !!this.textarea;
    }
    get focusedClass() {
        return this.focused;
    }
    get invalidClass() {
        return this.invalid;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (!this.formControl && !this.kendoInput) {
            if (isDevMode()) {
                throw new Error("The TextBoxContainer requires a Kendo Input component" +
                    " or a forms-bound component to function properly.");
            }
            return;
        }
        // add focus/blur/valueChange handlers
        const control = new FloatingLabelInputAdapter(this.kendoInput || this.formControl.valueAccessor, this.formControl);
        const setFocus = (isFocused) => () => {
            this.focused = isFocused;
            this.updateState();
        };
        this.subscribe(control, 'onFocus', setFocus(true));
        this.subscribe(control, 'onBlur', setFocus(false));
        this.subscribe(control, 'autoFillStart', () => {
            this.autoFillStarted = true;
            this.renderer.removeClass(this.elementRef.nativeElement, 'k-state-empty');
        });
        this.subscribe(control, 'autoFillEnd', () => {
            if (this.autoFillStarted) {
                this.autoFillStarted = false;
                if (this.empty) {
                    this.renderer.addClass(this.elementRef.nativeElement, 'k-state-empty');
                }
            }
        });
        const updateState = () => this.updateState();
        updateState();
        this.subscribe(control, 'onValueChange', updateState);
        // set label id for floating label
        if (this.id && control.focusableId) {
            // input wins
            this.id = control.focusableId;
        }
        else if (this.id) {
            control.focusableId = this.id;
        }
        else if (control.focusableId) {
            this.id = control.focusableId;
        }
        else {
            const id = "_" + guid();
            control.focusableId = id;
            this.id = id;
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._subscriptions.forEach(s => s.unsubscribe());
        this._subscriptions = [];
    }
    subscribe(control, eventName, handler) {
        if (control[eventName] instanceof EventEmitter) {
            const subscription = control[eventName].subscribe(handler);
            this._subscriptions.push(subscription);
        }
    }
    updateState() {
        const empty = value => {
            // zero is not an empty value (e.g., NumericTextBox)
            if (value === 0 || value === false) {
                return false;
            }
            // empty arrays are an empty value (e.g., MultiSelect)
            if (Array.isArray(value) && !value.length) {
                return true;
            }
            return !value;
        };
        const formControl = this.formControl;
        if (formControl) {
            const valueAccessor = formControl.valueAccessor;
            if (isFunction(valueAccessor.isEmpty)) {
                this.empty = valueAccessor.isEmpty();
            }
            else {
                this.empty = empty(formControl.value);
            }
            this.invalid = formControl.invalid && (formControl.touched || formControl.dirty);
        }
        else {
            this.empty = isFunction(this.kendoInput.isEmpty) ?
                this.kendoInput.isEmpty() : empty(this.kendoInput.value);
        }
        if (this.empty) {
            this.renderer.addClass(this.elementRef.nativeElement, 'k-state-empty');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'k-state-empty');
        }
        this.changeDetectorRef.markForCheck();
    }
}
TextBoxContainerComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: TextBoxContainerComponent, selectors: [["kendo-textbox-container"]], factory: function TextBoxContainerComponent_Factory(t) { return new (t || TextBoxContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(RTL, 8)); }, contentQueries: function TextBoxContainerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, KendoInput, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, TextAreaDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgControl, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.kendoInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.textarea = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.formControl = _t.first);
    } }, hostBindings: function TextBoxContainerComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(5);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-textbox-container", ctx.hostClasses);
        ɵngcc0.ɵɵclassProp("k-textarea-wrapper", ctx.textareaElementClass);
        ɵngcc0.ɵɵclassProp("k-state-focused", ctx.focusedClass);
        ɵngcc0.ɵɵclassProp("k-state-invalid", ctx.invalidClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { id: "id", floatingLabel: "floatingLabel" }, ngContentSelectors: _c61, consts: 2, vars: 1, template: function TextBoxContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, TextBoxContainerComponent_label_1_Template, 2, 2, "label", _c59);
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.floatingLabel);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextBoxContainerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-textbox-container',
                template: `
        <ng-content></ng-content>
        <label *ngIf="floatingLabel" [for]="id" class="k-label">{{ floatingLabel }}</label>
    `
            }]
    }], function () { return [{ type: ElementRef }, { type: Renderer2 }, { type: ChangeDetectorRef }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [RTL]
            }] }]; }, { constructor: [], elementRef: [], renderer: [], changeDetectorRef: [], focused: [], empty: [], invalid: [], _subscriptions: [], autoFillStarted: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-textbox-container']
        }], textareaElementClass: [{
            type: HostBinding,
            args: ['class.k-textarea-wrapper']
        }], focusedClass: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], invalidClass: [{
            type: HostBinding,
            args: ['class.k-state-invalid']
        }], ngAfterContentInit: [], id: [{
            type: Input
        }], ngOnDestroy: [], subscribe: [], updateState: [], floatingLabel: [{
            type: Input
        }], kendoInput: [{
            type: ContentChild,
            args: [KendoInput, { static: false }]
        }], textarea: [{
            type: ContentChild,
            args: [TextAreaDirective, { static: false }]
        }], formControl: [{
            type: ContentChild,
            args: [NgControl, { static: false }]
        }] });;
__decorate([
    HostBinding('class.k-textbox-container'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TextBoxContainerComponent.prototype, "hostClasses", null);
__decorate([
    HostBinding('class.k-textarea-wrapper'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TextBoxContainerComponent.prototype, "textareaElementClass", null);
__decorate([
    HostBinding('class.k-state-focused'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TextBoxContainerComponent.prototype, "focusedClass", null);
__decorate([
    HostBinding('class.k-state-invalid'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TextBoxContainerComponent.prototype, "invalidClass", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], TextBoxContainerComponent.prototype, "direction", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxContainerComponent.prototype, "id", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxContainerComponent.prototype, "floatingLabel", void 0);
__decorate([
    ContentChild(KendoInput, { static: false }),
    __metadata("design:type", Object)
], TextBoxContainerComponent.prototype, "kendoInput", void 0);
__decorate([
    ContentChild(TextAreaDirective, { static: false }),
    __metadata("design:type", TextAreaDirective)
], TextBoxContainerComponent.prototype, "textarea", void 0);
__decorate([
    ContentChild(NgControl, { static: false }),
    __metadata("design:type", NgControl)
], TextBoxContainerComponent.prototype, "formControl", void 0);
TextBoxContainerComponent = __decorate([
    __param(3, Optional()), __param(3, Inject(RTL)),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        ChangeDetectorRef, Boolean])
], TextBoxContainerComponent);

var TextBoxDirective_1;
/**
 * Represents the [Kendo UI TextBox directive]({% slug overview_textbox %}) for the Inputs components for Angular.
 * Used to style the textbox of any `input` element.
 *
 * @example
 * ```ts-no-run
 * <input kendoTextBox />
 * <input kendoTextBox type="email" />
 * <input kendoTextBox type="password" />
 * ```
 */
let TextBoxDirective = TextBoxDirective_1 = class TextBoxDirective {
    constructor(renderer, inputElement, ngZone) {
        this.renderer = renderer;
        this.inputElement = inputElement;
        this.ngZone = ngZone;
        this.hostClass = true;
        /**
         * @hidden
         */
        this.onFocus = new EventEmitter();
        /**
         * @hidden
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         */
        this.onValueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillStart = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillEnd = new EventEmitter();
        this.listeners = [];
    }
    /**
     * @hidden
     */
    set value(text) {
        if (!this.inputElement) {
            return;
        }
        this.inputElement.nativeElement.value = (text === undefined || text === null) ? '' : text;
        this.onValueChange.emit();
    }
    /**
     * @hidden
     */
    get value() {
        return this.inputElement.nativeElement.value;
    }
    get id() {
        return this.inputElement.nativeElement.id;
    }
    set id(id) {
        this.renderer.setAttribute(this.inputElement.nativeElement, 'id', id);
    }
    ngAfterViewInit() {
        const input = this.inputElement.nativeElement;
        this.listeners = [
            this.renderer.listen(input, 'focus', () => this.onFocus.emit()),
            this.renderer.listen(input, 'blur', () => this.onBlur.emit())
        ];
        this.ngZone.runOutsideAngular(() => {
            this.renderer.listen(input, 'animationstart', (e) => {
                if (e.animationName === 'autoFillStart') {
                    this.autoFillStart.emit();
                }
                else if (e.animationName === 'autoFillEnd') {
                    this.autoFillEnd.emit();
                }
            });
        });
    }
    ngOnDestroy() {
        this.listeners.forEach(listener => listener());
    }
}
TextBoxDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: TextBoxDirective, selectors: [["input", "kendoTextBox", ""]], factory: function TextBoxDirective_Factory(t) { return new (t || TextBoxDirective)(ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(NgZone)); }, hostBindings: function TextBoxDirective_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-textbox", ctx.hostClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { value: "value" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: KendoInput,
                useExisting: forwardRef(() => TextBoxDirective_1)
            }])] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextBoxDirective, [{
        type: Directive,
        args: [{
                selector: 'input[kendoTextBox]',
                providers: [{
                        provide: KendoInput,
                        useExisting: forwardRef(() => TextBoxDirective_1)
                    }]
            }]
    }], function () { return [{ type: Renderer2 }, { type: ElementRef }, { type: NgZone }]; }, { constructor: [], renderer: [], inputElement: [], ngZone: [], hostClass: [{
            type: HostBinding,
            args: ['class.k-textbox']
        }], onFocus: [], onBlur: [], onValueChange: [], autoFillStart: [], autoFillEnd: [], listeners: [], value: [{
            type: Input
        }], value: [], id: [], id: [], ngAfterViewInit: [], ngOnDestroy: [] });;
__decorate([
    HostBinding('class.k-textbox'),
    __metadata("design:type", Boolean)
], TextBoxDirective.prototype, "hostClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TextBoxDirective.prototype, "value", null);
TextBoxDirective = TextBoxDirective_1 = __decorate([
    __metadata("design:paramtypes", [Renderer2,
        ElementRef,
        NgZone])
], TextBoxDirective);

/**
 * @hidden
 */
const createMaxValidator = (maxValue) => {
    return (c) => {
        if (!isPresent(maxValue) || !isPresent(c.value) || c.value <= maxValue) {
            return null;
        }
        return {
            maxError: {
                maxValue: maxValue,
                value: c.value
            }
        };
    };
};

/**
 * @hidden
 */
const createMinValidator = (minValue) => {
    return (c) => {
        if (!isPresent(minValue) || !isPresent(c.value) || c.value >= minValue) {
            return null;
        }
        return {
            minError: {
                minValue: minValue,
                value: c.value
            }
        };
    };
};

/**
 * @hidden
 */
const MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-min';
/**
 * @hidden
 */
const MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-max';
/**
 * @hidden
 */
const POINT = ".";
/**
 * @hidden
 */
const INITIAL_SPIN_DELAY = 500;
/**
 * @hidden
 */
const SPIN_DELAY = 50;
/**
 * @hidden
 */
const EXPONENT_REGEX = /[eE][\-+]?([0-9]+)/;

/**
 * @hidden
 */
const numericRegex = (options) => {
    const { autoCorrect, decimals, min } = options;
    let separator = options.separator;
    if (separator === POINT) {
        separator = '\\' + separator;
    }
    const signPattern = autoCorrect && min !== null && min >= 0 ? '' : '-?';
    let numberPattern;
    if (decimals === 0) {
        numberPattern = '\\d*';
    }
    else {
        numberPattern = `(?:(?:\\d+(${separator}\\d*)?)|(?:${separator}\\d*))?`;
    }
    return new RegExp(`^${signPattern}${numberPattern}$`);
};
/**
 * @hidden
 */
const decimalPart = (value) => {
    return value >= 0 ? Math.floor(value) : Math.ceil(value);
};
/**
 * @hidden
 */
const noop = (_) => { }; // tslint:disable-line:no-empty
/**
 * @hidden
 */
const defined = (value) => {
    return typeof value !== 'undefined';
};
/**
 * @hidden
 */
const isNumber = (value) => {
    return !isNaN(value) && value !== null;
};
/**
 * @hidden
 */
function pad(value, digits) {
    const count = digits - String(value).length;
    let result = value;
    if (count > 0) {
        const padString = new Array(count + 1).join("0");
        result = parseFloat(value + padString);
    }
    return result;
}
/**
 * @hidden
 */
const getDeltaFromMouseWheel = (e) => {
    let delta = 0;
    if (e.wheelDelta) {
        delta = e.wheelDelta / 120;
        delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
    }
    else if (e.detail) {
        delta = Math.round(-e.detail / 3);
    }
    return delta;
};
/**
 * @hidden
 */
const getCaretPosition = (element) => element.selectionStart;
/**
 * @hidden
 */
const extractSignificantNumericChars = (formattedString, separator) => {
    const significantCharacters = `${separator}0123456789-`;
    return formattedString.split('').reduce((acc, curr) => significantCharacters.includes(curr) ? ++acc : acc, 0);
};
/**
 * @hidden
 */
const isRightClick = (event) => {
    const isRightClickIE = event.button && event.button === 2;
    const isRightClickOther = event.which && event.which === 3;
    return isRightClickIE || isRightClickOther;
};

/**
 * @hidden
 */
var ArrowDirection;
(function (ArrowDirection) {
    ArrowDirection[ArrowDirection["Down"] = -1] = "Down";
    ArrowDirection[ArrowDirection["None"] = 0] = "None";
    ArrowDirection[ArrowDirection["Up"] = 1] = "Up";
})(ArrowDirection || (ArrowDirection = {}));

var NumericTextBoxComponent_1;
const PARSABLE_OPTIONS = ['min', 'max', 'step', 'decimals'];
const PARSABLE_DEFAULTS = {
    decimals: null,
    max: null,
    min: null,
    step: 1
};
const FOCUSED$1 = 'k-state-focused';
const FORMATTED_VALUE = 'k-formatted-value';
/**
 * Represents the [Kendo UI NumericTextBox component for Angular]({% slug overview_numerictextbox %}).
 */
let NumericTextBoxComponent = NumericTextBoxComponent_1 = class NumericTextBoxComponent {
    constructor(intl, renderer, localizationService, injector, ngZone, changeDetector, hostElement) {
        this.intl = intl;
        this.renderer = renderer;
        this.localizationService = localizationService;
        this.injector = injector;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Determines whether the NumericTextBox is disabled ([see example]({% slug disabled_numerictextbox %})).
         */
        this.disabled = false;
        /**
         * Determines whether the NumericTextBox is in its read-only state ([see example]({% slug readonly_numerictextbox %})).
         */
        this.readonly = false;
        /**
         * Sets the title of the `input` element of the NumericTextBox.
         */
        this.title = '';
        /**
         * Specifies whether the value will be auto-corrected based on the minimum and maximum values
         * ([see example]({% slug precision_numerictextbox %})).
         */
        this.autoCorrect = false;
        /**
         * Specifies the number of decimals that the user can enter when the input is focused
         * ([see example]({% slug precision_numerictextbox %})).
         */
        this.decimals = null;
        /**
         * Specifies the value that is used to increment or decrement the component value
         * ([see example]({% slug predefinedsteps_numerictextbox %})).
         */
        this.step = 1;
        /**
         * Specifies whether the **Up** and **Down** spin buttons will be rendered
         * ([see example]({% slug spinbuttons_numerictextbox %})).
         */
        this.spinners = true;
        /**
         * Determines whether the built-in minimum or maximum validators are enforced when a form is validated.
         *
         * > The 4.2.0 Angular version introduces the `min` and `max` validation directives. As a result, even if you set `rangeValidation`
         * to `false`, the built-in Angular validators will be executed.
         */
        this.rangeValidation = true;
        /**
         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Determines whether the value of the NumericTextBox will be changed via scrolling. Defaults to `true`.
         *
         * @default true
         */
        this.changeValueOnScroll = true;
        /**
         * Determines whether the whole value will be selected when the NumericTextBox is clicked. Defaults to `true`.
         */
        this.selectOnFocus = true;
        /**
         * Specifies the value of the NumericTextBox
         * ([see example]({% slug formats_numerictextbox %})).
         */
        this.value = null;
        /**
         * Fires each time the user selects a new value ([see example]({% slug overview_numerictextbox %}#toc-events)).
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user focuses the `input` element ([see example]({% slug overview_numerictextbox %}#toc-events)).
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the `input` element gets blurred ([see example]({% slug overview_numerictextbox %}#toc-events)).
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         */
        this.ArrowDirection = ArrowDirection;
        /**
         * @hidden
         */
        this.arrowDirection = ArrowDirection.None;
        this.inputValue = '';
        this.minValidateFn = noop;
        this.maxValidateFn = noop;
        this._format = "n2";
        this.isPasted = false;
        this.mouseDown = false;
        this.ngChange = noop;
        this.ngTouched = noop;
        this.ngValidatorChange = noop;
        /**
         * @hidden
         */
        this.increasePress = (e) => {
            this.arrowPress(ArrowDirection.Up, e);
        };
        /**
         * @hidden
         */
        this.decreasePress = (e) => {
            this.arrowPress(ArrowDirection.Down, e);
        };
        /**
         * @hidden
         */
        this.releaseArrow = () => {
            clearTimeout(this.spinTimeout);
            if (this.arrowDirection !== ArrowDirection.None) {
                this.arrowDirection = ArrowDirection.None;
                this.changeDetector.detectChanges();
            }
        };
        /**
         * @hidden
         */
        this.handlePaste = () => {
            this.isPasted = true;
        };
        /**
         * @hidden
         */
        this.handleInput = () => {
            const input = this.numericInput.nativeElement;
            let { selectionStart, selectionEnd, value: inputValue } = input;
            if (this.pressedKey === Keys.NumpadDecimal) {
                inputValue = this.replaceNumpadDotValue();
            }
            if (this.isPasted) {
                inputValue = this.formatInputValue(this.intl.parseNumber(inputValue));
            }
            if (!this.isValid(inputValue)) {
                input.value = this.inputValue;
                this.setSelection(selectionStart - 1, selectionEnd - 1);
                return;
            }
            const parsedValue = this.intl.parseNumber(inputValue);
            let value = this.restrictDecimals(parsedValue);
            if (this.autoCorrect) {
                const limited = this.limitInputValue(value);
                value = limited.value;
                selectionStart = limited.selectionStart;
                selectionEnd = limited.selectionEnd;
            }
            if (parsedValue !== value || this.hasTrailingZeros(inputValue) || !this.focused) {
                this.setInputValue(value);
                this.setSelection(selectionStart, selectionEnd);
            }
            else {
                this.inputValue = inputValue;
            }
            if (this.isPasted) {
                input.value = this.inputValue;
            }
            this.updateValue(value);
            this.previousSelection = null;
            this.isPasted = false;
        };
        /**
         * @hidden
         */
        this.handleDragEnter = () => {
            if (!this.focused && !this.isDisabled) {
                this.setInputValue(this.value, true);
            }
        };
        /**
         * @hidden
         */
        this.handleMouseDown = () => {
            this.mouseDown = true;
        };
        /**
         * @hidden
         */
        this.handleFocus = () => {
            if (!this.focused) {
                this.focused = true;
                if (!this.isDisabled) {
                    const shouldSelectAll = this.selectOnFocus || !this.mouseDown;
                    this.ngZone.runOutsideAngular(() => {
                        setTimeout(() => {
                            if (shouldSelectAll) {
                                this.selectAll();
                            }
                            else {
                                this.selectCaret();
                            }
                        }, 0);
                    });
                }
            }
            this.mouseDown = false;
            if (hasObservers(this.onFocus)) {
                this.ngZone.run(() => {
                    this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            //blur is thrown before input when dragging the input text in IE
            if (this.inputValue !== this.elementValue) {
                this.handleInput();
            }
            this.setInputValue();
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    this.onBlur.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleKeyDown = (e) => {
            if (this.isDisabled) {
                return;
            }
            let step;
            if (e.keyCode === Keys.ArrowDown) {
                step = -1;
            }
            else if (e.keyCode === Keys.ArrowUp) {
                step = 1;
            }
            if (step && this.step) {
                e.preventDefault();
                this.addStep(step);
            }
            const input = this.numericInput.nativeElement;
            this.previousSelection = {
                end: input.selectionEnd,
                start: input.selectionStart
            };
            this.pressedKey = e.keyCode;
        };
        /**
         * @hidden
         */
        this.handleWheel = (e) => {
            if (this.focused && !this.isDisabled && this.changeValueOnScroll) {
                e.preventDefault();
                const delta = getDeltaFromMouseWheel(e);
                this.addStep(delta);
            }
        };
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    /**
     * Specifies the number format which is used when the NumericTextBox is not focused
     * ([see example]({% slug formats_numerictextbox %})).
     * If `format` is set to `null` or `undefined`, the default format will be used.
     */
    get format() {
        const format = this._format;
        return format !== null && format !== undefined ? format : 'n2';
    }
    set format(value) {
        this._format = value;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    get widgetClasses() {
        return true;
    }
    ngOnInit() {
        this.subscriptions = this.localizationService
            .changes
            .subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.control = this.injector.get(NgControl, null);
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (anyChanged(PARSABLE_OPTIONS, changes, false)) {
            this.parseOptions(PARSABLE_OPTIONS.filter(option => changes[option]));
        }
        this.verifySettings();
        if (anyChanged(['min', 'max', 'rangeValidation'], changes, false)) {
            this.minValidateFn = this.rangeValidation ? createMinValidator(this.min) : noop;
            this.maxValidateFn = this.rangeValidation ? createMaxValidator(this.max) : noop;
            this.ngValidatorChange();
        }
        if (anyChanged(['autoCorrect', 'decimals', 'min'], changes)) {
            delete this.numericRegex;
        }
        if (anyChanged(['value', 'format'], changes, false)) {
            this.verifyValue(this.value);
            this.value = this.restrictModelValue(this.value);
            if (!this.focused || (this.intl.parseNumber(this.elementValue) !== this.value)) {
                this.setInputValue();
            }
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        clearTimeout(this.spinTimeout);
    }
    /**
     * @hidden
     */
    validate(control) {
        return this.minValidateFn(control) || this.maxValidateFn(control);
    }
    /**
     * @hidden
     */
    registerOnValidatorChange(fn) {
        this.ngValidatorChange = fn;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.verifyValue(value);
        let restrictedValue = this.restrictModelValue(value);
        this.value = restrictedValue;
        this.setInputValue();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.changeDetector.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * Focuses the NumericTextBox.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="numerictextbox.focus()">Focus NumericTextBox</button>
     *  <kendo-numerictextbox #numerictextbox></kendo-numerictextbox>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        invokeElementMethod(this.numericInput, 'focus');
    }
    /**
     * Blurs the NumericTextBox.
     */
    blur() {
        invokeElementMethod(this.numericInput, 'blur');
    }
    /**
     * Notifies the `NumericTextBoxComponent` that the input value should be changed.
     * Can be used to update the input after setting the component properties directly.
     */
    notifyValueChange() {
        this.setInputValue();
    }
    /**
     * @hidden
     */
    get incrementTitle() {
        return this.localizationService.get('increment');
    }
    /**
     * @hidden
     */
    get decrementTitle() {
        return this.localizationService.get('decrement');
    }
    get decimalSeparator() {
        const numberSymbols = this.intl.numberSymbols();
        return numberSymbols.decimal;
    }
    get elementValue() {
        return this.numericInput.nativeElement.value;
    }
    set elementValue(value) {
        this.renderer.setProperty(this.numericInput.nativeElement, 'value', value);
    }
    get focused() {
        return this.isFocused;
    }
    get hasDecimals() {
        return this.decimals !== null && this.decimals >= 0;
    }
    set focused(value) {
        if (this.isFocused !== value && this.numericWrap) {
            const wrap = this.numericWrap.nativeElement;
            const input = this.numericInput.nativeElement;
            if (value) {
                this.renderer.addClass(wrap, FOCUSED$1);
                if (!this.isDisabled) {
                    this.renderer.removeClass(input, FORMATTED_VALUE);
                }
            }
            else {
                this.renderer.removeClass(wrap, FOCUSED$1);
                this.renderer.addClass(input, FORMATTED_VALUE);
            }
            this.isFocused = value;
        }
    }
    get isDisabled() {
        return this.disabled || this.readonly;
    }
    arrowPress(direction, e) {
        e.preventDefault();
        if (this.isDisabled || isRightClick(e)) {
            return;
        }
        if (!mobileOS) {
            this.focused = true;
            this.focus();
        }
        if (this.arrowDirection !== direction) {
            this.arrowDirection = direction;
            this.changeDetector.detectChanges();
        }
        if (this.step) {
            this.spin(direction, INITIAL_SPIN_DELAY);
        }
        else {
            this.setInputValue();
        }
    }
    updateValue(value) {
        if (!areSame(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.changeDetector.markForCheck();
            });
        }
    }
    replaceNumpadDotValue() {
        let value = this.inputValue || "";
        if (this.previousSelection) {
            const input = this.numericInput.nativeElement;
            const { selectionStart, selectionEnd } = input;
            const { start, end } = this.previousSelection;
            input.value = value = value.substring(0, start) + this.decimalSeparator + value.substring(end);
            this.setSelection(selectionStart, selectionEnd);
        }
        return value;
    }
    isValid(value) {
        if (!this.numericRegex) {
            this.numericRegex = numericRegex({
                autoCorrect: this.autoCorrect,
                decimals: this.decimals,
                min: this.min,
                separator: this.decimalSeparator
            });
        }
        return this.numericRegex.test(value);
    }
    spin(step, timeout) {
        clearTimeout(this.spinTimeout);
        this.spinTimeout = window.setTimeout(() => {
            this.spin(step, SPIN_DELAY);
        }, timeout);
        this.addStep(step);
    }
    addStep(step) {
        let value = add(this.value || 0, this.step * step);
        value = this.limitValue(value);
        value = this.restrictDecimals(value);
        this.setInputValue(value);
        this.updateValue(value);
    }
    setSelection(start, end) {
        if (this.focused) {
            invokeElementMethod(this.numericInput, 'setSelectionRange', start, end);
        }
    }
    limitValue(value) {
        let result = value;
        if (!this.isInRange(value)) {
            if (isNumber(this.max) && value > this.max) {
                result = this.max;
            }
            if (isNumber(this.min) && value < this.min) {
                result = this.min;
            }
        }
        return result;
    }
    limitInputValue(value) {
        let { selectionStart, selectionEnd, value: enteredValue } = this.numericInput.nativeElement;
        let limitedValue = value;
        let selectToEnd = false;
        if (!this.isInRange(value)) {
            const lengthChange = enteredValue.length - String(this.inputValue).length;
            const { min, max } = this;
            const hasMax = isNumber(max);
            const hasMin = isNumber(min);
            let padLimit, replaceNext;
            let correctedValue = value;
            if (selectionStart === 0 && this.inputValue.substr(1) === enteredValue) {
                return {
                    selectionEnd: selectionEnd,
                    selectionStart: selectionStart,
                    value: null
                };
            }
            if (hasMax && value > max) {
                if (value > 0) {
                    replaceNext = true;
                }
                else {
                    padLimit = max;
                }
            }
            else if (hasMin && value < min) {
                if (value > 0) {
                    padLimit = min;
                }
                else {
                    replaceNext = true;
                }
            }
            if (padLimit) {
                const paddedValue = this.tryPadValue(value, padLimit);
                if (paddedValue && decimalPart(value) !== decimalPart(padLimit)) {
                    correctedValue = paddedValue;
                    selectToEnd = true;
                }
            }
            else if (replaceNext) {
                if (this.inputValue && selectionStart !== enteredValue.length) {
                    correctedValue = parseFloat(enteredValue.substr(0, selectionStart) +
                        enteredValue.substr(selectionStart + lengthChange));
                }
            }
            limitedValue = this.limitValue(correctedValue);
            selectToEnd = (selectToEnd || limitedValue !== correctedValue) && this.previousSelection &&
                (this.previousSelection.end - this.previousSelection.start + lengthChange) > 0;
        }
        return {
            selectionEnd: selectToEnd ? String(limitedValue).length : selectionEnd,
            selectionStart: selectionStart,
            value: limitedValue
        };
    }
    tryPadValue(value, limit) {
        const limitLength = String(Math.floor(limit)).length;
        const zeroPadded = pad(value, limitLength);
        const zeroPaddedNext = pad(value, limitLength + 1);
        let result;
        if (this.isInRange(zeroPadded)) {
            result = zeroPadded;
        }
        else if (this.isInRange(zeroPaddedNext)) {
            result = zeroPaddedNext;
        }
        return result;
    }
    isInRange(value) {
        return !isNumber(value) || ((!isNumber(this.min) || this.min <= value) && (!isNumber(this.max) || value <= this.max));
    }
    restrictModelValue(value) {
        let result = this.restrictDecimals(value, true);
        if (this.autoCorrect && this.limitValue(result) !== result) {
            result = null;
        }
        return result;
    }
    restrictDecimals(value, round) {
        let result = value;
        if (value && this.hasDecimals) {
            const decimals = this.decimals;
            const stringValue = String(value);
            if (round || EXPONENT_REGEX.test(stringValue)) {
                result = toFixedPrecision(value, decimals);
            }
            else {
                const parts = stringValue.split(POINT);
                let fraction = parts[1];
                if (fraction && fraction.length > decimals) {
                    fraction = fraction.substr(0, decimals);
                    result = parseFloat(`${parts[0]}${POINT}${fraction}`);
                }
            }
        }
        return result;
    }
    formatInputValue(value) {
        let stringValue = String(value);
        const exponentMatch = EXPONENT_REGEX.exec(stringValue);
        if (exponentMatch) {
            stringValue = value.toFixed(limitPrecision(parseInt(exponentMatch[1], 10)));
        }
        return stringValue.replace(POINT, this.decimalSeparator);
    }
    formatValue(value, focused) {
        let formattedValue;
        if (value === null || !defined(value) || value === '') {
            formattedValue = '';
        }
        else if (focused && !this.readonly) {
            formattedValue = this.formatInputValue(value);
        }
        else {
            formattedValue = this.intl.formatNumber(value, this.format);
        }
        return formattedValue;
    }
    setInputValue(value = this.value, focused = this.focused) {
        const formattedValue = this.formatValue(value, focused);
        this.elementValue = formattedValue;
        this.inputValue = formattedValue;
    }
    verifySettings() {
        if (!isDevMode()) {
            return;
        }
        if (this.min !== null && this.max !== null && this.min > this.max) {
            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);
        }
    }
    verifyValue(value) {
        if (isDevMode() && value && typeof value !== 'number') {
            throw new Error(`The NumericTextBox component requires value of type Number and ${JSON.stringify(value)} was set.`);
        }
    }
    parseOptions(options) {
        for (let idx = 0; idx < options.length; idx++) {
            const name = options[idx];
            const value = this[name];
            if (typeof value === 'string') {
                const parsed = parseFloat(value);
                const valid = !isNaN(parsed);
                if (isDevMode() && !valid && value !== '') {
                    throw new Error('The NumericTextBox component requires value of type Number or a String representing ' +
                        `a number for the ${name} property and ${JSON.stringify(value)} was set.`);
                }
                this[name] = valid ? parsed : PARSABLE_DEFAULTS[name];
            }
        }
    }
    intlChange() {
        delete this.numericRegex;
        if (this.numericInput && (!this.focused || !this.isValid(this.elementValue))) {
            this.setInputValue();
        }
    }
    hasTrailingZeros(inputValue) {
        if (this.hasDecimals && this.focused) {
            const fraction = inputValue.split(this.decimalSeparator)[1];
            return fraction && fraction.length > this.decimals && fraction.lastIndexOf('0') === fraction.length - 1;
        }
    }
    selectAll() {
        this.setInputValue();
        this.setSelection(0, this.inputValue.length);
    }
    selectCaret() {
        const caretPosition = getCaretPosition(this.numericInput.nativeElement);
        const formattedValue = this.elementValue;
        const partialValue = formattedValue.substring(0, caretPosition);
        this.setInputValue();
        if (partialValue.length) {
            const significantCharsInFormattedValue = extractSignificantNumericChars(partialValue, this.decimalSeparator);
            const adjustedSignificantChars = this.adjustSignificantChars(formattedValue, significantCharsInFormattedValue);
            this.setSelection(adjustedSignificantChars, adjustedSignificantChars);
        }
        else {
            this.setSelection(0, 0);
        }
    }
    numberOfLeadingZeroes(formattedValue) {
        const separatorIndex = formattedValue.indexOf(this.decimalSeparator);
        const matchedLeadingZeroes = formattedValue.match(/^[^1-9]*?(0+)/);
        if (matchedLeadingZeroes) {
            const lengthOfMatch = matchedLeadingZeroes[0].length;
            const lengthOfLeadingZeroesMatch = matchedLeadingZeroes[1].length;
            return lengthOfMatch === separatorIndex ? lengthOfLeadingZeroesMatch - 1 : lengthOfLeadingZeroesMatch;
        }
        return 0;
    }
    adjustSignificantChars(formattedValue, significantChars) {
        const leadingZeroes = this.numberOfLeadingZeroes(formattedValue);
        if (leadingZeroes > 0) {
            return Math.max(0, significantChars - leadingZeroes);
        }
        return significantChars;
    }
}
NumericTextBoxComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: NumericTextBoxComponent, selectors: [["kendo-numerictextbox"]], factory: function NumericTextBoxComponent_Factory(t) { return new (t || NumericTextBoxComponent)(ɵngcc0.ɵɵdirectiveInject(IntlService), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(Injector), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, viewQuery: function NumericTextBoxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c62, true);
        ɵngcc0.ɵɵstaticViewQuery(_c63, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.numericInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.numericWrap = _t.first);
    } }, hostBindings: function NumericTextBoxComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(3);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.widgetClasses);
        ɵngcc0.ɵɵclassProp("k-numerictextbox", ctx.widgetClasses);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { focusableId: "focusableId", disabled: "disabled", readonly: "readonly", title: "title", autoCorrect: "autoCorrect", decimals: "decimals", step: "step", spinners: "spinners", rangeValidation: "rangeValidation", tabindex: "tabindex", changeValueOnScroll: "changeValueOnScroll", selectOnFocus: "selectOnFocus", value: "value", format: "format", tabIndex: "tabIndex", max: "max", min: "min", placeholder: "placeholder", maxlength: "maxlength" }, outputs: { valueChange: "valueChange", onFocus: "focus", onBlur: "blur" }, exportAs: ["kendoNumericTextBox"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.numerictextbox' },
            { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NumericTextBoxComponent_1), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => NumericTextBoxComponent_1), multi: true },
            { provide: KendoInput, useExisting: forwardRef(() => NumericTextBoxComponent_1) }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], consts: 7, vars: 25, template: function NumericTextBoxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, _c64);
        ɵngcc0.ɵɵi18nAttributes(1, _c69);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "span", _c70, _c71);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵelement(4, "input", _c72, _c73);
        ɵngcc0.ɵɵtemplate(6, NumericTextBoxComponent_span_6_Template, 5, 16, "span", _c74);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabled);
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(14, _c82, ctx.handleWheel, ctx.handleWheel));
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("tabindex", ctx.tabIndex)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction7(17, _c83, ctx.handleMouseDown, ctx.handleDragEnter, ctx.handleKeyDown, ctx.handleInput, ctx.handleFocus, ctx.handleBlur, ctx.handlePaste));
        ɵngcc0.ɵɵattribute("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value)("title", ctx.title)("placeholder", ctx.placeholder)("maxLength", ctx.maxlength);
        ɵngcc0.ɵɵselect(6);
        ɵngcc0.ɵɵproperty("ngIf", ctx.spinners);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NumericTextBoxComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoNumericTextBox',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.numerictextbox' },
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NumericTextBoxComponent_1), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => NumericTextBoxComponent_1), multi: true },
                    { provide: KendoInput, useExisting: forwardRef(() => NumericTextBoxComponent_1) }
                ],
                selector: 'kendo-numerictextbox',
                template: `
        <ng-container kendoNumericTextBoxLocalizedMessages
            i18n-increment="kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox"
            increment="Increase value"
            i18n-decrement="kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox"
            decrement="Decrease value"
        >
        </ng-container>
        <span
            class="k-numeric-wrap"
            [class.k-state-disabled]="disabled"
            [kendoEventsOutsideAngular]="{ mousewheel: handleWheel, DOMMouseScroll: handleWheel }"
            #numericWrap>
            <input
            role="spinbutton"
            class="k-input k-formatted-value"
            autocomplete="off"
            autocorrect="off"
            [id]="focusableId"
            [attr.aria-valuemin]="min"
            [attr.aria-valuemax]="max"
            [attr.aria-valuenow]="value"
            [attr.title]="title"
            [attr.placeholder]="placeholder"
            [attr.maxLength]="maxlength"
            [tabindex]="tabIndex"
            [disabled]="disabled"
            [readonly]="readonly"
            [kendoEventsOutsideAngular]="{
                mousedown: handleMouseDown,
                dragenter: handleDragEnter,
                keydown: handleKeyDown,
                input: handleInput,
                focus: handleFocus,
                blur: handleBlur,
                paste: handlePaste
            }"
            #numericInput />
            <span class="k-select" *ngIf="spinners" [kendoEventsOutsideAngular]="{ mouseup: releaseArrow, mouseleave: releaseArrow }">
                <span
                    role="button"
                    [kendoEventsOutsideAngular]="{ mousedown: increasePress }"
                    [attr.aria-label]="incrementTitle"
                    [title]="incrementTitle"
                    [class.k-state-active]="arrowDirection === ArrowDirection.Up"
                    class="k-link k-link-increase"
                >
                    <span class="k-icon k-i-arrow-n"></span>
                </span>
                <span
                    role="button"
                    [kendoEventsOutsideAngular]="{ mousedown: decreasePress }"
                    [attr.aria-label]="decrementTitle"
                    [title]="decrementTitle"
                    [class.k-state-active]="arrowDirection === ArrowDirection.Down"
                    class="k-link k-link-decrease"
                >
                    <span class="k-icon k-i-arrow-s"></span>
                </span>
            </span>
        </span>
      `
            }]
    }], function () { return [{ type: IntlService }, { type: Renderer2 }, { type: LocalizationService }, { type: Injector }, { type: NgZone }, { type: ChangeDetectorRef }, { type: ElementRef }]; }, { constructor: [], intl: [], renderer: [], localizationService: [], injector: [], ngZone: [], changeDetector: [], hostElement: [], focusableId: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], title: [{
            type: Input
        }], autoCorrect: [{
            type: Input
        }], decimals: [{
            type: Input
        }], step: [{
            type: Input
        }], spinners: [{
            type: Input
        }], rangeValidation: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], changeValueOnScroll: [{
            type: Input
        }], selectOnFocus: [{
            type: Input
        }], value: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], ArrowDirection: [], arrowDirection: [], inputValue: [], minValidateFn: [], maxValidateFn: [], _format: [], isPasted: [], mouseDown: [], ngChange: [], ngTouched: [], ngValidatorChange: [], increasePress: [], decreasePress: [], releaseArrow: [], handlePaste: [], handleInput: [], previousSelection: [], handleDragEnter: [], handleMouseDown: [], handleFocus: [], focused: [], focused: [], handleBlur: [], handleKeyDown: [], pressedKey: [], handleWheel: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], format: [{
            type: Input
        }], format: [], tabIndex: [{
            type: Input
        }], tabIndex: [], widgetClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-numerictextbox']
        }], ngOnInit: [], subscriptions: [], control: [], ngOnChanges: [], ngOnDestroy: [], validate: [], registerOnValidatorChange: [], writeValue: [], registerOnChange: [], registerOnTouched: [], setDisabledState: [], focus: [], blur: [], notifyValueChange: [], incrementTitle: [], decrementTitle: [], decimalSeparator: [], elementValue: [], elementValue: [], hasDecimals: [], isFocused: [], isDisabled: [], arrowPress: [], updateValue: [], replaceNumpadDotValue: [], isValid: [], numericRegex: [], spin: [], spinTimeout: [], addStep: [], setSelection: [], limitValue: [], limitInputValue: [], tryPadValue: [], isInRange: [], restrictModelValue: [], restrictDecimals: [], formatInputValue: [], formatValue: [], setInputValue: [], verifySettings: [], verifyValue: [], parseOptions: [], intlChange: [], hasTrailingZeros: [], selectAll: [], selectCaret: [], numberOfLeadingZeroes: [], adjustSignificantChars: [], max: [{
            type: Input
        }], min: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], maxlength: [{
            type: Input
        }], numericInput: [{
            type: ViewChild,
            args: ['numericInput', { static: true }]
        }], numericWrap: [{
            type: ViewChild,
            args: ['numericWrap', { static: true }]
        }] });;
__decorate([
    Input(),
    __metadata("design:type", String)
], NumericTextBoxComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NumericTextBoxComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "autoCorrect", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NumericTextBoxComponent.prototype, "format", null);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "decimals", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NumericTextBoxComponent.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "step", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "spinners", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "rangeValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], NumericTextBoxComponent.prototype, "tabIndex", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "changeValueOnScroll", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NumericTextBoxComponent.prototype, "selectOnFocus", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NumericTextBoxComponent.prototype, "maxlength", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], NumericTextBoxComponent.prototype, "valueChange", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], NumericTextBoxComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], NumericTextBoxComponent.prototype, "onBlur", void 0);
__decorate([
    ViewChild('numericInput', { static: true }),
    __metadata("design:type", ElementRef)
], NumericTextBoxComponent.prototype, "numericInput", void 0);
__decorate([
    ViewChild('numericWrap', { static: true }),
    __metadata("design:type", ElementRef)
], NumericTextBoxComponent.prototype, "numericWrap", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], NumericTextBoxComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-numerictextbox'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NumericTextBoxComponent.prototype, "widgetClasses", null);
NumericTextBoxComponent = NumericTextBoxComponent_1 = __decorate([
    __metadata("design:paramtypes", [IntlService,
        Renderer2,
        LocalizationService,
        Injector,
        NgZone,
        ChangeDetectorRef,
        ElementRef])
], NumericTextBoxComponent);

/**
 * @hidden
 */
class NumericTextBoxMessages extends ComponentMessages {
}
NumericTextBoxMessages.ngBaseDef = ɵngcc0.ɵɵdefineBase({ inputs: { decrement: "decrement", increment: "increment" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], NumericTextBoxMessages.prototype, "decrement", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NumericTextBoxMessages.prototype, "increment", void 0);

var NumericTextBoxCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages.
 */
let NumericTextBoxCustomMessagesComponent = NumericTextBoxCustomMessagesComponent_1 = class NumericTextBoxCustomMessagesComponent extends NumericTextBoxMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
NumericTextBoxCustomMessagesComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: NumericTextBoxCustomMessagesComponent, selectors: [["kendo-numerictextbox-messages"]], factory: function NumericTextBoxCustomMessagesComponent_Factory(t) { return new (t || NumericTextBoxCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NumericTextBoxMessages,
                useExisting: forwardRef(() => NumericTextBoxCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], consts: 0, vars: 0, template: function NumericTextBoxCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NumericTextBoxCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: NumericTextBoxMessages,
                        useExisting: forwardRef(() => NumericTextBoxCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-numerictextbox-messages',
                template: ``
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], service: [], override: [] });;
NumericTextBoxCustomMessagesComponent = NumericTextBoxCustomMessagesComponent_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], NumericTextBoxCustomMessagesComponent);

/**
 * @hidden
 */
var ResultType;
(function (ResultType) {
    ResultType[ResultType["Literal"] = 0] = "Literal";
    ResultType[ResultType["Mask"] = 1] = "Mask";
    ResultType[ResultType["Undefined"] = 2] = "Undefined";
})(ResultType || (ResultType = {}));
/**
 * @hidden
 */
class Result {
    constructor(value, rest, type = ResultType.Undefined) {
        this.value = value;
        this.rest = rest;
        this.type = type;
    }
    //map :: Functor f => f a ~> (a -> b) -> f b
    map(fn) {
        return new Result(fn(this.value), this.rest);
    }
    //chain :: Chain m => m a ~> (a -> m b) -> m b
    chain(fn) {
        return fn(this.value, this.rest);
    }
    fold(s, _ /*we don't need it*/) {
        return s(this.value, this.rest);
    }
    concat(r) {
        return this.map((vs, _) => r.chain((v, __) => vs.concat([v])));
    }
    toString() {
        return `Result({ value: '${this.value}', rest: ${this.rest} })`;
    }
}

/**
 * @hidden
 */
class Stream {
    constructor(input = [], control = []) {
        this.input = input;
        this.control = control;
        this.inputCursor = 0;
        this.controlCursor = 0;
    }
    eof() {
        return this.inputCursor >= this.input.length;
    }
    // Get the first value from the input.
    next() {
        return {
            char: this.input[this.inputCursor++],
            control: this.control[this.controlCursor++]
        };
    }
    peek() {
        return {
            char: this.input[this.inputCursor],
            control: this.control[this.controlCursor]
        };
    }
    eat_input() {
        this.inputCursor++;
    }
    eat_control() {
        this.controlCursor++;
    }
    eat() {
        this.inputCursor++;
        this.controlCursor++;
    }
}

const toArray = (value) => (value || '').split('');
const ESCAPE_CHARACTER = '\\';
/**
 * @hidden
 */
class Parser {
    constructor(parse) {
        this.parse = parse;
    }
    run(input, control = '') {
        if (input instanceof Stream) {
            return this.parse(input);
        }
        else {
            return this.parse(new Stream(toArray(input), toArray(control)));
        }
    }
    //map :: Functor f => f a ~> (a -> b) -> f b
    map(f) {
        return new Parser(stream => this.parse(stream).map(f));
    }
    //chain :: Chain m => m a ~> (a -> m b) -> m b
    chain(f) {
        return new Parser(stream => this.parse(stream).chain((v, s) => f(v).run(s)));
    }
    isLiteral(c) {
        return this.run(c).type === ResultType.Literal;
    }
}
/**
 * @hidden
 */
const mask = ({ prompt, promptPlaceholder }) => rule => new Parser(stream => {
    while (!stream.eof()) {
        const { char, control } = stream.peek();
        if (char === control && control === prompt) {
            stream.eat();
            return new Result(prompt, stream, ResultType.Mask);
        }
        if (rule.test(char)) {
            stream.eat();
            return new Result(char, stream, ResultType.Mask);
        }
        if (char === promptPlaceholder) {
            stream.eat();
            return new Result(prompt, stream, ResultType.Mask);
        }
        stream.eat_input();
    }
    stream.eat();
    return new Result(prompt, stream, ResultType.Mask);
});
/**
 * @hidden
 */
const literal = _token => new Parser(stream => {
    //    let {char, control} = stream.peek();
    let char = stream.peek().char;
    if (char === _token) {
        stream.eat();
        return new Result(_token, stream, ResultType.Literal);
    }
    //    if (control === _token) {
    //        while (!stream.eof() && char !== _token) {
    //            stream.eat_input();
    //            char = stream.peek().char;
    //        }
    //    }
    //
    //    if (control !== undefined) {
    //        stream.eat();
    //    }
    return new Result(_token, stream, ResultType.Literal);
});
/**
 * @hidden
 */
const unmask = prompt => rule => new Parser(stream => {
    while (!stream.eof()) {
        const { char, control } = stream.peek();
        if (char === prompt && control === prompt) {
            stream.eat();
            return new Result(char, stream);
        }
        if (rule.test(char)) {
            stream.eat();
            return new Result(char, stream);
        }
        stream.eat_input();
    }
    stream.eat();
    return new Result('', stream);
});
/**
 * @hidden
 */
const unliteral = _token => new Parser(stream => {
    if (stream.eof()) {
        return new Result('', stream);
    }
    const { char } = stream.peek();
    if (char === _token) {
        stream.eat();
    }
    return new Result(_token, stream);
});
/**
 * @hidden
 */
const token = (rules, creator) => new Parser(stream => {
    let { char } = stream.next();
    const rule = rules[char];
    if (char === ESCAPE_CHARACTER) {
        char = stream.next().char;
        return new Result(creator.literal(char), stream);
    }
    if (!rule) {
        return new Result(creator.literal(char), stream);
    }
    return new Result(creator.mask(rule), stream);
});
/**
 * @hidden
 */
const rawMask = ({ prompt, promptPlaceholder }) => new Parser(stream => {
    let { char } = stream.next();
    if (char === prompt) {
        return new Result(promptPlaceholder, stream);
    }
    return new Result(char, stream);
});
/**
 * @hidden
 */
const rawLiteral = includeLiterals => new Parser(stream => {
    let { char } = stream.next();
    if (includeLiterals) {
        return new Result(char, stream);
    }
    return new Result('', stream);
});

/**
 * @hidden
 */
const always = value => new Parser(stream => new Result(value, stream));
/**
 * @hidden
 */
const append = (p1, p2) => p1.chain(vs => p2.map(v => vs.concat([v])));
/**
 * @hidden
 */
const sequence = list => list.reduce((acc, parser) => append(acc, parser), always([]));
/**
 * @hidden
 */
const greedy = parser => new Parser(stream => {
    let result = new Result([], stream);
    while (!stream.eof()) {
        result = result.concat(parser.run(stream));
    }
    return result;
});

/**
 * @hidden
 */
let MaskingService = class MaskingService {
    /**
     * @hidden
     */
    constructor() {
        this.rules = {};
        this.prompt = "_";
        this.mask = "";
        this.promptPlaceholder = " ";
        this.includeLiterals = false;
        this.maskTokens = [];
        this.unmaskTokens = [];
        this.rawTokens = [];
        this.validationTokens = [];
    }
    update({ mask: mask$$1 = '', prompt = '', promptPlaceholder = ' ', rules = {}, includeLiterals = false }) {
        this.mask = mask$$1;
        this.prompt = prompt;
        this.promptPlaceholder = promptPlaceholder;
        this.rules = rules;
        this.includeLiterals = includeLiterals;
        this.tokenize();
    }
    validationValue(maskedValue = '') {
        let value = maskedValue;
        sequence(this.validationTokens)
            .run(maskedValue)
            .fold(unmasked => {
            value = unmasked.join('');
        });
        return value;
    }
    rawValue(maskedValue = '') {
        let value = maskedValue;
        if (!this.rawTokens.length) {
            return value;
        }
        sequence(this.rawTokens)
            .run(maskedValue)
            .fold(unmasked => {
            value = unmasked.join('');
        });
        return value;
    }
    /**
     * @hidden
     */
    maskRaw(rawValue = '') {
        let value = rawValue;
        if (!this.maskTokens.length) {
            return value;
        }
        sequence(this.maskTokens)
            .run(rawValue)
            .fold(masked => {
            value = masked.join('');
        });
        return value;
    }
    maskInput(input, control, splitPoint) {
        if (input.length < control.length) {
            return this.maskRemoved(input, control, splitPoint);
        }
        return this.maskInserted(input, control, splitPoint);
    }
    maskInRange(pasted, oldValue, start, end) {
        let value = '';
        let selection = end;
        const beforeChange = oldValue.split('').slice(0, start);
        const afterChange = oldValue.split('').slice(end);
        sequence(this.maskTokens.slice(start, end))
            .run(pasted)
            .fold(masked => {
            value = beforeChange
                .concat(masked)
                .concat(afterChange)
                .join('');
        });
        return {
            selection,
            value
        };
    }
    maskRemoved(input, control, splitPoint) {
        let value = '';
        let selection = splitPoint;
        const unchanged = input.split('').slice(splitPoint);
        const changed = input.split('').slice(0, splitPoint).join('');
        const take$$1 = this.maskTokens.length - (input.length - splitPoint);
        sequence(this.maskTokens.slice(0, take$$1))
            .run(changed, control)
            .fold(masked => {
            selection = this.adjustPosition(masked, selection);
            value = masked.concat(unchanged).join('');
        });
        return {
            selection,
            value
        };
    }
    adjustPosition(input, selection) {
        const caretChar = input[selection];
        const isLiteral = this.maskTokens[selection].isLiteral(caretChar);
        if (!isLiteral && caretChar !== this.prompt) {
            return selection + 1;
        }
        return selection;
    }
    maskInserted(input, control, splitPoint) {
        let value = '';
        let selection = splitPoint;
        const changed = input.slice(0, splitPoint);
        sequence(this.unmaskTokens)
            .run(changed, control)
            .chain(unmasked => {
            selection = unmasked.join('').length;
            const unchanged = control.slice(selection);
            return sequence(this.maskTokens)
                .run(unmasked.join('') + unchanged, control);
        })
            .fold(masked => {
            value = masked.join('');
        });
        return {
            selection,
            value
        };
    }
    get maskTokenCreator() {
        const { prompt, promptPlaceholder } = this;
        return {
            literal: rule => literal(rule),
            mask: rule => mask({ prompt, promptPlaceholder })(rule)
        };
    }
    get unmaskTokenCreator() {
        return {
            literal: rule => unliteral(rule),
            mask: rule => unmask(this.prompt)(rule)
        };
    }
    get rawTokenCreator() {
        const { prompt, promptPlaceholder, includeLiterals } = this;
        return {
            literal: _ => rawLiteral(includeLiterals),
            mask: _ => rawMask({ prompt, promptPlaceholder })
        };
    }
    get validationTokenCreator() {
        const { prompt } = this;
        return {
            literal: _ => rawLiteral(false),
            mask: _ => rawMask({ prompt, promptPlaceholder: '' })
        };
    }
    tokenize() {
        greedy(token(this.rules, this.maskTokenCreator))
            .run(this.mask)
            .fold((tokens, _) => {
            this.maskTokens = tokens;
        });
        greedy(token(this.rules, this.unmaskTokenCreator))
            .run(this.mask)
            .fold((tokens, _) => {
            this.unmaskTokens = tokens;
        });
        greedy(token(this.rules, this.rawTokenCreator))
            .run(this.mask)
            .fold((tokens, _) => {
            this.rawTokens = tokens;
        });
        greedy(token(this.rules, this.validationTokenCreator))
            .run(this.mask)
            .fold((tokens, _) => {
            this.validationTokens = tokens;
        });
    }
}
MaskingService.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: MaskingService, factory: function MaskingService_Factory(t) { return new (t || MaskingService)(); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MaskingService, [{
        type: Injectable
    }], function () { return []; }, { constructor: [], rules: [], prompt: [], mask: [], promptPlaceholder: [], includeLiterals: [], maskTokens: [], unmaskTokens: [], rawTokens: [], validationTokens: [], update: [], validationValue: [], rawValue: [], maskRaw: [], maskInput: [], maskInRange: [], maskRemoved: [], adjustPosition: [], maskInserted: [], maskTokenCreator: [], unmaskTokenCreator: [], rawTokenCreator: [], validationTokenCreator: [], tokenize: [] });;

var MaskedTextBoxComponent_1;
const resolvedPromise = Promise.resolve(null);
const FOCUSED$2 = 'k-state-focused';
/**
 * Represents the [Kendo UI MaskedTextBox component for Angular]({% slug overview_maskedtextbox %}).
 *
 * @example
 * ```ts-no-run
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *      <kendo-maskedtextbox
 *          [mask]="mask"
 *          [value]="value">
 *      </kendo-maskedtextbox>
 *     `
 * })
 *
 * class AppComponent {
 *  public value: string = "9580128055807792";
 *  public mask: string = "0000-0000-0000-0000";
 * }
 * ```
 */
let MaskedTextBoxComponent = MaskedTextBoxComponent_1 = class MaskedTextBoxComponent {
    constructor(service, renderer, hostElement, ngZone, injector, changeDetector, rtl) {
        this.service = service;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.ngZone = ngZone;
        this.injector = injector;
        this.changeDetector = changeDetector;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Determines whether the MaskedTextBox is disabled ([see example]({% slug disabled_maskedtextbox %})).
         */
        this.disabled = false;
        /**
         * Determines whether the MaskedTextBox is in its read-only state ([see example]({% slug readonly_maskedtextbox %})).
         */
        this.readonly = false;
        this.hostClasses = true;
        /**
         * Represents a prompt character for the masked value.
         * @default `_`
         */
        this.prompt = '_';
        /**
         * Indicates a character which represents an empty position in the raw value.
         * @default ' '
         */
        this.promptPlaceholder = ' ';
        /**
         * Indicates whether to include literals in the raw value  ([see example]({% slug value_maskedtextbox %})).
         * @default false
         */
        this.includeLiterals = false;
        /**
         * Specifies if the mask should be shown on focus for empty value.
         */
        this.maskOnFocus = false;
        /**
         * Determines whether the built-in mask validator is enforced when a form is validated
         * ([see example]({% slug validation_maskedtextbox %})).
         * @default true
         */
        this.maskValidation = true;
        /**
         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the `input` element.
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-maskedtextbox (focus)="handleFocus()"></kendo-maskedtextbox>
         * `
         * })
         * class AppComponent {
         *   public handleFocus(): void {
         *      console.log("Component is focused");
         *   }
         * }
         * ```
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the `input` element gets blurred.
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-maskedtextbox (blur)="handleBlur()"></kendo-maskedtextbox>
         * `
         * })
         * class AppComponent {
         *   public handleBlur(): void {
         *      console.log("Component is blurred");
         *   }
         * }
         * ```
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the value changes.
         */
        this.valueChange = new EventEmitter();
        this.focusClick = false;
        this.defaultRules = {
            "#": /[\d\s\+\-]/,
            "&": /[\S]/,
            "0": /[\d]/,
            "9": /[\d\s]/,
            "?": /[a-zA-Z\s]/,
            "A": /[a-zA-Z0-9]/,
            "C": /./,
            "L": /[a-zA-Z]/,
            "a": /[a-zA-Z0-9\s]/
        };
        this.isPasted = false;
        this.selection = [0, 0];
        /**
         * @hidden
         */
        this.handleFocus = () => {
            this.focused = true;
            if (this.maskOnFocus && this.emptyMask) {
                this.updateInput(this.service.maskRaw(this.value));
                this.ngZone.runOutsideAngular(() => {
                    setTimeout(() => { this.setSelection(0, 0); }, 0);
                });
            }
            if (hasObservers(this.onFocus)) {
                this.ngZone.run(() => {
                    this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleClick = () => {
            if (this.focused && !this.focusClick) {
                this.focusClick = true;
                const { selectionStart, selectionEnd } = this.input.nativeElement;
                if (selectionStart === selectionEnd) {
                    this.setFocusSelection();
                }
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            this.focusClick = false;
            if (this.maskOnFocus && this.emptyMask) {
                this.updateInput(this.maskedValue);
            }
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.onTouched();
                    this.onBlur.emit();
                });
            }
        };
        this.onChange = (_) => { };
        this.onTouched = () => { };
        validatePackage(packageMetadata);
        this.direction = rtl ? 'rtl' : 'ltr';
        this.updateService();
    }
    get hostDisabledClass() {
        return this.disabled;
    }
    /**
     * Exposes the RegExp-based mask validation array ([see example]({% slug masks_maskedtextbox %})).
     */
    get rules() {
        return this._rules || this.defaultRules;
    }
    set rules(value) {
        this._rules = Object.assign({}, this.defaultRules, value);
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    ngOnInit() {
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.control = this.injector.get(NgControl, null);
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the MaskedTextBox is empty.
     */
    isEmpty() {
        if (this.input) {
            return !Boolean(this.input.nativeElement.value);
        }
    }
    /**
     * @hidden
     */
    handleDragDrop() {
        return false;
    }
    /**
     * Focuses the MaskedTextBox.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="maskedinput.focus()">Focus the input</button>
     *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.input) {
            return;
        }
        this.input.nativeElement.focus();
        this.setFocusSelection();
    }
    /**
     * Blurs the MaskedTextBox.
     */
    blur() {
        if (!this.input) {
            return;
        }
        this.input.nativeElement.blur();
    }
    /**
     * @hidden
     */
    pasteHandler(e) {
        const { selectionStart, selectionEnd } = e.target;
        if (selectionEnd === selectionStart) {
            return;
        }
        this.isPasted = true;
        this.selection = [selectionStart, selectionEnd];
    }
    /**
     * @hidden
     */
    inputHandler(e) {
        const value = e.target.value;
        const [start, end] = this.selection;
        if (!this.mask) {
            this.updateValue(value);
            this.isPasted = false;
            return;
        }
        let result;
        if (this.isPasted) {
            this.isPasted = false;
            const rightPart = this.maskedValue.length - end;
            const to = value.length - rightPart;
            result = this.service.maskInRange(value.slice(start, to), this.maskedValue, start, end);
        }
        else {
            result = this.service.maskInput(value, this.maskedValue, e.target.selectionStart);
        }
        this.updateInput(result.value, result.selection);
        this.updateValue(result.value);
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (changes.value) {
            this.value = this.normalizeValue();
        }
        if (!this.mask) {
            this.updateInput(this.value);
            return;
        }
        const next = this.extractChanges(changes);
        this.updateService(next);
        if (isChanged('value', changes)) {
            const maskedValue = this.service.maskRaw(this.value);
            if (maskedValue !== this.maskedValue) {
                this.updateInput(maskedValue);
            }
        }
        else if (anyChanged(['promptPlaceholder', 'includeLiterals'], changes)) {
            resolvedPromise.then(() => {
                this.updateValue(this.maskedValue);
            });
        }
        else {
            this.updateInput(this.service.maskRaw(this.value));
        }
    }
    /**
     * @hidden
     * Writes a new value to the element.
     */
    writeValue(value) {
        this.value = this.normalizeValue(value);
        this.updateInput(this.service.maskRaw(this.value));
    }
    /**
     * @hidden
     * Sets the function that will be called when a `change` event is triggered.
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @hidden
     * Sets the function that will be called when a `touch` event is triggered.
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.changeDetector.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    validate(_) {
        if (this.maskValidation === false || !this.mask) {
            return null;
        }
        if (!this.service.validationValue(this.maskedValue)) {
            return null;
        }
        if (this.maskedValue.indexOf(this.prompt) !== -1) {
            return {
                patternError: {
                    mask: this.mask,
                    maskedValue: this.maskedValue,
                    value: this.value
                }
            };
        }
        return null;
    }
    /**
     * @hidden
     */
    updateValue(maskedValue) {
        if (this.mask && !this.service.validationValue(maskedValue)) {
            this.value = '';
        }
        else {
            this.value = this.service.rawValue(maskedValue);
        }
        this.onChange(this.value);
        this.valueChange.emit(this.value);
    }
    updateInput(maskedValue = '', selection) {
        this.maskedValue = maskedValue;
        const value = this.maskOnFocus && !this.focused && this.emptyMask ? '' : maskedValue;
        this.renderer.setProperty(this.input.nativeElement, "value", value);
        if (selection !== undefined) {
            this.setSelection(selection, selection);
        }
    }
    extractChanges(changes) {
        return Object.keys(changes).filter(key => key !== 'rules').reduce((obj, key) => {
            obj[key] = changes[key].currentValue;
            return obj;
        }, {}); // tslint:disable-line:align
    }
    updateService(extra) {
        const config = Object.assign({
            includeLiterals: this.includeLiterals,
            mask: this.mask,
            prompt: this.prompt,
            promptPlaceholder: this.promptPlaceholder,
            rules: this.rules
        }, extra); // tslint:disable-line:align
        this.service.update(config);
    }
    setSelection(start = this.selection[0], end = this.selection[1]) {
        if (this.focused) {
            invokeElementMethod(this.input, 'setSelectionRange', start, end);
        }
    }
    get emptyMask() {
        return this.service.maskRaw() === this.maskedValue;
    }
    setFocusSelection() {
        const selectionStart = this.input.nativeElement.selectionStart;
        const index = this.maskedValue ? this.maskedValue.indexOf(this.prompt) : 0;
        if (index >= 0 && index < selectionStart) {
            this.selection = [index, index];
            this.setSelection();
        }
    }
    get focused() {
        return this.isFocused;
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            const element = this.hostElement.nativeElement;
            if (value) {
                this.renderer.addClass(element, FOCUSED$2);
            }
            else {
                this.renderer.removeClass(element, FOCUSED$2);
            }
            this.isFocused = value;
        }
    }
    normalizeValue(value = this.value) {
        const present = isPresent(value);
        if (present && typeof value !== 'string') {
            if (isDevMode()) {
                throw new Error('The MaskedTextBox component supports only string values.');
            }
            return String(value);
        }
        return present ? value : '';
    }
}
MaskedTextBoxComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: MaskedTextBoxComponent, selectors: [["kendo-maskedtextbox"]], factory: function MaskedTextBoxComponent_Factory(t) { return new (t || MaskedTextBoxComponent)(ɵngcc0.ɵɵdirectiveInject(MaskingService), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(Injector), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(RTL, 8)); }, viewQuery: function MaskedTextBoxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c84, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.input = _t.first);
    } }, hostBindings: function MaskedTextBoxComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(4);
        ɵngcc0.ɵɵlistener("paste", function MaskedTextBoxComponent_paste_HostBindingHandler($event) { return ctx.pasteHandler($event); });
        ɵngcc0.ɵɵlistener("input", function MaskedTextBoxComponent_input_HostBindingHandler($event) { return ctx.inputHandler($event); });
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses);
        ɵngcc0.ɵɵclassProp("k-maskedtextbox", ctx.hostClasses);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.hostDisabledClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { focusableId: "focusableId", disabled: "disabled", readonly: "readonly", prompt: "prompt", promptPlaceholder: "promptPlaceholder", includeLiterals: "includeLiterals", maskOnFocus: "maskOnFocus", maskValidation: "maskValidation", tabindex: "tabindex", rules: "rules", tabIndex: "tabIndex", value: "value", title: "title", mask: "mask" }, outputs: { onFocus: "focus", onBlur: "blur", valueChange: "valueChange" }, exportAs: ["kendoMaskedTextBox"], features: [ɵngcc0.ɵɵProvidersFeature([
            MaskingService,
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => MaskedTextBoxComponent_1) /* tslint:disable-line */
            },
            {
                multi: true,
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => MaskedTextBoxComponent_1) /* tslint:disable-line */
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => MaskedTextBoxComponent_1)
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], consts: 2, vars: 12, template: function MaskedTextBoxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "input", _c85, _c86);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("tabindex", ctx.tabIndex)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction5(6, _c87, ctx.handleFocus, ctx.handleBlur, ctx.handleClick, ctx.handleDragDrop, ctx.handleDragDrop));
        ɵngcc0.ɵɵattribute("title", ctx.title);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MaskedTextBoxComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoMaskedTextBox',
                providers: [
                    MaskingService,
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => MaskedTextBoxComponent_1) /* tslint:disable-line */
                    },
                    {
                        multi: true,
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => MaskedTextBoxComponent_1) /* tslint:disable-line */
                    },
                    {
                        provide: KendoInput,
                        useExisting: forwardRef(() => MaskedTextBoxComponent_1)
                    }
                ],
                selector: 'kendo-maskedtextbox',
                template: `
        <input type="text"
            #input
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            class="k-textbox"
            [id]="focusableId"
            [tabindex]="tabIndex"
            [attr.title]="title"
            [disabled]="disabled"
            [readonly]="readonly"
            [kendoEventsOutsideAngular]="{
                focus: handleFocus,
                blur: handleBlur,
                click: handleClick,
                dragstart: handleDragDrop,
                drop: handleDragDrop
            }"
        />
    `
            }]
    }], function () { return [{ type: MaskingService }, { type: Renderer2 }, { type: ElementRef }, { type: NgZone }, { type: Injector }, { type: ChangeDetectorRef }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [RTL]
            }] }]; }, { constructor: [], service: [], renderer: [], hostElement: [], ngZone: [], injector: [], changeDetector: [], focusableId: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-maskedtextbox']
        }], prompt: [{
            type: Input
        }], promptPlaceholder: [{
            type: Input
        }], includeLiterals: [{
            type: Input
        }], maskOnFocus: [{
            type: Input
        }], maskValidation: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], valueChange: [{
            type: Output
        }], focusClick: [], defaultRules: [], isPasted: [], selection: [], handleFocus: [], focused: [], focused: [], handleClick: [], handleBlur: [], onChange: [], onTouched: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], hostDisabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], rules: [{
            type: Input
        }], rules: [], _rules: [], tabIndex: [{
            type: Input
        }], tabIndex: [], ngOnInit: [], control: [], isEmpty: [], handleDragDrop: [], focus: [], blur: [], pasteHandler: [{
            type: HostListener,
            args: ['paste', ['$event']]
        }], inputHandler: [{
            type: HostListener,
            args: ['input', ['$event']]
        }], ngOnChanges: [], value: [{
            type: Input
        }], writeValue: [], registerOnChange: [], registerOnTouched: [], setDisabledState: [], validate: [], updateValue: [], updateInput: [], maskedValue: [], extractChanges: [], updateService: [], setSelection: [], emptyMask: [], setFocusSelection: [], isFocused: [], normalizeValue: [], title: [{
            type: Input
        }], mask: [{
            type: Input
        }], input: [{
            type: ViewChild,
            args: ['input', { static: true }]
        }] });;
__decorate([
    Input(),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MaskedTextBoxComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MaskedTextBoxComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "title", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-maskedtextbox'),
    __metadata("design:type", Boolean)
], MaskedTextBoxComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], MaskedTextBoxComponent.prototype, "hostDisabledClass", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "mask", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MaskedTextBoxComponent.prototype, "rules", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "prompt", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MaskedTextBoxComponent.prototype, "promptPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MaskedTextBoxComponent.prototype, "includeLiterals", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MaskedTextBoxComponent.prototype, "maskOnFocus", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MaskedTextBoxComponent.prototype, "maskValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], MaskedTextBoxComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], MaskedTextBoxComponent.prototype, "tabIndex", null);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], MaskedTextBoxComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], MaskedTextBoxComponent.prototype, "onBlur", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MaskedTextBoxComponent.prototype, "valueChange", void 0);
__decorate([
    ViewChild('input', { static: true }),
    __metadata("design:type", ElementRef)
], MaskedTextBoxComponent.prototype, "input", void 0);
__decorate([
    HostListener('paste', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], MaskedTextBoxComponent.prototype, "pasteHandler", null);
__decorate([
    HostListener('input', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], MaskedTextBoxComponent.prototype, "inputHandler", null);
MaskedTextBoxComponent = MaskedTextBoxComponent_1 = __decorate([
    __param(6, Optional()), __param(6, Inject(RTL)),
    __metadata("design:paramtypes", [MaskingService,
        Renderer2,
        ElementRef,
        NgZone,
        Injector,
        ChangeDetectorRef, Boolean])
], MaskedTextBoxComponent);

/**
 * @hidden
 */
class SliderTick {
    constructor(value) {
        this.value = value;
        this.classes = {
            'k-tick': true
        };
    }
}
/**
 * @hidden
 */
let SliderTicksComponent = class SliderTicksComponent {
    constructor(rtl) {
        this.rtl = rtl;
        this.wrapperClasses = 'k-reset k-slider-items';
        this.ticks = [];
    }
    ngOnChanges(_) {
        this.createTicks();
    }
    createTicks() {
        const count = calculateTicksCount(this.min, this.max, this.step);
        const largeStep = this.largeStep;
        const tickValueProps = {
            max: this.max,
            min: this.min,
            smallStep: this.step
        };
        let result = [];
        for (let i = 0; i < count; i++) {
            result.push(new SliderTick(calculateValueFromTick(i, tickValueProps)));
            if (largeStep && i % largeStep === 0) {
                result[i].large = true;
                result[i].classes['k-tick-large'] = true;
            }
        }
        if (this.rtl || this.vertical) {
            result = result.reverse();
        }
        if (result.length > 0) {
            Object.assign(result[0].classes, this.endTickClasses(true));
            Object.assign(result[result.length - 1].classes, this.endTickClasses(false));
        }
        this.ticks = result;
    }
    endTickClasses(first) {
        return {
            'k-first': (first && !this.vertical) || (!first && this.vertical),
            'k-last': (!first && !this.vertical) || (first && this.vertical)
        };
    }
}
SliderTicksComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: SliderTicksComponent, selectors: [["", "kendoSliderTicks", ""]], factory: function SliderTicksComponent_Factory(t) { return new (t || SliderTicksComponent)(ɵngcc0.ɵɵdirectiveInject(RTL, 8)); }, viewQuery: function SliderTicksComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c88, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.tickElements = _t);
    } }, hostBindings: function SliderTicksComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.wrapperClasses);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { tickTitle: "tickTitle", vertical: "vertical", step: "step", largeStep: "largeStep", min: "min", max: "max", labelTemplate: "labelTemplate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c89, consts: 3, vars: 1, template: function SliderTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SliderTicksComponent_li_0_Template, 5, 5, "li", _c90);
        ɵngcc0.ɵɵtemplate(1, SliderTicksComponent_ng_template_1_Template, 1, 1, "ng-template", null, _c91, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(SliderTicksComponent, [{
        type: Component,
        args: [{
                selector: '[kendoSliderTicks]',
                template: `
    <li #tickElement *ngFor="let tick of ticks;"
        [ngClass]="tick.classes"
        title="{{ tickTitle(tick.value) }}"
        role="presentation"
     >
         <ng-container [ngSwitch]="tick.large">
            <span class="k-label" *ngSwitchCase="true">
                <ng-container [ngTemplateOutlet]="labelTemplate || defaultLabel" [ngTemplateOutletContext]="tick">
                </ng-container>
            </span>
            <ng-container *ngSwitchCase="false">&nbsp;</ng-container>
         </ng-container>
     </li>

     <ng-template #defaultLabel let-value="value">
        {{ tickTitle(value) }}
     </ng-template>
  `
            }]
    }], function () { return [{ type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [RTL]
            }] }]; }, { constructor: [], rtl: [], wrapperClasses: [{
            type: HostBinding,
            args: ['class']
        }], ticks: [], ngOnChanges: [], createTicks: [], endTickClasses: [], tickTitle: [{
            type: Input
        }], vertical: [{
            type: Input
        }], step: [{
            type: Input
        }], largeStep: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], labelTemplate: [{
            type: Input
        }], tickElements: [{
            type: ViewChildren,
            args: ['tickElement']
        }] });;
__decorate([
    HostBinding('class'),
    __metadata("design:type", String)
], SliderTicksComponent.prototype, "wrapperClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SliderTicksComponent.prototype, "tickTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SliderTicksComponent.prototype, "vertical", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderTicksComponent.prototype, "step", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderTicksComponent.prototype, "largeStep", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderTicksComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SliderTicksComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], SliderTicksComponent.prototype, "labelTemplate", void 0);
__decorate([
    ViewChildren('tickElement'),
    __metadata("design:type", QueryList)
], SliderTicksComponent.prototype, "tickElements", void 0);
SliderTicksComponent = __decorate([
    __param(0, Optional()), __param(0, Inject(RTL)),
    __metadata("design:paramtypes", [Boolean])
], SliderTicksComponent);

/**
 * @hidden
 */
let SlidersCommonModule = class SlidersCommonModule {
}
SlidersCommonModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: SlidersCommonModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(SlidersCommonModule, { declarations: function () { return [SliderTicksComponent,
        LabelTemplateDirective]; }, imports: function () { return [CommonModule, DraggableModule, EventsModule, ResizeSensorModule]; }, exports: function () { return [LabelTemplateDirective,
        SliderTicksComponent,
        DraggableModule,
        EventsModule,
        ResizeSensorModule]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(SlidersCommonModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SliderTicksComponent,
                    LabelTemplateDirective
                ],
                exports: [
                    LabelTemplateDirective,
                    SliderTicksComponent,
                    DraggableModule,
                    EventsModule,
                    ResizeSensorModule
                ],
                imports: [CommonModule, DraggableModule, EventsModule, ResizeSensorModule]
            }]
    }], null, null);
SlidersCommonModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function SlidersCommonModule_Factory(t) { return new (t || SlidersCommonModule)(); }, imports: [[CommonModule, DraggableModule, EventsModule, ResizeSensorModule]] });;

/**
 * @hidden
 */
class SliderMessages extends ComponentMessages {
}
SliderMessages.ngBaseDef = ɵngcc0.ɵɵdefineBase({ inputs: { decrement: "decrement", increment: "increment", dragHandle: "dragHandle" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderMessages.prototype, "decrement", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderMessages.prototype, "increment", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SliderMessages.prototype, "dragHandle", void 0);

var LocalizedSliderMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedSliderMessagesDirective = LocalizedSliderMessagesDirective_1 = class LocalizedSliderMessagesDirective extends SliderMessages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedSliderMessagesDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: LocalizedSliderMessagesDirective, selectors: [["", "kendoSliderLocalizedMessages", ""]], factory: function LocalizedSliderMessagesDirective_Factory(t) { return new (t || LocalizedSliderMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: SliderMessages,
                useExisting: forwardRef(() => LocalizedSliderMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(LocalizedSliderMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: SliderMessages,
                        useExisting: forwardRef(() => LocalizedSliderMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoSliderLocalizedMessages]'
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], service: [] });;
LocalizedSliderMessagesDirective = LocalizedSliderMessagesDirective_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], LocalizedSliderMessagesDirective);

var SliderCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages.
 */
let SliderCustomMessagesComponent = SliderCustomMessagesComponent_1 = class SliderCustomMessagesComponent extends SliderMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
SliderCustomMessagesComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: SliderCustomMessagesComponent, selectors: [["kendo-slider-messages"]], factory: function SliderCustomMessagesComponent_Factory(t) { return new (t || SliderCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: SliderMessages,
                useExisting: forwardRef(() => SliderCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], consts: 0, vars: 0, template: function SliderCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(SliderCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: SliderMessages,
                        useExisting: forwardRef(() => SliderCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-slider-messages',
                template: ``
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], service: [], override: [] });;
SliderCustomMessagesComponent = SliderCustomMessagesComponent_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], SliderCustomMessagesComponent);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Slider component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Inputs module
 * import { SliderModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, SliderModule], // import Slider module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let SliderModule = class SliderModule {
}
SliderModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: SliderModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(SliderModule, { declarations: function () { return [SliderComponent,
        SliderCustomMessagesComponent,
        LocalizedSliderMessagesDirective]; }, imports: function () { return [CommonModule,
        SlidersCommonModule]; }, exports: function () { return [SliderComponent,
        SliderCustomMessagesComponent,
        LabelTemplateDirective,
        LocalizedSliderMessagesDirective]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(SliderModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SliderComponent,
                    SliderCustomMessagesComponent,
                    LocalizedSliderMessagesDirective
                ],
                exports: [
                    SliderComponent,
                    SliderCustomMessagesComponent,
                    LabelTemplateDirective,
                    LocalizedSliderMessagesDirective
                ],
                imports: [CommonModule, SlidersCommonModule]
            }]
    }], null, null);
SliderModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function SliderModule_Factory(t) { return new (t || SliderModule)(); }, imports: [[CommonModule, SlidersCommonModule]] });;

/**
 * @hidden
 */
class RangeSliderMessages extends ComponentMessages {
}
RangeSliderMessages.ngBaseDef = ɵngcc0.ɵɵdefineBase({ inputs: { dragHandleStart: "dragHandleStart", dragHandleEnd: "dragHandleEnd" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], RangeSliderMessages.prototype, "dragHandleStart", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RangeSliderMessages.prototype, "dragHandleEnd", void 0);

var LocalizedRangeSliderMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedRangeSliderMessagesDirective = LocalizedRangeSliderMessagesDirective_1 = class LocalizedRangeSliderMessagesDirective extends RangeSliderMessages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedRangeSliderMessagesDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: LocalizedRangeSliderMessagesDirective, selectors: [["", "kendoSliderLocalizedMessages", ""]], factory: function LocalizedRangeSliderMessagesDirective_Factory(t) { return new (t || LocalizedRangeSliderMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: RangeSliderMessages,
                useExisting: forwardRef(() => LocalizedRangeSliderMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(LocalizedRangeSliderMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: RangeSliderMessages,
                        useExisting: forwardRef(() => LocalizedRangeSliderMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoSliderLocalizedMessages]'
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], service: [] });;
LocalizedRangeSliderMessagesDirective = LocalizedRangeSliderMessagesDirective_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], LocalizedRangeSliderMessagesDirective);

var RangeSliderCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages.
 */
let RangeSliderCustomMessagesComponent = RangeSliderCustomMessagesComponent_1 = class RangeSliderCustomMessagesComponent extends RangeSliderMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
RangeSliderCustomMessagesComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: RangeSliderCustomMessagesComponent, selectors: [["kendo-rangeslider-messages"]], factory: function RangeSliderCustomMessagesComponent_Factory(t) { return new (t || RangeSliderCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: RangeSliderMessages,
                useExisting: forwardRef(() => RangeSliderCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], consts: 0, vars: 0, template: function RangeSliderCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(RangeSliderCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: RangeSliderMessages,
                        useExisting: forwardRef(() => RangeSliderCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-rangeslider-messages',
                template: ``
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], service: [], override: [] });;
RangeSliderCustomMessagesComponent = RangeSliderCustomMessagesComponent_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], RangeSliderCustomMessagesComponent);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the RangeSlider component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Inputs module
 * import { RangeSliderModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, RangeSliderModule], // import RangeSlider module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let RangeSliderModule = class RangeSliderModule {
}
RangeSliderModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: RangeSliderModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(RangeSliderModule, { declarations: function () { return [RangeSliderComponent,
        RangeSliderCustomMessagesComponent,
        LocalizedRangeSliderMessagesDirective]; }, imports: function () { return [CommonModule,
        SlidersCommonModule]; }, exports: function () { return [RangeSliderComponent,
        RangeSliderCustomMessagesComponent,
        LocalizedRangeSliderMessagesDirective,
        LabelTemplateDirective]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(RangeSliderModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    RangeSliderComponent,
                    RangeSliderCustomMessagesComponent,
                    LocalizedRangeSliderMessagesDirective
                ],
                exports: [
                    RangeSliderComponent,
                    RangeSliderCustomMessagesComponent,
                    LocalizedRangeSliderMessagesDirective,
                    LabelTemplateDirective
                ],
                imports: [CommonModule, SlidersCommonModule]
            }]
    }], null, null);
RangeSliderModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function RangeSliderModule_Factory(t) { return new (t || RangeSliderModule)(); }, imports: [[CommonModule, SlidersCommonModule]] });;

/**
 * @hidden
 */
class Messages extends ComponentMessages {
}
Messages.ngBaseDef = ɵngcc0.ɵɵdefineBase({ inputs: { on: "on", off: "off" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "on", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], Messages.prototype, "off", void 0);

var LocalizedSwitchMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedSwitchMessagesDirective = LocalizedSwitchMessagesDirective_1 = class LocalizedSwitchMessagesDirective extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedSwitchMessagesDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: LocalizedSwitchMessagesDirective, selectors: [["", "kendoSwitchLocalizedMessages", ""]], factory: function LocalizedSwitchMessagesDirective_Factory(t) { return new (t || LocalizedSwitchMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => LocalizedSwitchMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(LocalizedSwitchMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => LocalizedSwitchMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoSwitchLocalizedMessages]'
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], service: [] });;
LocalizedSwitchMessagesDirective = LocalizedSwitchMessagesDirective_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], LocalizedSwitchMessagesDirective);

var SwitchCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages.
 */
let SwitchCustomMessagesComponent = SwitchCustomMessagesComponent_1 = class SwitchCustomMessagesComponent extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
SwitchCustomMessagesComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: SwitchCustomMessagesComponent, selectors: [["kendo-switch-messages"]], factory: function SwitchCustomMessagesComponent_Factory(t) { return new (t || SwitchCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => SwitchCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], consts: 0, vars: 0, template: function SwitchCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(SwitchCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => SwitchCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-switch-messages',
                template: ``
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], service: [], override: [] });;
SwitchCustomMessagesComponent = SwitchCustomMessagesComponent_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], SwitchCustomMessagesComponent);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Switch component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Switch module
 * import { SwitchModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, SwitchModule], // import Switch module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let SwitchModule = class SwitchModule {
}
SwitchModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: SwitchModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(SwitchModule, { declarations: function () { return [SwitchComponent,
        SwitchCustomMessagesComponent,
        LocalizedSwitchMessagesDirective]; }, imports: function () { return [CommonModule, EventsModule, ResizeSensorModule]; }, exports: function () { return [SwitchComponent,
        SwitchCustomMessagesComponent,
        LocalizedSwitchMessagesDirective]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(SwitchModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SwitchComponent,
                    SwitchCustomMessagesComponent,
                    LocalizedSwitchMessagesDirective
                ],
                exports: [
                    SwitchComponent,
                    SwitchCustomMessagesComponent,
                    LocalizedSwitchMessagesDirective
                ],
                imports: [CommonModule, EventsModule, ResizeSensorModule]
            }]
    }], null, null);
SwitchModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function SwitchModule_Factory(t) { return new (t || SwitchModule)(); }, imports: [[CommonModule, EventsModule, ResizeSensorModule]] });;

var LocalizedNumericTextBoxMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedNumericTextBoxMessagesDirective = LocalizedNumericTextBoxMessagesDirective_1 = class LocalizedNumericTextBoxMessagesDirective extends NumericTextBoxMessages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedNumericTextBoxMessagesDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: LocalizedNumericTextBoxMessagesDirective, selectors: [["", "kendoNumericTextBoxLocalizedMessages", ""]], factory: function LocalizedNumericTextBoxMessagesDirective_Factory(t) { return new (t || LocalizedNumericTextBoxMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NumericTextBoxMessages,
                useExisting: forwardRef(() => LocalizedNumericTextBoxMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(LocalizedNumericTextBoxMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: NumericTextBoxMessages,
                        useExisting: forwardRef(() => LocalizedNumericTextBoxMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoNumericTextBoxLocalizedMessages]'
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], service: [] });;
LocalizedNumericTextBoxMessagesDirective = LocalizedNumericTextBoxMessagesDirective_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], LocalizedNumericTextBoxMessagesDirective);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the NumericTextBox component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the NumericTextBox module
 * import { NumericTextBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, NumericTextBoxModule], // import NumericTextBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let NumericTextBoxModule = class NumericTextBoxModule {
}
NumericTextBoxModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: NumericTextBoxModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(NumericTextBoxModule, { declarations: function () { return [LocalizedNumericTextBoxMessagesDirective,
        NumericTextBoxComponent,
        NumericTextBoxCustomMessagesComponent]; }, imports: function () { return [CommonModule, EventsModule]; }, exports: function () { return [NumericTextBoxComponent,
        NumericTextBoxCustomMessagesComponent]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NumericTextBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    LocalizedNumericTextBoxMessagesDirective,
                    NumericTextBoxComponent,
                    NumericTextBoxCustomMessagesComponent
                ],
                exports: [
                    NumericTextBoxComponent,
                    NumericTextBoxCustomMessagesComponent
                ],
                imports: [CommonModule, EventsModule]
            }]
    }], null, null);
NumericTextBoxModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function NumericTextBoxModule_Factory(t) { return new (t || NumericTextBoxModule)(); }, imports: [[CommonModule, EventsModule]] });;

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the MaskedTextBox component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the MaskedTextBox module
 * import { MaskedTextBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, MaskedTextBoxModule], // import MaskedTextBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let MaskedTextBoxModule = class MaskedTextBoxModule {
}
MaskedTextBoxModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: MaskedTextBoxModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(MaskedTextBoxModule, { declarations: function () { return [MaskedTextBoxComponent]; }, imports: function () { return [CommonModule, EventsModule]; }, exports: function () { return [MaskedTextBoxComponent]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MaskedTextBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [MaskedTextBoxComponent],
                exports: [MaskedTextBoxComponent],
                imports: [CommonModule, EventsModule]
            }]
    }], null, null);
MaskedTextBoxModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function MaskedTextBoxModule_Factory(t) { return new (t || MaskedTextBoxModule)(); }, imports: [[CommonModule, EventsModule]] });;

/**
 * @hidden
 *
 * Returns true if the used browser is Safari.
 */
const isSafari = (userAgent) => {
    return detectDesktopBrowser(userAgent).safari ||
        (detectMobileOS(userAgent) && detectMobileOS(userAgent).browser === 'mobilesafari');
};
/**
 * @hidden
 *
 * Checks if input is Japanese IME
 */
const isJapanese = (input) => {
    const japaneseRegex = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
    return japaneseRegex.test(input);
};

/**
 * Specifies the adornments in the suffix container ([see examples]({% slug adornments_textbox %}#toc-suffixadornments)).
 *  @example
 * ```ts-no-run
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-textbox>
 *    <ng-template kendoTextBoxSuffixTemplate>
 *        <button kendoButton look="clear" icon="image"></button>
 *    </ng-template>
 *  </kendo-textbox>
 * `
 * })
 * class AppComponent {}
 * ```
 */
let TextBoxSuffixTemplateDirective = class TextBoxSuffixTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TextBoxSuffixTemplateDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: TextBoxSuffixTemplateDirective, selectors: [["", "kendoTextBoxSuffixTemplate", ""]], factory: function TextBoxSuffixTemplateDirective_Factory(t) { return new (t || TextBoxSuffixTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(TemplateRef, 8)); } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextBoxSuffixTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTextBoxSuffixTemplate]'
            }]
    }], function () { return [{ type: TemplateRef, decorators: [{
                type: Optional
            }] }]; }, { constructor: [], templateRef: [] });;
TextBoxSuffixTemplateDirective = __decorate([
    __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], TextBoxSuffixTemplateDirective);

/**
 * Specifies the adornments in the prefix container ([see examples]({% slug adornments_textbox %}#toc-prefixadornments)).
 * @example
 * ```ts-no-run
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-textbox>
 *    <ng-template kendoTextBoxPrefixTemplate>
 *        <button kendoButton look="clear" icon="image"></button>
 *    </ng-template>
 *  </kendo-textbox>
 * `
 * })
 * class AppComponent {}
 * ```
 */
let TextBoxPrefixTemplateDirective = class TextBoxPrefixTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TextBoxPrefixTemplateDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: TextBoxPrefixTemplateDirective, selectors: [["", "kendoTextBoxPrefixTemplate", ""]], factory: function TextBoxPrefixTemplateDirective_Factory(t) { return new (t || TextBoxPrefixTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(TemplateRef, 8)); } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextBoxPrefixTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTextBoxPrefixTemplate]'
            }]
    }], function () { return [{ type: TemplateRef, decorators: [{
                type: Optional
            }] }]; }, { constructor: [], templateRef: [] });;
TextBoxPrefixTemplateDirective = __decorate([
    __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], TextBoxPrefixTemplateDirective);

var TextBoxComponent_1;
const FOCUSED$3 = 'k-state-focused';
let TextBoxComponent = TextBoxComponent_1 = class TextBoxComponent {
    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        this.injector = injector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Sets the `title` attribute of the `input` element of the TextBox.
         */
        this.title = '';
        /**
         * Sets the disabled state of the component.
         *
         * @default false
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         *
         * @default false
         */
        this.readonly = false;
        /**
         * Specifies the `tabindex` of the TextBox.
         *
         * @default 0
         */
        this.tabindex = 0;
        /**
         * Provides a value for the TextBox.
         */
        this.value = null;
        /**
         * Determines whether the whole value will be selected when the TextBox is clicked. Defaults to `false`.
         *
         * @default false
         */
        this.selectOnFocus = false;
        /**
         * Specifies when the Success icon will be shown ([see example]({% slug validation_textbox %})).
         *
         * The possible values are:
         *
         * `boolean`&mdash;The Success icon is displayed, if the condition given by the developer is met.
         *
         * `initial`&mdash;The Success icon will be displayed when the component state is neither `invalid` nor `touched` or `dirty`.
         *
         * @default false
         */
        this.showSuccessIcon = false;
        /**
         * Specifies when the Error icon will be shown ([see example]({% slug validation_textbox %})).
         *
         * The possible values are:
         *
         * * `initial`&mdash;The Error icon will be displayed when the component state is
         * `invalid` and `touched` or `dirty`.
         * * `boolean`&mdash;The Error icon is displayed, if the condition given by the developer is met.
         *
         * @default false
         */
        this.showErrorIcon = false;
        /**
         * Specifies whether a Clear button will be rendered.
         *
         * @default false
         */
        this.clearButton = false;
        /**
         * Fires each time the value is changed&mdash;
         * when the component is blurred or the value is cleared through the **Clear** button
         * ([see example]({% slug overview_textbox %}#toc-events)).
         * When the value of the component is programmatically changed to `ngModel` or `formControl`
         * through its API or form binding, the `valueChange` event is not triggered because it
         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user focuses the `input` element.
         */
        this.inputFocus = new EventEmitter();
        /**
         * Fires each time the `input` element gets blurred.
         */
        this.inputBlur = new EventEmitter();
        /**
         * Fires each time the user focuses the TextBox component.
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textbox (focus)="handleFocus()"></kendo-textbox>
         * `
         * })
         * class AppComponent {
         *   public handleFocus(): void {
         *      console.log('Component is isFocused');
         *   }
         * }
         * ```
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the TextBox component gets blurred.
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textbox (blur)="handleBlur()"></kendo-textbox>
         * `
         * })
         * class AppComponent {
         *   public handleBlur(): void {
         *      console.log('Component is blurred');
         *   }
         * }
         * ```
         */
        this.onBlur = new EventEmitter();
        this.hostClass = true;
        this._isFocused = false;
        this.focusChangedProgrammatically = false;
        /**
         * @hidden
         */
        this.handleInputFocus = () => {
            if (!this.disabled) {
                if (this.selectOnFocus && this.value) {
                    this.ngZone.run(() => {
                        setTimeout(() => { this.selectAll(); });
                    });
                }
                if (hasObservers(this.onFocus)) {
                    if (!this.isFocused) {
                        this.ngZone.run(() => {
                            this.onFocus.emit();
                        });
                    }
                }
                if (hasObservers(this.inputFocus)) {
                    if (!this.focusChangedProgrammatically || (this.focusChangedProgrammatically && this.clearButtonClicked)) {
                        this.ngZone.run(() => {
                            this.inputFocus.emit();
                        });
                    }
                }
                this.ngZone.run(() => {
                    this.isFocused = true;
                });
            }
        };
        /**
         * @hidden
         */
        this.handleInputBlur = () => {
            this.changeDetector.markForCheck();
            if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    this.inputBlur.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleInput = (ev) => {
            let incomingValue = isSafari(navigator.userAgent) && isJapanese(ev.target.value) ? ev.data : ev.target.value;
            this.updateValue(incomingValue);
        };
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    get disabledClass() {
        return this.disabled;
    }
    ngOnInit() {
        this.control = this.injector.get(NgControl, null);
        this.checkClearButton();
        this.subscriptions = this.localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    ngAfterViewInit() {
        const hostElement = this.hostElement.nativeElement;
        let cursorInsideWrapper = false;
        let tabbing = false;
        this.ngZone.runOutsideAngular(() => {
            // focusIn and focusOut are relative to the host element
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {
                if (!this.isFocused) {
                    this.ngZone.run(() => {
                        this.onFocus.emit();
                        this.isFocused = true;
                    });
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {
                if (!this.isFocused) {
                    return;
                }
                if (tabbing) {
                    const closestTextbox = closest(args.relatedTarget, (element) => element === this.hostElement.nativeElement);
                    if (!closestTextbox) {
                        this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper && !this.clearButtonClicked) {
                        this.handleBlur();
                    }
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {
                cursorInsideWrapper = true;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {
                cursorInsideWrapper = false;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
        });
    }
    ngOnChanges(changes) {
        if (changes.disabled || changes.readonly || changes.value) {
            this.checkClearButton();
        }
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    /**
     * Focuses the TextBox.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="input.focus()">Focus the input</button>
     *  <kendo-textbox #input></kendo-textbox>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.input) {
            return;
        }
        this.focusChangedProgrammatically = true;
        this.isFocused = true;
        this.input.nativeElement.focus();
        this.focusChangedProgrammatically = false;
    }
    /**
     * Blurs the TextBox.
     */
    blur() {
        this.focusChangedProgrammatically = true;
        const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');
        if (isFocusedElement) {
            isFocusedElement.blur();
        }
        this.isFocused = false;
        this.focusChangedProgrammatically = false;
    }
    /**
     * @hidden
     */
    clearTitle() {
        return this.localizationService.get('clear');
    }
    /**
     * @hidden
     */
    checkClearButton() {
        this.showClearButton =
            !this.disabled &&
                !this.readonly &&
                this.clearButton &&
                !!this.value;
    }
    /**
     * @hidden
     */
    clearValue(ev) {
        if (ev) {
            ev.preventDefault();
        }
        this.clearButtonClicked = true;
        this.input.nativeElement.value = '';
        this.input.nativeElement.focus();
        this.updateValue('');
        this.checkClearButton();
        this.clearButtonClicked = false;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        this.checkClearButton();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.changeDetector.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    showErrorsInitial() {
        if (!this.control) {
            return false;
        }
        const { invalid, dirty, touched } = this.control;
        return invalid && (dirty || touched);
    }
    /**
     * @hidden
     */
    showSuccessInitial() {
        if (!this.control) {
            return false;
        }
        const { valid, dirty, touched } = this.control;
        return valid && (dirty || touched);
    }
    /**
     * @hidden
     */
    get successIconClasses() {
        return this.successIcon
            ? `k-text-success ${this.successIcon}`
            : `k-text-success k-icon k-i-check-outline`;
    }
    /**
     * @hidden
     */
    get errorIconClasses() {
        return this.errorIcon
            ? `k-text-error ${this.errorIcon}`
            : `k-text-error k-icon k-i-warning`;
    }
    /**
     * @hidden
     */
    get clearButtonClasses() {
        return this.clearButtonIcon
            ? this.clearButtonIcon
            : `k-icon k-i-close-circle`;
    }
    /**
     * @hidden
     */
    get hasErrors() {
        return this.showErrorIcon === 'initial'
            ? this.showErrorsInitial()
            : this.showErrorIcon;
    }
    /**
     * @hidden
     */
    get isSuccessful() {
        return this.showSuccessIcon === 'initial'
            ? this.showSuccessInitial()
            : this.showSuccessIcon;
    }
    setSelection(start, end) {
        if (this.isFocused) {
            invokeElementMethod(this.input, 'setSelectionRange', start, end);
        }
    }
    selectAll() {
        if (this.value) {
            this.setSelection(0, this.value.length);
        }
    }
    updateValue(value) {
        if (!areSame(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.checkClearButton();
                this.changeDetector.markForCheck();
            });
        }
    }
    get isFocused() {
        return this._isFocused;
    }
    set isFocused(value) {
        if (this._isFocused !== value && this.hostElement) {
            const element = this.hostElement.nativeElement;
            if (value && !this.disabled) {
                this.renderer.addClass(element, FOCUSED$3);
            }
            else {
                this.renderer.removeClass(element, FOCUSED$3);
            }
            this._isFocused = value;
        }
    }
    handleBlur() {
        this.ngZone.run(() => {
            if (!this.focusChangedProgrammatically) {
                this.onBlur.emit();
            }
            this.isFocused = false;
        });
    }
}
TextBoxComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: TextBoxComponent, selectors: [["kendo-textbox"]], factory: function TextBoxComponent_Factory(t) { return new (t || TextBoxComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(Injector), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, contentQueries: function TextBoxComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TextBoxSuffixTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, TextBoxPrefixTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.suffixTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.prefixTemplate = _t.first);
    } }, viewQuery: function TextBoxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c84, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.input = _t.first);
    } }, hostBindings: function TextBoxComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(3);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-textbox", ctx.hostClass);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabledClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { focusableId: "focusableId", title: "title", disabled: "disabled", readonly: "readonly", tabindex: "tabindex", value: "value", selectOnFocus: "selectOnFocus", showSuccessIcon: "showSuccessIcon", showErrorIcon: "showErrorIcon", clearButton: "clearButton", tabIndex: "tabIndex", successIcon: "successIcon", errorIcon: "errorIcon", clearButtonIcon: "clearButtonIcon", placeholder: "placeholder", maxlength: "maxlength" }, outputs: { valueChange: "valueChange", inputFocus: "inputFocus", inputBlur: "inputBlur", onFocus: "focus", onBlur: "blur" }, exportAs: ["kendoTextBox"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.textbox' },
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => TextBoxComponent_1),
                multi: true
            },
            { provide: KendoInput, useExisting: forwardRef(() => TextBoxComponent_1) }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], consts: 11, vars: 18, template: function TextBoxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, _c99);
        ɵngcc0.ɵɵi18nAttributes(1, _c102);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "span", _c103);
        ɵngcc0.ɵɵtemplate(3, TextBoxComponent_3_Template, 1, 1, undefined, _c104);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "input", _c105, _c86);
        ɵngcc0.ɵɵelementStart(6, "span", _c106);
        ɵngcc0.ɵɵtemplate(7, TextBoxComponent_span_7_Template, 1, 1, "span", _c107);
        ɵngcc0.ɵɵtemplate(8, TextBoxComponent_span_8_Template, 1, 1, "span", _c107);
        ɵngcc0.ɵɵtemplate(9, TextBoxComponent_span_9_Template, 2, 4, "span", _c108);
        ɵngcc0.ɵɵtemplate(10, TextBoxComponent_10_Template, 1, 1, undefined, _c104);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("disabled", ctx.disabled)("readonly", ctx.readonly)("value", ctx.value)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction3(14, _c112, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));
        ɵngcc0.ɵɵattribute("tabindex", ctx.disabled ? undefined : ctx.tabindex)("placeholder", ctx.placeholder)("title", ctx.title)("maxlength", ctx.maxlength);
        ɵngcc0.ɵɵselect(7);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasErrors);
        ɵngcc0.ɵɵselect(8);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isSuccessful);
        ɵngcc0.ɵɵselect(9);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showClearButton);
        ɵngcc0.ɵɵselect(10);
        ɵngcc0.ɵɵproperty("ngIf", ctx.suffixTemplate);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextBoxComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoTextBox',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.textbox' },
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => TextBoxComponent_1),
                        multi: true
                    },
                    { provide: KendoInput, useExisting: forwardRef(() => TextBoxComponent_1) }
                ],
                selector: 'kendo-textbox',
                template: `
        <ng-container kendoTextBoxLocalizedMessages
            i18n-clear="kendo.textbox.clear|The title for the **Clear** button in the TextBox."
            clear="Clear">
        </ng-container>
        <span class="k-input-prefix">
            <ng-template
                *ngIf="prefixTemplate"
                [ngTemplateOutlet]="prefixTemplate?.templateRef">
            </ng-template>
        </span>
        <input
            class="k-input"
            #input
            [id]="focusableId"
            [disabled]="disabled"
            [readonly]="readonly"
            [attr.tabindex]="disabled ? undefined : tabindex"
            [value]="value"
            [attr.placeholder]="placeholder"
            [attr.title]="title"
            [attr.maxlength]="maxlength"
            [kendoEventsOutsideAngular]="{
                focus: handleInputFocus,
                blur: handleInputBlur,
                input: handleInput}"/>
        <span class="k-input-suffix">
            <span *ngIf="hasErrors" [ngClass]="errorIconClasses"></span>
            <span *ngIf="isSuccessful" [ngClass]="successIconClasses"></span>
            <span
                role="button"
                class="k-clear-value"
                *ngIf="showClearButton"
                (click)="clearValue()"
                (mousedown)="$event.preventDefault()"
                [tabindex]="tabIndex"
                [attr.aria-label]="clearTitle()"
                [title]="clearTitle()"
                (keydown.enter)="clearValue($event)"
                (keydown.space)="clearValue($event)"
                >
                <span [ngClass]="clearButtonClasses"></span>
            </span>
            <ng-template
                *ngIf="suffixTemplate"
                [ngTemplateOutlet]="suffixTemplate?.templateRef">
            </ng-template>
        </span>
    `
            }]
    }], function () { return [{ type: LocalizationService }, { type: NgZone }, { type: ChangeDetectorRef }, { type: Renderer2 }, { type: Injector }, { type: ElementRef }]; }, { constructor: [], localizationService: [], ngZone: [], changeDetector: [], renderer: [], injector: [], hostElement: [], focusableId: [{
            type: Input
        }], title: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], value: [{
            type: Input
        }], selectOnFocus: [{
            type: Input
        }], showSuccessIcon: [{
            type: Input
        }], showErrorIcon: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], inputFocus: [{
            type: Output
        }], inputBlur: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-textbox']
        }], _isFocused: [], focusChangedProgrammatically: [], handleInputFocus: [], isFocused: [], isFocused: [], handleInputBlur: [], handleInput: [], ngChange: [], ngTouched: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], tabIndex: [{
            type: Input
        }], tabIndex: [], disabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], ngOnInit: [], control: [], subscriptions: [], ngAfterViewInit: [], ngOnChanges: [], ngOnDestroy: [], focus: [], blur: [], clearTitle: [], checkClearButton: [], showClearButton: [], clearValue: [], clearButtonClicked: [], writeValue: [], registerOnChange: [], registerOnTouched: [], setDisabledState: [], showErrorsInitial: [], showSuccessInitial: [], successIconClasses: [], errorIconClasses: [], clearButtonClasses: [], hasErrors: [], isSuccessful: [], setSelection: [], selectAll: [], updateValue: [], handleBlur: [], successIcon: [{
            type: Input
        }], errorIcon: [{
            type: Input
        }], clearButtonIcon: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], maxlength: [{
            type: Input
        }], input: [{
            type: ViewChild,
            args: ['input', { static: true }]
        }], suffixTemplate: [{
            type: ContentChild,
            args: [TextBoxSuffixTemplateDirective, { static: false }]
        }], prefixTemplate: [{
            type: ContentChild,
            args: [TextBoxPrefixTemplateDirective, { static: false }]
        }] });;
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextBoxComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextBoxComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TextBoxComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextBoxComponent.prototype, "selectOnFocus", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TextBoxComponent.prototype, "showSuccessIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TextBoxComponent.prototype, "showErrorIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextBoxComponent.prototype, "clearButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "successIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "errorIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "clearButtonIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], TextBoxComponent.prototype, "tabIndex", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TextBoxComponent.prototype, "maxlength", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextBoxComponent.prototype, "valueChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextBoxComponent.prototype, "inputFocus", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextBoxComponent.prototype, "inputBlur", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], TextBoxComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], TextBoxComponent.prototype, "onBlur", void 0);
__decorate([
    ViewChild('input', { static: true }),
    __metadata("design:type", ElementRef)
], TextBoxComponent.prototype, "input", void 0);
__decorate([
    ContentChild(TextBoxSuffixTemplateDirective, { static: false }),
    __metadata("design:type", TextBoxSuffixTemplateDirective)
], TextBoxComponent.prototype, "suffixTemplate", void 0);
__decorate([
    ContentChild(TextBoxPrefixTemplateDirective, { static: false }),
    __metadata("design:type", TextBoxPrefixTemplateDirective)
], TextBoxComponent.prototype, "prefixTemplate", void 0);
__decorate([
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TextBoxComponent.prototype, "disabledClass", null);
__decorate([
    HostBinding('class.k-textbox'),
    __metadata("design:type", Boolean)
], TextBoxComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], TextBoxComponent.prototype, "direction", void 0);
TextBoxComponent = TextBoxComponent_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService,
        NgZone,
        ChangeDetectorRef,
        Renderer2,
        Injector,
        ElementRef])
], TextBoxComponent);

/**
 * @hidden
 */
class TextBoxMessages extends ComponentMessages {
}
TextBoxMessages.ngBaseDef = ɵngcc0.ɵɵdefineBase({ inputs: { clear: "clear" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], TextBoxMessages.prototype, "clear", void 0);

var TextBoxCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages.
 */
let TextBoxCustomMessagesComponent = TextBoxCustomMessagesComponent_1 = class TextBoxCustomMessagesComponent extends TextBoxMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
TextBoxCustomMessagesComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: TextBoxCustomMessagesComponent, selectors: [["kendo-textbox-messages"]], factory: function TextBoxCustomMessagesComponent_Factory(t) { return new (t || TextBoxCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: TextBoxMessages,
                useExisting: forwardRef(() => TextBoxCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], consts: 0, vars: 0, template: function TextBoxCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextBoxCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: TextBoxMessages,
                        useExisting: forwardRef(() => TextBoxCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-textbox-messages',
                template: ``
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], service: [], override: [] });;
TextBoxCustomMessagesComponent = TextBoxCustomMessagesComponent_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], TextBoxCustomMessagesComponent);

var LocalizedTextBoxMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedTextBoxMessagesDirective = LocalizedTextBoxMessagesDirective_1 = class LocalizedTextBoxMessagesDirective extends TextBoxMessages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedTextBoxMessagesDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: LocalizedTextBoxMessagesDirective, selectors: [["", "kendoTextBoxLocalizedMessages", ""]], factory: function LocalizedTextBoxMessagesDirective_Factory(t) { return new (t || LocalizedTextBoxMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: TextBoxMessages,
                useExisting: forwardRef(() => LocalizedTextBoxMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(LocalizedTextBoxMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: TextBoxMessages,
                        useExisting: forwardRef(() => LocalizedTextBoxMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoTextBoxLocalizedMessages]'
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], service: [] });;
LocalizedTextBoxMessagesDirective = LocalizedTextBoxMessagesDirective_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], LocalizedTextBoxMessagesDirective);

/**
 * Specifies a separator in the content of components like the TextArea and the TextBox. ([see examples]({% slug adornments_textbox %}#toc-separator)).
 * @example
 * ```ts-no-run
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-textbox>
 *    <ng-template kendoTextBoxSuffixTemplate>
 *        <kendo-input-separator></kendo-input-separator>
 *        <button kendoButton look="clear" icon="image"></button>
 *    </ng-template>
 *  </kendo-textbox>
 * `
 * })
 * class AppComponent {}
 * ```
 */
let InputSeparatorComponent = class InputSeparatorComponent {
    /**
     * Specifies a separator in the content of components like the TextArea and the TextBox. ([see examples]({% slug adornments_textbox %}#toc-separator)).
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <kendo-textbox>
     *    <ng-template kendoTextBoxSuffixTemplate>
     *        <kendo-input-separator></kendo-input-separator>
     *        <button kendoButton look="clear" icon="image"></button>
     *    </ng-template>
     *  </kendo-textbox>
     * `
     * })
     * class AppComponent {}
     * ```
     */
    constructor() {
        this.hostClass = true;
    }
}
InputSeparatorComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: InputSeparatorComponent, selectors: [["kendo-input-separator"], ["kendo-textbox-separator"]], factory: function InputSeparatorComponent_Factory(t) { return new (t || InputSeparatorComponent)(); }, hostBindings: function InputSeparatorComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-input-separator", ctx.hostClass);
        ɵngcc0.ɵɵstylingApply();
    } }, consts: 0, vars: 0, template: function InputSeparatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(InputSeparatorComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-input-separator, kendo-textbox-separator',
                template: ``
            }]
    }], function () { return []; }, { constructor: [], hostClass: [{
            type: HostBinding,
            args: ['class.k-input-separator']
        }] });;
__decorate([
    HostBinding('class.k-input-separator'),
    __metadata("design:type", Boolean)
], InputSeparatorComponent.prototype, "hostClass", void 0);

/**
 * @hidden
 */
const SHARED_DIRECTIVES = [
    InputSeparatorComponent,
    TextAreaDirective
];
/**
 * @hidden
 */
let SharedModule = class SharedModule {
}
SharedModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: SharedModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(SharedModule, { declarations: [InputSeparatorComponent,
        TextAreaDirective], exports: [InputSeparatorComponent,
        TextAreaDirective] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(SharedModule, [{
        type: NgModule,
        args: [{
                declarations: [SHARED_DIRECTIVES],
                exports: [SHARED_DIRECTIVES]
            }]
    }], null, null);
SharedModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function SharedModule_Factory(t) { return new (t || SharedModule)(); } });;

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TextBox directive.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the TextBox module
 * import { TextBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, TextBoxModule], // import TextBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let TextBoxModule = class TextBoxModule {
}
TextBoxModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: TextBoxModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(TextBoxModule, { declarations: function () { return [TextBoxDirective,
        TextBoxContainerComponent,
        TextBoxComponent,
        TextBoxSuffixTemplateDirective,
        TextBoxPrefixTemplateDirective,
        TextBoxCustomMessagesComponent,
        LocalizedTextBoxMessagesDirective]; }, imports: function () { return [CommonModule, EventsModule,
        SharedModule]; }, exports: function () { return [TextBoxDirective,
        TextBoxContainerComponent,
        TextBoxComponent,
        TextBoxSuffixTemplateDirective,
        TextBoxPrefixTemplateDirective,
        EventsModule,
        TextBoxCustomMessagesComponent,
        LocalizedTextBoxMessagesDirective,
        InputSeparatorComponent,
        TextAreaDirective]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    TextBoxDirective,
                    TextBoxContainerComponent,
                    TextBoxComponent,
                    TextBoxSuffixTemplateDirective,
                    TextBoxPrefixTemplateDirective,
                    TextBoxCustomMessagesComponent,
                    LocalizedTextBoxMessagesDirective
                ],
                exports: [
                    TextBoxDirective,
                    TextBoxContainerComponent,
                    TextBoxComponent,
                    TextBoxSuffixTemplateDirective,
                    TextBoxPrefixTemplateDirective,
                    EventsModule,
                    TextBoxCustomMessagesComponent,
                    LocalizedTextBoxMessagesDirective,
                    SHARED_DIRECTIVES
                ],
                imports: [CommonModule, EventsModule, SharedModule]
            }]
    }], null, null);
TextBoxModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function TextBoxModule_Factory(t) { return new (t || TextBoxModule)(); }, imports: [[CommonModule, EventsModule, SharedModule]] });;

/**
 * @hidden
 */
class TextFieldsBase {
    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        this.injector = injector;
        this.hostElement = hostElement;
        /**
         * Sets the `title` attribute of the internal textarea input element of the component.
         */
        this.title = '';
        /**
         * Sets the disabled state of the TextArea component.
         *
         * @default false
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the TextArea component.
         *
         * @default false
         */
        this.readonly = false;
        /**
         * Provides a value for the TextArea component.
         */
        this.value = null;
        /**
         * Determines whether the whole value will be selected when the TextArea is clicked. Defaults to `false`.
         *
         * @default false
         */
        this.selectOnFocus = false;
        /**
         * Fires each time the user focuses the internal textarea element of the component.
         * This event is useful when you need to distinguish between focusing the textarea element and focusing one of its adornments.
         */
        this.inputFocus = new EventEmitter();
        /**
         * Fires each time the internal textarea element gets blurred.
         * This event is useful when adornments are used, in order to distinguish between blurring the textarea element and blurring the whole TextArea component.
         */
        this.inputBlur = new EventEmitter();
        this.subscriptions = new Subscription();
        this._isFocused = false;
        this.focusChangedProgrammatically = false;
        /**
         * @hidden
         */
        this.handleInputBlur = () => {
            this.changeDetector.markForCheck();
            if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    this.inputBlur.emit();
                });
            }
        };
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
    }
    get disabledClass() {
        return this.disabled;
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.changeDetector.markForCheck();
        this.disabled = isDisabled;
    }
}
TextFieldsBase.ngBaseDef = ɵngcc0.ɵɵdefineBase({ inputs: { title: "title", disabled: "disabled", readonly: "readonly", value: "value", selectOnFocus: "selectOnFocus", placeholder: "placeholder" }, outputs: { inputFocus: "inputFocus", inputBlur: "inputBlur" }, viewQuery: function (rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c84, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.input = _t.first);
    } }, hostBindings: function (rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(2);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabledClass);
        ɵngcc0.ɵɵstylingApply();
    } } });
__decorate([
    Input(),
    __metadata("design:type", String)
], TextFieldsBase.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextFieldsBase.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextFieldsBase.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextFieldsBase.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TextFieldsBase.prototype, "selectOnFocus", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextFieldsBase.prototype, "placeholder", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextFieldsBase.prototype, "inputFocus", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextFieldsBase.prototype, "inputBlur", void 0);
__decorate([
    ViewChild('input', { static: true }),
    __metadata("design:type", ElementRef)
], TextFieldsBase.prototype, "input", void 0);
__decorate([
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TextFieldsBase.prototype, "disabledClass", null);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], TextFieldsBase.prototype, "direction", void 0);

var TextAreaComponent_1;
const resizeClasses = {
    'vertical': 'k-resize-vertical',
    'horizontal': 'k-resize-horizontal',
    'both': 'k-resize-both',
    'none': 'k-resize-none',
    'auto': 'k-resize-none'
};
const FOCUSED$4 = 'k-state-focus';
/**
 * Represents the [Kendo UI TextArea component for Angular]({% slug overview_textarea %}).
 */
let TextAreaComponent = TextAreaComponent_1 = class TextAreaComponent extends TextFieldsBase {
    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
        super(localizationService, ngZone, changeDetector, renderer, injector, hostElement);
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        this.injector = injector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        this.hostClass = true;
        /**
         * Specifies the flow direction of the TextArea sections. This property is useful when adornments are used, in order to specify
         * their position in relation to the textarea element.
         *
         * The possible values are:
         * * `vertical`(Default) &mdash;TextArea sections are placed from top to bottom.
         * * `horizontal`&mdash;TextArea sections are placed from left to right in `ltr`, and from right to left in `rtl` mode.
         */
        this.flow = 'vertical';
        /**
         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Configures the resize behavior of the TextArea.
         *
         * The possible values are:
         * * `vertical`(Default)&mdash;The TextArea component can be resized only vertically.
         * * `horizontal`&mdash;The TextArea component can be resized only horizontally.
         * * `both`&mdash;The TextArea component can be resized in both (horizontal and vertical) directions.
         * * `auto`&mdash;Specifies whether the TextArea component will adjust its height automatically, based on the content.
         * * `none`&mdash;The TextArea cannot be resized.
         *
         */
        this.resizable = 'vertical';
        /**
         * Fires each time the user focuses the TextArea component.
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textarea (focus)="handleFocus()"></kendo-textarea>
         * `
         * })
         * class AppComponent {
         *   public handleFocus(): void {
         *      console.log('Component is focused');
         *   }
         * }
         * ```
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the TextArea component gets blurred.
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textarea (blur)="handleBlur()"></kendo-textarea>
         * `
         * })
         * class AppComponent {
         *   public handleBlur(): void {
         *      console.log('Component is blurred');
         *   }
         * }
         * ```
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires each time the value is changed or the component is blurred
         * ([see example]({% slug overview_textarea %}#toc-events)).
         * When the component value is changed programmatically or via its form control binding, the valueChange event is not emitted.
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.handleInput = (ev) => {
            let incomingValue = ev.target.value;
            this.updateValue(incomingValue);
            this.resize();
        };
        /**
         * @hidden
         */
        this.handleInputFocus = () => {
            if (!this.disabled) {
                if (this.selectOnFocus && this.value) {
                    this.ngZone.run(() => {
                        setTimeout(() => { this.selectAll(); });
                    });
                }
                if (hasObservers(this.onFocus)) {
                    if (!this.isFocused) {
                        this.ngZone.run(() => {
                            this.onFocus.emit();
                        });
                    }
                }
                if (hasObservers(this.inputFocus)) {
                    if (!this.focusChangedProgrammatically) {
                        this.ngZone.run(() => {
                            this.inputFocus.emit();
                        });
                    }
                }
                this.ngZone.run(() => {
                    this.isFocused = true;
                });
            }
        };
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    get flowCol() {
        return this.flow === 'vertical';
    }
    get flowRow() {
        return this.flow === 'horizontal';
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    ngAfterViewInit() {
        const hostElement = this.hostElement.nativeElement;
        let cursorInsideWrapper = false;
        let tabbing = false;
        this.ngZone.runOutsideAngular(() => {
            // focusIn and focusOut are relative to the host element
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {
                if (!this.isFocused) {
                    this.ngZone.run(() => {
                        this.onFocus.emit();
                        this.isFocused = true;
                    });
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {
                if (!this.isFocused) {
                    return;
                }
                if (tabbing) {
                    const closestTextbox = closest(args.relatedTarget, (element) => element === this.hostElement.nativeElement);
                    if (!closestTextbox) {
                        this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper) {
                        this.handleBlur();
                    }
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {
                cursorInsideWrapper = true;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {
                cursorInsideWrapper = false;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
        });
    }
    ngOnInit() {
        this.control = this.injector.get(NgControl, null);
        if (isDocumentAvailable() && this.resizable === 'auto') {
            this.resizeSubscription = fromEvent(window, 'resize')
                .pipe((debounceTime(50)))
                .subscribe(() => this.resize());
        }
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.subscriptions = this.localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    ngOnChanges(changes) {
        const hostElement = this.hostElement.nativeElement;
        const element = this.input.nativeElement;
        if (changes.resizable) {
            if (this.resizable === 'auto') {
                this.initialHeight = element.offsetHeight;
            }
            else {
                this.renderer.setStyle(element, 'overflow-y', 'auto');
                this.renderer.setStyle(element, 'resize', 'both');
                element.style.height = `${this.initialHeight}px`;
            }
        }
        if (changes.cols) {
            if (isPresent(changes.cols.currentValue)) {
                this.renderer.setStyle(hostElement, 'width', 'auto');
            }
            else {
                this.renderer.removeStyle(hostElement, 'width');
            }
        }
    }
    ngAfterViewChecked() {
        this.resize();
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    updateValue(value) {
        if (!areSame(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.changeDetector.markForCheck();
            });
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get resizableClass() {
        return resizeClasses[this.resizable];
    }
    /**
     * Focuses the TextArea component.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="textarea.focus()">Focus the textarea</button>
     *  <kendo-textarea #textarea></kendo-textarea>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.input) {
            return;
        }
        this.focusChangedProgrammatically = true;
        this.isFocused = true;
        this.input.nativeElement.focus();
        this.focusChangedProgrammatically = false;
    }
    /**
     * Blurs the TextArea component.
     */
    blur() {
        this.focusChangedProgrammatically = true;
        const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');
        if (isFocusedElement) {
            isFocusedElement.blur();
        }
        this.isFocused = false;
        this.focusChangedProgrammatically = false;
    }
    resize() {
        if (this.resizable !== 'auto') {
            return;
        }
        const element = this.input.nativeElement;
        this.renderer.setStyle(element, 'overflow-y', 'hidden');
        this.renderer.setStyle(element, 'height', `${this.initialHeight}px`);
        const scrollHeight = element.scrollHeight;
        if (scrollHeight > this.initialHeight) {
            element.style.height = `${scrollHeight}px`;
        }
    }
    get isFocused() {
        return this._isFocused;
    }
    set isFocused(value) {
        if (this._isFocused !== value && this.hostElement) {
            const element = this.hostElement.nativeElement;
            if (value && !this.disabled) {
                this.renderer.addClass(element, FOCUSED$4);
            }
            else {
                this.renderer.removeClass(element, FOCUSED$4);
            }
            this._isFocused = value;
        }
    }
    handleBlur() {
        this.ngZone.run(() => {
            if (!this.focusChangedProgrammatically) {
                this.onBlur.emit();
            }
            this.isFocused = false;
        });
    }
    setSelection(start, end) {
        if (this.isFocused) {
            invokeElementMethod(this.input, 'setSelectionRange', start, end);
        }
    }
    selectAll() {
        if (this.value) {
            this.setSelection(0, this.value.length);
        }
    }
}
TextAreaComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: TextAreaComponent, selectors: [["kendo-textarea"]], factory: function TextAreaComponent_Factory(t) { return new (t || TextAreaComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(Injector), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, hostBindings: function TextAreaComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(3);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-textarea", ctx.hostClass);
        ɵngcc0.ɵɵclassProp("k-flex-col", ctx.flowCol);
        ɵngcc0.ɵɵclassProp("k-flex-row", ctx.flowRow);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { focusableId: "focusableId", flow: "flow", tabindex: "tabindex", resizable: "resizable", tabIndex: "tabIndex", rows: "rows", cols: "cols", maxlength: "maxlength" }, outputs: { onFocus: "focus", onBlur: "blur", valueChange: "valueChange" }, exportAs: ["kendoTextArea"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.textarea' },
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => TextAreaComponent_1),
                multi: true
            },
            { provide: KendoInput, useExisting: forwardRef(() => TextAreaComponent_1) }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature()], ngContentSelectors: _c115, consts: 4, vars: 19, template: function TextAreaComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c114);
        ɵngcc0.ɵɵelementStart(0, "textarea", _c113, _c86);
        ɵngcc0.ɵɵtext(2, "            ");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.resizableClass)("id", ctx.focusableId)("value", ctx.value)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction3(15, _c112, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));
        ɵngcc0.ɵɵattribute("aria-multiline", true)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("placeholder", ctx.placeholder)("rows", ctx.rows)("cols", ctx.cols)("tabindex", ctx.tabIndex)("title", ctx.title)("maxlength", ctx.maxlength);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextAreaComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoTextArea',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.textarea' },
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => TextAreaComponent_1),
                        multi: true
                    },
                    { provide: KendoInput, useExisting: forwardRef(() => TextAreaComponent_1) }
                ],
                selector: 'kendo-textarea',
                template: `
        <textarea
            #input
            [attr.aria-multiline]="true"
            [attr.aria-disabled]="disabled ? true : undefined"
            [attr.aria-readonly]="readonly ? true : undefined"
            class="k-input"
            [ngClass]="resizableClass"
            [id]="focusableId"
            [value]="value"
            [attr.placeholder]="placeholder"
            [disabled]="disabled"
            [readonly]="readonly"
            [attr.rows]="rows"
            [attr.cols]="cols"
            [attr.tabindex]="tabIndex"
            [attr.title]="title"
            [attr.maxlength]="maxlength"
            [kendoEventsOutsideAngular]="{
                focus: handleInputFocus,
                blur: handleInputBlur,
                input: handleInput}">
            </textarea>
            <ng-content select="kendo-textarea-suffix"></ng-content>
    `
            }]
    }], function () { return [{ type: LocalizationService }, { type: NgZone }, { type: ChangeDetectorRef }, { type: Renderer2 }, { type: Injector }, { type: ElementRef }]; }, { constructor: [], localizationService: [], ngZone: [], changeDetector: [], renderer: [], injector: [], hostElement: [], focusableId: [{
            type: Input
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-textarea']
        }], flow: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], resizable: [{
            type: Input
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], valueChange: [{
            type: Output
        }], handleInput: [], handleInputFocus: [], isFocused: [], isFocused: [], direction: [], flowCol: [{
            type: HostBinding,
            args: ['class.k-flex-col']
        }], flowRow: [{
            type: HostBinding,
            args: ['class.k-flex-row']
        }], tabIndex: [{
            type: Input
        }], tabIndex: [], ngAfterViewInit: [], ngOnInit: [], control: [], resizeSubscription: [], subscriptions: [], ngOnChanges: [], initialHeight: [], ngAfterViewChecked: [], writeValue: [], value: [], registerOnChange: [], ngChange: [], registerOnTouched: [], ngTouched: [], updateValue: [], ngOnDestroy: [], resizableClass: [], focus: [], focusChangedProgrammatically: [], blur: [], resize: [], _isFocused: [], handleBlur: [], setSelection: [], selectAll: [], rows: [{
            type: Input
        }], cols: [{
            type: Input
        }], maxlength: [{
            type: Input
        }] });;
__decorate([
    Input(),
    __metadata("design:type", String)
], TextAreaComponent.prototype, "focusableId", void 0);
__decorate([
    HostBinding('class.k-textarea'),
    __metadata("design:type", Boolean)
], TextAreaComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('class.k-flex-col'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TextAreaComponent.prototype, "flowCol", null);
__decorate([
    HostBinding('class.k-flex-row'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], TextAreaComponent.prototype, "flowRow", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextAreaComponent.prototype, "flow", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TextAreaComponent.prototype, "rows", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TextAreaComponent.prototype, "cols", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TextAreaComponent.prototype, "maxlength", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TextAreaComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], TextAreaComponent.prototype, "tabIndex", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], TextAreaComponent.prototype, "resizable", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], TextAreaComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], TextAreaComponent.prototype, "onBlur", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TextAreaComponent.prototype, "valueChange", void 0);
TextAreaComponent = TextAreaComponent_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService,
        NgZone,
        ChangeDetectorRef,
        Renderer2,
        Injector,
        ElementRef])
], TextAreaComponent);

/**
 * Specifies the adornments in the suffix container ([see example]({% slug textarea_adornments %}).
 *  @example
 * ```ts-no-run
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-textarea>
 *    <kendo-textarea-suffix>
 *        <button kendoButton look="clear" icon="image"></button>
 *    </kendo-textarea-suffix>
 *  </kendo-textarea>
 * `
 * })
 * class AppComponent {}
 * ```
 */
let TextAreaSuffixComponent = class TextAreaSuffixComponent {
    /**
     * Specifies the adornments in the suffix container ([see example]({% slug textarea_adornments %}).
     *  @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <kendo-textarea>
     *    <kendo-textarea-suffix>
     *        <button kendoButton look="clear" icon="image"></button>
     *    </kendo-textarea-suffix>
     *  </kendo-textarea>
     * `
     * })
     * class AppComponent {}
     * ```
     */
    constructor() {
        this.hostClass = true;
    }
}
TextAreaSuffixComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: TextAreaSuffixComponent, selectors: [["kendo-textarea-suffix"]], factory: function TextAreaSuffixComponent_Factory(t) { return new (t || TextAreaSuffixComponent)(); }, hostBindings: function TextAreaSuffixComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-textarea-suffix", ctx.hostClass);
        ɵngcc0.ɵɵstylingApply();
    } }, exportAs: ["kendoTextAreaSuffix"], ngContentSelectors: _c61, consts: 1, vars: 0, template: function TextAreaSuffixComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextAreaSuffixComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoTextAreaSuffix',
                selector: 'kendo-textarea-suffix',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return []; }, { constructor: [], hostClass: [{
            type: HostBinding,
            args: ['class.k-textarea-suffix']
        }] });;
__decorate([
    HostBinding('class.k-textarea-suffix'),
    __metadata("design:type", Boolean)
], TextAreaSuffixComponent.prototype, "hostClass", void 0);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TextArea component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the TextArea module
 * import { TextAreaModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, TextAreaModule], // import TextArea module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let TextAreaModule = class TextAreaModule {
}
TextAreaModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: TextAreaModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(TextAreaModule, { declarations: function () { return [TextAreaComponent,
        TextAreaSuffixComponent]; }, imports: function () { return [CommonModule, EventsModule,
        SharedModule]; }, exports: function () { return [TextAreaComponent,
        EventsModule,
        TextAreaSuffixComponent,
        InputSeparatorComponent,
        TextAreaDirective]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TextAreaModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    TextAreaComponent,
                    TextAreaSuffixComponent
                ],
                exports: [
                    TextAreaComponent,
                    EventsModule,
                    TextAreaSuffixComponent,
                    SHARED_DIRECTIVES
                ],
                imports: [CommonModule, EventsModule, SharedModule]
            }]
    }], null, null);
TextAreaModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function TextAreaModule_Factory(t) { return new (t || TextAreaModule)(); }, imports: [[CommonModule, EventsModule, SharedModule]] });;

/**
 * @hidden
 */
class PreventableEvent {
    constructor() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns - `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Fires each time the left side of the ColorPicker wrapper is clicked.
 * The event is triggered regardless of whether a ColorPicker icon is set or not.
 *
 * Provides information about the current active color and gives the option to prevent the opening of the popup.
 *
 * @example
 *
 * ```ts-no-run
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *       <kendo-colorpicker
 *           [icon]="'edit-tools'"
 *           [value]="'#900'"
 *           (activeColorClick)="handleActiveColorClick($event)"
 *       >
 *       </kendo-colorpicker>
 *   `
 * })
 * class AppComponent {
 *     public handleActiveColorClick(event: ActiveColorClickEvent): void {
 *         event.preventOpen();
 *
 *         console.log('Open prevented:', event.isOpenPrevented());
 *         console.log('Current color:', event.color);
 *     }
 *  }
 * ```
 */
class ActiveColorClickEvent {
    /**
     * @hidden
     * @param color Represents the current value of the ColorPicker.
     */
    constructor(color) {
        this.color = color;
        this.openPrevented = false;
    }
    /**
     * Prevents the opening of the popup.
     */
    preventOpen() {
        this.openPrevented = true;
    }
    /**
     * Returns `true` if the popup opening is prevented by any of its subscribers.
     *
     * @returns - Returns `true` if the open action was prevented. Otherwise, returns `false`.
     */
    isOpenPrevented() {
        return this.openPrevented;
    }
}

/**
 * @hidden
 *
 * Returns the hex or rgba string representation of the color.
 */
const parseColor$1 = (value, format, safe = true) => {
    const allowedFormats = ['hex', 'rgba', 'name'];
    if (allowedFormats.indexOf(format) === -1) {
        throw new Error(`Unsupported color output format '${format}'. The available options are 'hex', 'rgba' or 'name'.`);
    }
    if (!isPresent(value)) {
        return;
    }
    if (format === 'name') {
        return nameFormat(value, safe);
    }
    const parsedColor = parseColor(value.trim(), safe);
    if (!isPresent(parsedColor)) {
        return;
    }
    return format === 'hex' ? parsedColor.toCss() : parsedColor.toCssRgba();
};
/**
 * @hidden
 *
 * Returns an HSV object representation of the color string.
 */
const getHSV = (value, safe = true) => {
    const parsed = parseColor(value, safe);
    if (!isPresent(parsed)) {
        return {};
    }
    return parsed.toHSV();
};
/**
 * @hidden
 *
 * Returns an RGBA object representation of the color string.
 */
const getRGBA = (value, safe = true) => {
    const parsed = parseColor(value, safe);
    if (!isPresent(parsed)) {
        return {};
    }
    return parsed.toBytes();
};
/**
 * @hidden
 *
 * Returns the RGBA string representation of the color.
 */
const getColorFromHSV = (hsva) => {
    const hue = fitIntoBounds(hsva.h, 0, 359.9);
    const saturation = fitIntoBounds(hsva.s, 0, 1);
    const value = fitIntoBounds(hsva.v, 0, 1);
    const alpha = fitIntoBounds(hsva.a, 0, 1);
    return Color.fromHSV(hue, saturation, value, alpha).toCssRgba();
};
/**
 * @hidden
 *
 * Returns the RGBA string representation of the color based on the `hue`, assuming the `value`, `saturation` and `alpha` have value of `1`.
 */
const getColorFromHue = (hue) => {
    return getColorFromHSV({ h: hue, s: 1, v: 1, a: 1 });
};
/**
 * @hidden
 *
 * Returns the RGBA string representation of the color.
 */
const getColorFromRGBA = (rgba) => {
    const red = fitIntoBounds(rgba.r, 0, 255);
    const green = fitIntoBounds(rgba.g, 0, 255);
    const blue = fitIntoBounds(rgba.b, 0, 255);
    const alpha = fitIntoBounds(rgba.a, 0, 1);
    return Color.fromBytes(red, green, blue, alpha).toCssRgba();
};
/**
 *
 * @hidden
 */
function nameFormat(value, safe) {
    value = value.toLowerCase().trim();
    if (isPresent(namedColors[value])) {
        return value;
    }
    if (parseColor(value, safe)) {
        value = parseColor(value, safe).toHex();
    }
    const key = Object.keys(namedColors).find(key => namedColors[key] === value);
    if (!key && !safe) {
        throw new Error(`The provided color ${value} is not supported for 'format="name"' property.To display ${value} color, the component 'format' property shoud be set to 'hex' or 'rgba' `);
    }
    return key;
}
/**
 * @hidden
 *
 * Returns the RGB object representation of the color based on the background color.
 */
const getRGBFromRGBA = (foregroundColor, backgroundColor) => {
    const r1 = fitIntoBounds(foregroundColor.r, 0, 255);
    const g1 = fitIntoBounds(foregroundColor.g, 0, 255);
    const b1 = fitIntoBounds(foregroundColor.b, 0, 255);
    const a1 = fitIntoBounds(foregroundColor.a, 0, 1);
    const r2 = fitIntoBounds(backgroundColor.r, 0, 255);
    const g2 = fitIntoBounds(backgroundColor.g, 0, 255);
    const b2 = fitIntoBounds(backgroundColor.b, 0, 255);
    return {
        r: Math.round(((1 - a1) * r2) + (a1 * r1)),
        g: Math.round(((1 - a1) * g2) + (a1 * g1)),
        b: Math.round(((1 - a1) * b2) + (a1 * b1))
    };
};
/**
 * @hidden
 *
 * Returns the relative luminance.
 */
const getLuminance = (rgb) => {
    let a = [rgb.r, rgb.g, rgb.b].map(function (v) {
        v /= 255;
        return v <= 0.03928
            ? v / 12.92
            : Math.pow((v + 0.055) / 1.055, 2.4);
    });
    return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;
};
/**
 * @hidden
 *
 * Returns the color contrast.
 */
const getContrast = (luminance1, luminance2) => {
    const brightest = Math.max(luminance1, luminance2);
    const darkest = Math.min(luminance1, luminance2);
    return (brightest + 0.05)
        / (darkest + 0.05);
};
/**
 * @hidden
 *
 * Returns the color contrast from two RGBA colors.
 */
const getContrastFromTwoRGBAs = (a, b) => {
    return getContrast(getLuminance(getRGBFromRGBA(a, b)), getLuminance(getRGBFromRGBA(b, { r: 0, g: 0, b: 0, a: 1 })));
};

// tslint:disable:max-line-length
/**
 * @hidden
 */
const PALETTEPRESETS = {
    basic: {
        colors: '000000,7f7f7f,880015,ed1c24,ff7f27,fff200,22b14c,00a2e8,3f48cc,a349a4,ffffff,c3c3c3,b97a57,ffaec9,ffc90e,efe4b0,b5e61d,99d9ea,7092be,c8bfe7',
        columns: 10
    },
    office: {
        colors: 'ffffff, 000000, e6e6e6, 435569, 4371c4, ed7e32, a5a4a5, febf04, 5a9bd5, 71ae48, f2f2f3, 7f7f7f, d1cece, d5dde3, dae1f4, fce5d4, deeded, fff2cc, deeaf6, e1efd9, d7d8d8, 585959, aeabab, adbaca, b4c5e7, f6caac, dbdbdb, ffe498, bcd6ee, c5e0b2, bfbfc0, 3f3f3f, 767070, 8595b1, 8fabdb, f5b183, c9c8c9, fed965, 9bc4e5, a8d08d, a5a5a6, 262625, 393939, 334050, 2e5496, c45a11, 7b7b7a, bf9000, 2f75b5, 548235, 7f7f7f, 0b0c0c, 161616, 222a34, 203764, 843d0b, 525252, 7f6000, 1d4d79, 375623',
        columns: 10
    },
    apex: {
        colors: 'ffffff, 000000, c9c2d1, 69676d, ceb966, 9cb084, 6bb1c9, 6585cf, 7e6bc9, a379bb, f2f2f2, 7f7f7f, f4f2f5, e0e0e2, f5f1e0, ebefe6, e1eff4, e0e6f5, e5e1f4, ece4f1, d8d8d8, 595959, e9e6ec, c2c1c5, ebe3c1, d7dfcd, c3dfe9, c1ceeb, cbc3e9, dac9e3, bfbfbf, 3f3f3f, dedae3, a4a3a8, e1d5a3, c3cfb5, a6d0de, a2b5e2, b1a6de, c7aed6, a5a5a5, 262626, 9688a5, 4e4d51, ae9638, 758c5a, 3d8da9, 365bb0, 533da9, 7d4d99, 7f7f7f, 0c0c0c, 635672, 343336, 746425, 4e5d3c, 295e70, 243c75, 372970, 533366',
        columns: 10
    },
    austin: {
        colors: 'ffffff, 000000, caf278, 3e3d2d, 94c600, 71685a, ff6700, 909465, 956b43, fea022, f2f2f2, 7f7f7f, f4fce4, dddcd0, efffc0, e3e1dc, ffe0cb, e8e9df, ece1d6, feecd2, d8d8d8, 595959, e9f9c9, bbb9a1, dfff82, c8c3ba, ffc299, d2d4c0, dac3ad, fed9a6, bfbfbf, 3f3f3f, dff7ae, ada598, cfff43, ada598, ffa365, bcbfa1, c8a585, fec67a, a5a5a5, 262626, a9ea25, 2e2d21, 6f9400, 544e43, bf4d00, 6c6f4b, 6f5032, d77b00, 7f7f7f, 0c0c0c, 74a50f, 1f1e16, 4a6300, 38342d, 7f3300, 484a32, 4a3521, 8f5200',
        columns: 10
    },
    clarity: {
        colors: 'ffffff, 292934, f3f2dc, d2533c, 93a299, ad8f67, 726056, 4c5a6a, 808da0, 79463d, f2f2f2, e7e7ec, e7e5b9, f6dcd8, e9ecea, eee8e0, e4dedb, d8dde3, e5e8ec, e9d6d3, d8d8d8, c4c4d1, d5d185, edbab1, d3d9d6, ded2c2, c9beb8, b2bcc8, ccd1d9, d3aea7, bfbfbf, 8a8aa3, aca73b, e4978a, bec7c1, cdbba3, af9e94, 8c9bac, b2bac6, bd857c, a5a5a5, 56566e, 56531d, a43925, 6b7c72, 866b48, 554840, 39434f, 5c697b, 5a342d, 7f7f7f, 3b3b4b, 22210b, 6d2619, 47534c, 594730, 39302b, 262d35, 3d4652, 3c231e',
        columns: 10
    },
    slipstream: {
        colors: 'ffffff, 000000, b4dcfa, 212745, 4e67c8, 5eccf3, a7ea52, 5dceaf, ff8021, f14124, f2f2f2, 7f7f7f, 8bc9f7, c7cce4, dbe0f4, def4fc, edfadc, def5ef, ffe5d2, fcd9d3, d8d8d8, 595959, 4facf3, 909aca, b8c2e9, beeafa, dbf6b9, beebdf, ffcca6, f9b3a7, bfbfbf, 3f3f3f, 0d78c9, 5967af, 94a3de, 9ee0f7, caf297, 9de1cf, ffb279, f68d7b, a5a5a5, 262626, 063c64, 181d33, 31479f, 11b2eb, 81d319, 34ac8b, d85c00, c3260c, 7f7f7f, 0c0c0c, 021828, 101322, 202f6a, 0b769c, 568c11, 22725c, 903d00, 821908',
        columns: 10
    },
    metro: {
        colors: 'ffffff, 000000, d6ecff, 4e5b6f, 7fd13b, ea157a, feb80a, 00addc, 738ac8, 1ab39f, f2f2f2, 7f7f7f, a7d6ff, d9dde4, e5f5d7, fad0e4, fef0cd, c5f2ff, e2e7f4, c9f7f1, d8d8d8, 595959, 60b5ff, b3bcca, cbecb0, f6a1c9, fee29c, 8be6ff, c7d0e9, 94efe3, bfbfbf, 3f3f3f, 007dea, 8d9baf, b2e389, f272af, fed46b, 51d9ff, aab8de, 5fe7d5, a5a5a5, 262626, 003e75, 3a4453, 5ea226, af0f5b, c58c00, 0081a5, 425ea9, 138677, 7f7f7f, 0c0c0c, 00192e, 272d37, 3f6c19, 750a3d, 835d00, 00566e, 2c3f71, 0c594f',
        columns: 10
    },
    flow: {
        colors: 'ffffff, 000000, dbf5f9, 04617b, 0f6fc6, 009dd9, 0bd0d9, 10cf9b, 7cca62, a5c249, f2f2f2, 7f7f7f, b2e9f2, b4ecfc, c7e2fa, c4eeff, c9fafc, c9faed, e4f4df, edf2da, d8d8d8, 595959, 76d9e8, 6adafa, 90c6f6, 89deff, 93f5f9, 94f6db, cae9c0, dbe6b6, bfbfbf, 3f3f3f, 21b2c8, 20c8f7, 59a9f2, 4fceff, 5df0f6, 5ff2ca, b0dfa0, c9da91, a5a5a5, 262626, 105964, 02485c, 0b5394, 0075a2, 089ca2, 0b9b74, 54a838, 7e9532, 7f7f7f, 0c0c0c, 062328, 01303d, 073763, 004e6c, 05686c, 07674d, 387025, 546321',
        columns: 10
    },
    hardcover: {
        colors: 'ffffff, 000000, ece9c6, 895d1d, 873624, d6862d, d0be40, 877f6c, 972109, aeb795, f2f2f2, 7f7f7f, e1dca5, f2e0c6, f0d0c9, f6e6d5, f5f2d8, e7e5e1, fbc7bc, eef0e9, d8d8d8, 595959, d0c974, e6c28d, e2a293, eeceaa, ece5b2, cfccc3, f78f7a, dee2d4, bfbfbf, 3f3f3f, a29a36, daa454, d4735e, e6b681, e2d88c, b7b2a5, f35838, ced3bf, a5a5a5, 262626, 514d1b, 664515, 65281a, a2641f, a39428, 655f50, 711806, 879464, 7f7f7f, 0c0c0c, 201e0a, 442e0e, 431b11, 6c4315, 6d621a, 433f35, 4b1004, 5a6243',
        columns: 10
    },
    trek: {
        colors: 'ffffff, 000000, fbeec9, 4e3b30, f0a22e, a5644e, b58b80, c3986d, a19574, c17529, f2f2f2, 7f7f7f, f7e09e, e1d6cf, fcecd5, eddfda, f0e7e5, f3eae1, ece9e3, f5e3d1, d8d8d8, 595959, f3cc5f, c4ad9f, f9d9ab, dcc0b6, e1d0cc, e7d5c4, d9d4c7, ebc7a3, bfbfbf, 3f3f3f, d29f0f, a78470, f6c781, cba092, d2b9b2, dbc1a7, c6bfab, e1ac76, a5a5a5, 262626, 694f07, 3a2c24, c87d0e, 7b4b3a, 926255, a17242, 7b7153, 90571e, 7f7f7f, 0c0c0c, 2a1f03, 271d18, 855309, 523226, 614138, 6b4c2c, 524b37, 603a14',
        columns: 10
    },
    verve: {
        colors: 'ffffff, 000000, d2d2d2, 666666, ff388c, e40059, 9c007f, 68007f, 005bd3, 00349e, f2f2f2, 7f7f7f, bdbdbd, e0e0e0, ffd7e8, ffc6dc, ffb8f1, f1b2ff, c3dcff, b8cfff, d8d8d8, 595959, 9d9d9d, c1c1c1, ffafd1, ff8eba, ff71e4, e365ff, 87baff, 72a0ff, bfbfbf, 3f3f3f, 696969, a3a3a3, ff87ba, ff5597, ff2ad7, d519ff, 4b98ff, 2b71ff, a5a5a5, 262626, 343434, 4c4c4c, e90062, ab0042, 75005f, 4e005f, 00449e, 002676, 7f7f7f, 0c0c0c, 151515, 333333, 9b0041, 72002c, 4e003f, 34003f, 002d69, 00194f',
        columns: 10
    },
    monochrome: {
        colors: '000000, 1a1a1a, 333333, 4d4d4d, 666666, 808080, 999999, b3b3b3, cccccc, e6e6e6, f2f2f2, ffffff',
        columns: 12
    },
    accessible: {
        colors: 'black, grey, darkred, red, darkorange, gold, green, blue, darkblue, purple, white, darkgrey, saddlebrown, pink, orange, yellow, lightgreen, lightskyblue, lightblue, mediumpurple',
        columns: 10
    }
};

/**
 * @hidden
 */
let ColorPickerLocalizationService = class ColorPickerLocalizationService extends LocalizationService {
    constructor(prefix, messageService, _rtl) {
        super(prefix, messageService, _rtl);
    }
};
ColorPickerLocalizationService = __decorate([
    __param(0, Inject(L10N_PREFIX)),
    __param(1, Optional()),
    __param(2, Optional()), __param(2, Inject(RTL)),
    __metadata("design:paramtypes", [String, MessageService, Boolean])
], ColorPickerLocalizationService);

/**
 * @hidden
 */
let ColorGradientLocalizationService = class ColorGradientLocalizationService extends LocalizationService {
    constructor(prefix, messageService, _rtl, colorPickerLocalization) {
        super(prefix, messageService, _rtl);
        this.colorPickerLocalization = colorPickerLocalization;
    }
    get(shortKey) {
        if (this.colorPickerLocalization) {
            return this.colorPickerLocalization.get(shortKey);
        }
        return super.get(shortKey);
    }
};
ColorGradientLocalizationService = __decorate([
    __param(0, Inject(L10N_PREFIX)),
    __param(1, Optional()),
    __param(2, Optional()), __param(2, Inject(RTL)),
    __param(3, Optional()), __param(3, Inject(ColorPickerLocalizationService)),
    __metadata("design:paramtypes", [String, MessageService, Boolean, ColorPickerLocalizationService])
], ColorGradientLocalizationService);

/**
 * @hidden
 */
let ColorInputComponent = class ColorInputComponent {
    constructor(localization, host, renderer) {
        this.localization = localization;
        this.host = host;
        this.renderer = renderer;
        /**
         * Sets whether the alpha slider will be shown.
         */
        this.opacity = true;
        /**
         * Sets the disabled state of the ColorInput.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorInput.
         */
        this.readonly = false;
        /**
         * Emits a parsed rgba string color.
         */
        this.valueChange = new EventEmitter();
        this.colorInputClass = true;
        /**
         * The rgba inputs values.
         */
        this.rgba = {};
        this.subscriptions = new Subscription();
    }
    /**
     * Indicates whether any of the inputs are focused.
     */
    get isFocused() {
        if (!(isDocumentAvailable() && isPresent(this.host))) {
            return false;
        }
        const activeElement = document.activeElement;
        return this.host.nativeElement.contains(activeElement);
    }
    /**
     * Indicates whether any of the rgba inputs have value.
     */
    get rgbaInputValid() {
        return Object.keys(this.rgba).every(key => isPresent(this.rgba[key]));
    }
    ngAfterViewInit() {
        this.initDomEvents();
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    ngOnChanges(changes) {
        if (isPresent(changes.value) && !this.isFocused) {
            this.hex = parseColor$1(this.value, 'hex');
            this.rgba = getRGBA(this.value);
            this.rgba.a = parseColor$1(this.value, 'rgba') ? this.rgba.a : 1;
        }
    }
    handleRgbaValueChange() {
        const color = getColorFromRGBA(this.rgba);
        if (!this.rgbaInputValid || color === this.value) {
            return;
        }
        this.value = color;
        this.rgba = getRGBA(this.value);
        this.hex = parseColor$1(color, 'hex');
        this.valueChange.emit(color);
    }
    handleHexValueChange(hex) {
        this.hex = hex;
        const color = parseColor$1(hex, 'rgba');
        if (!isPresent(color) || color === this.value) {
            return;
        }
        this.value = color;
        this.rgba = getRGBA(color);
        this.valueChange.emit(color);
    }
    handleRgbaInputBlur() {
        if (!this.rgbaInputValid) {
            this.rgba = getRGBA(this.value);
        }
    }
    handleHexInputBlur() {
        this.hex = parseColor$1(this.value, 'hex');
    }
    textFor(key) {
        return this.localization.get(key);
    }
    toggleFormatView() {
        this.formatView = this.formatView === 'hex' ? 'rgba' : 'hex';
    }
    initDomEvents() {
        if (!this.host) {
            return;
        }
        this.subscriptions.add(this.renderer.listen(this.toggleFormatButton.nativeElement, 'click', () => this.toggleFormatView()));
    }
}
ColorInputComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: ColorInputComponent, selectors: [["kendo-colorinput"]], factory: function ColorInputComponent_Factory(t) { return new (t || ColorInputComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(Renderer2)); }, viewQuery: function ColorInputComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c116, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c117, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.opacityInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.toggleFormatButton = _t.first);
    } }, hostBindings: function ColorInputComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(2);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-colorgradient-inputs", ctx.colorInputClass);
        ɵngcc0.ɵɵclassProp("k-hstack", ctx.colorInputClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { opacity: "opacity", disabled: "disabled", readonly: "readonly", value: "value", formatView: "formatView" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], consts: 6, vars: 2, template: function ColorInputComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", _c118);
        ɵngcc0.ɵɵelementStart(1, "button", _c119, _c120);
        ɵngcc0.ɵɵelement(3, "span", _c121);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, ColorInputComponent_input_4_Template, 2, 4, "input", _c122);
        ɵngcc0.ɵɵtemplate(5, ColorInputComponent_ng_container_5_Template, 17, 34, "ng-container", _c104);
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.formatView === "hex");
        ɵngcc0.ɵɵselect(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.formatView === "rgba");
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ColorInputComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-colorinput',
                template: `
        <div class="k-vstack">
            <button class="k-colorgradient-toggle-mode k-button k-icon-button k-flat" #toggleFormatButton>
                <span class="k-button-icon k-icon k-i-arrows-kpi"></span>
            </button>
        </div>
        <input *ngIf="formatView === 'hex'"
            #hexInput
            class="k-textbox k-hex-value"
            [disabled]="disabled"
            [readonly]="readonly"
            [value]="hex || ''"
            [placeholder]="textFor('hexInputPlaceholder')"
            (blur)="handleHexInputBlur()"
            (input)="handleHexValueChange(hexInput.value)"
        />
        <ng-container *ngIf="formatView === 'rgba'">
            <div class="k-vstack">
                <kendo-numerictextbox
                    #red
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [min]="0"
                    [max]="255"
                    [placeholder]="textFor('redInputPlaceholder')"
                    [(value)]="rgba.r"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="red.focusableId" class="k-colorgradient-input-label">R</label>
            </div>
            <div class="k-vstack">
                <kendo-numerictextbox
                    #green
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [min]="0"
                    [max]="255"
                    [placeholder]="textFor('greenInputPlaceholder')"
                    [(value)]="rgba.g"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="green.focusableId" class="k-colorgradient-input-label">G</label>
            </div>
            <div class="k-vstack">
                <kendo-numerictextbox
                    #blue
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [min]="0"
                    [max]="255"
                    [placeholder]="textFor('blueInputPlaceholder')"
                    [(value)]="rgba.b"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="blue.focusableId" class="k-colorgradient-input-label">B</label>
            </div>
            <div class="k-vstack" *ngIf="opacity">
                <kendo-numerictextbox  #opacityInput
                    #alpha
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [min]="0"
                    [max]="1"
                    [placeholder]="textFor('alphaInputPlaceholder')"
                    [(value)]="rgba.a"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [step]="0.01"
                    [format]="'n2'"
                    [decimals]="2"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="alpha.focusableId" class="k-colorgradient-input-label">A</label>
            </div>
        </ng-container>
    `
            }]
    }], function () { return [{ type: LocalizationService }, { type: ElementRef }, { type: Renderer2 }]; }, { constructor: [], localization: [], host: [], renderer: [], opacity: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], colorInputClass: [{
            type: HostBinding,
            args: ['class.k-colorgradient-inputs']
        }, {
            type: HostBinding,
            args: ['class.k-hstack']
        }], rgba: [], subscriptions: [], isFocused: [], rgbaInputValid: [], ngAfterViewInit: [], ngOnDestroy: [], ngOnChanges: [], hex: [], handleRgbaValueChange: [], value: [{
            type: Input
        }], handleHexValueChange: [], handleRgbaInputBlur: [], handleHexInputBlur: [], textFor: [], toggleFormatView: [], formatView: [{
            type: Input
        }], initDomEvents: [], opacityInput: [{
            type: ViewChild,
            args: ['opacityInput', { read: ElementRef, static: false }]
        }], toggleFormatButton: [{
            type: ViewChild,
            args: ['toggleFormatButton', { static: false }]
        }] });;
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorInputComponent.prototype, "formatView", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorInputComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorInputComponent.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorInputComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorInputComponent.prototype, "readonly", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorInputComponent.prototype, "valueChange", void 0);
__decorate([
    HostBinding('class.k-colorgradient-inputs'),
    HostBinding('class.k-hstack'),
    __metadata("design:type", Boolean)
], ColorInputComponent.prototype, "colorInputClass", void 0);
__decorate([
    ViewChild('opacityInput', { read: ElementRef, static: false }),
    __metadata("design:type", ElementRef)
], ColorInputComponent.prototype, "opacityInput", void 0);
__decorate([
    ViewChild('toggleFormatButton', { static: false }),
    __metadata("design:type", ElementRef)
], ColorInputComponent.prototype, "toggleFormatButton", void 0);
ColorInputComponent = __decorate([
    __metadata("design:paramtypes", [LocalizationService,
        ElementRef,
        Renderer2])
], ColorInputComponent);

/**
 * @hidden
 */
const DEFAULT_OUTPUT_FORMAT = 'rgba';
/**
 * @hidden
 */
const DEFAULT_GRADIENT_BACKGROUND_COLOR = 'rgba(255, 0, 0, 1)';
/**
 * @hidden
 */
const DRAGHANDLE_MOVE_SPEED = 5;
/**
 * @hidden
 */
const AAA_RATIO = 7.0;
/**
 * @hidden
 */
const AA_RATIO = 4.5;

var ColorGradientComponent_1;
let serial = 0;
/**
 * The ColorGradient component enables smooth color transitions and provides options for selecting specific colors over the drag handle.
 * The ColorGradient is independently used by `kendo-colorpicker` and can be directly added to the page.
 */
let ColorGradientComponent = ColorGradientComponent_1 = class ColorGradientComponent {
    constructor(host, ngZone, renderer, cdr, localizationService) {
        this.host = host;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.cdr = cdr;
        this.localizationService = localizationService;
        /**
         * @hidden
         */
        this.hostClasses = true;
        /**
         * @hidden
         */
        this.id = `k-colorgradient-${serial++}`;
        /**
         * Defines whether the alpha slider will be displayed.
         */
        this.opacity = true;
        /**
         * Sets the disabled state of the ColorGradient.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorGradient.
         */
        this.readonly = false;
        /**
         * Specifies whether the ColorGradient should display a 'Clear color' button.
         */
        this.clearButton = false;
        /**
         * Determines the delay time (in milliseconds) before the value is changed on handle drag. A value of 0 indicates no delay.
         *
         * @default 0
         */
        this.delay = 0;
        /**
         * Fires each time the user selects a new color.
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.backgroundColor = DEFAULT_GRADIENT_BACKGROUND_COLOR;
        /**
         * @hidden
         *
         * Represents the currently selected `hue`, `saturation`, `value`, and `alpha` values.
         * The values are initially set in `ngOnInit` or in `ngOnChanges` and are
         * updated on moving the drag handle or the sliders.
         */
        this.hsva = {};
        /**
         * Specifies the output format of the ColorGradientComponent.
         * The input value may be in a different format. However, it will be parsed into the output `format`
         * after the component processes it.
         *
         * The supported values are:
         * * (Default) `rgba`
         * * `hex`
         */
        this.format = DEFAULT_OUTPUT_FORMAT;
        this._tabindex = 0;
        this.listeners = [];
        this.updateValues = new Subject();
        this.notifyNgChanged = () => { };
        this.notifyNgTouched = () => { };
        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    /**
     * @hidden
     */
    get readonlyAttribute() {
        return this.readonly;
    }
    /**
     * @hidden
     */
    get disabledClass() {
        return this.disabled;
    }
    /**
     * @hidden
     */
    get hostTabindex() {
        return this.tabindex;
    }
    /**
     * @hidden
     */
    get gradientId() {
        return this.id;
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor$1(value, this.format);
    }
    get value() {
        return this._value;
    }
    /**
     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * Indicates whether the ColorGradient or any of its content is focused.
     */
    get isFocused() {
        if (!(isDocumentAvailable() && isPresent(this.host))) {
            return false;
        }
        return this.host.nativeElement === document.activeElement || this.host.nativeElement.contains(document.activeElement);
    }
    /**
     * @hidden
     */
    get alphaSliderValue() {
        // setting the initial value to undefined to force the slider to recalculate the height of the slider track on the next cdr run
        if (!(isPresent(this.hsva) && isPresent(this.hsva.a))) {
            return;
        }
        return this.hsva.a * 100;
    }
    get gradientRect() {
        return this.gradientWrapper.nativeElement.getBoundingClientRect();
    }
    /**
     * @hidden
     */
    get contrastToolVisible() {
        return typeof this.contrastTool === 'string' && this.contrastTool !== '';
    }
    ngAfterViewInit() {
        this.updateUI();
        this.cdr.detectChanges();
        this.addEventListeners();
        this.subscribeChanges();
    }
    ngOnChanges(changes) {
        if (isChanged('value', changes) && !this.isFocused) {
            this.updateUI();
        }
        if (isChanged('delay', changes)) {
            this.unsubscribeChanges();
            this.subscribeChanges();
        }
    }
    ngOnDestroy() {
        this.listeners.forEach(removeListener => removeListener());
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
        this.unsubscribeChanges();
    }
    /**
     * Focuses the component.
     */
    focus() {
        if (this.disabled) {
            return;
        }
        this.host.nativeElement.focus();
    }
    /**
     * @hidden
     */
    reset() {
        this.handleValueChange(undefined);
        this.updateUI();
        this.host.nativeElement.focus();
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (this.disabled || this.readonly || !isPresent(args.originalEvent)) {
            return;
        }
        this.focus();
        args.originalEvent.preventDefault();
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');
        this.changePosition(args);
    }
    /**
     * @hidden
     */
    onHandleRelease() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');
        this.handleValueChange(getColorFromHSV(this.hsva));
    }
    /**
     * @hidden
     */
    onKeyboardAction(args) {
        if (this.disabled || this.readonly) {
            return;
        }
        if (args.key && args.key.indexOf('Arrow') !== -1) {
            args.preventDefault();
            const dragHandleElement = this.gradientDragHandle.nativeElement;
            this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');
            let keyboardMoveX = 0;
            let keyboardMoveY = 0;
            switch (args.key) {
                case 'ArrowRight':
                    keyboardMoveX = DRAGHANDLE_MOVE_SPEED;
                    break;
                case 'ArrowLeft':
                    keyboardMoveX = -DRAGHANDLE_MOVE_SPEED;
                    break;
                case 'ArrowUp':
                    keyboardMoveY = -DRAGHANDLE_MOVE_SPEED;
                    break;
                case 'ArrowDown':
                    keyboardMoveY = DRAGHANDLE_MOVE_SPEED;
                    break;
                default: break;
            }
            const newY = parseInt(dragHandleElement.style.top, 10) + keyboardMoveY;
            const newX = parseInt(dragHandleElement.style.left, 10) + keyboardMoveX;
            this.renderer.setStyle(dragHandleElement, 'top', `${newY}px`);
            this.renderer.setStyle(dragHandleElement, 'left', `${newX}px`);
            this.ngZone.run(() => this.moveDragHandle(newX, newY));
        }
    }
    /**
     * @hidden
     */
    changePosition(position) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.gradientDragHandle.nativeElement.focus();
        const newX = position.clientX - this.gradientRect.left;
        const newY = position.clientY - this.gradientRect.top;
        this.ngZone.run(() => this.moveDragHandle(newX, newY));
    }
    /**
     * @hidden
     */
    handleHueSliderChange(hue) {
        this.handleValueChange(getColorFromHSV(this.hsva));
        this.backgroundColor = getColorFromHue(hue);
        this.setAlphaSliderBackground(this.backgroundColor);
    }
    /**
     * @hidden
     */
    handleAlphaSliderChange(alpha) {
        this.hsva.a = alpha / 100;
        this.handleValueChange(getColorFromHSV(this.hsva));
    }
    /**
     * @hidden
     */
    handleInputsValueChange(color) {
        const parsed = parseColor$1(color, this.format);
        if (this.value !== parsed) {
            this.handleValueChange(parsed);
            this.updateUI();
        }
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        if (isPresent(this.gradientWrapper)) {
            this.updateUI();
        }
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.cdr.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    get colorGradientHandleTitle() {
        return this.localizationService.get('colorGradientHandle');
    }
    /**
     * @hidden
     */
    get colorGradientHandleAriaLabel() {
        const parsed = parseColor$1(this.value, this.format);
        return `${this.value ? parsed : this.localizationService.get('colorGradientHandle')}`;
    }
    /**
     * @hidden
     */
    get hueSliderTitle() {
        return this.localizationService.get('hueSliderHandle');
    }
    /**
     * @hidden
     */
    get opacitySliderTitle() {
        return this.localizationService.get('opacitySliderHandle');
    }
    /**
     * @hidden
     */
    get clearButtonTitle() {
        return this.localizationService.get('clearButton');
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    moveDragHandle(positionX, positionY) {
        const top = fitIntoBounds(positionY, 0, this.gradientRect.height);
        const left = fitIntoBounds(positionX, 0, this.gradientRect.width);
        this.setDragHandleElementPosition(top, left);
        this.hsva.s = left / this.gradientRect.width;
        this.hsva.v = 1 - top / this.gradientRect.height;
        this.updateValues.next(getColorFromHSV(this.hsva));
        this.setAlphaSliderBackground(getColorFromHSV(Object.assign({}, this.hsva, { a: 1 })));
    }
    updateUI() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.hsva = this.value ? getHSV(this.value) : { h: 0, s: 0, v: 1, a: 1 };
        const top = (1 - this.hsva.v) * this.gradientRect.height;
        const left = this.hsva.s * this.gradientRect.width;
        this.setDragHandleElementPosition(top, left);
        this.backgroundColor = getColorFromHue(this.hsva.h);
        this.setAlphaSliderBackground(this.backgroundColor);
        this.setHostElementAriaLabel();
    }
    handleValueChange(color) {
        if (this.value === color) {
            return;
        }
        this.value = color;
        this.valueChange.emit(color);
        this.notifyNgChanged(color);
        this.setHostElementAriaLabel();
    }
    setDragHandleElementPosition(top, left) {
        const dragHandle = this.gradientDragHandle.nativeElement;
        this.renderer.setStyle(dragHandle, 'top', `${top}px`);
        this.renderer.setStyle(dragHandle, 'left', `${left}px`);
    }
    setAlphaSliderBackground(backgroundColor) {
        if (!isPresent(this.alphaSlider)) {
            return;
        }
        const sliderTrack = this.alphaSlider.track.nativeElement;
        this.renderer.setStyle(sliderTrack, 'background', `linear-gradient(to top, transparent, ${backgroundColor})`);
    }
    setHostElementAriaLabel() {
        const parsed = parseColor$1(this.value, this.format);
        this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorGradientNoColor')}`);
    }
    addEventListeners() {
        this.ngZone.runOutsideAngular(() => {
            const focusOutListener = this.renderer.listen(this.host.nativeElement, 'focusout', (event) => {
                if (!containsFocus(this.host.nativeElement, event.relatedTarget) && isUntouched(this.host)) {
                    this.ngZone.run(() => this.notifyNgTouched());
                }
            });
            const keydownListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keydown', (event) => {
                this.onKeyboardAction(event);
            });
            const keyupListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keyup', () => {
                this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');
                if (!this.readonly && !this.disabled) {
                    this.ngZone.run(() => this.handleValueChange(getColorFromHSV(this.hsva)));
                }
            });
            const dragHandleFocusInListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusin', () => {
                this.renderer.addClass(this.gradientDragHandle.nativeElement, 'k-state-focus');
            });
            const dragHandleFocusOutListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusout', () => {
                this.renderer.removeClass(this.gradientDragHandle.nativeElement, 'k-state-focus');
            });
            this.listeners.push(focusOutListener, keydownListener, keyupListener, dragHandleFocusInListener, dragHandleFocusOutListener);
        });
    }
    subscribeChanges() {
        this.changeRequestsSubscription = this.updateValues.pipe(throttleTime(this.delay)).subscribe(value => {
            this.handleValueChange(value);
        });
    }
    unsubscribeChanges() {
        if (this.changeRequestsSubscription) {
            this.changeRequestsSubscription.unsubscribe();
        }
    }
}
ColorGradientComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: ColorGradientComponent, selectors: [["kendo-colorgradient"]], factory: function ColorGradientComponent_Factory(t) { return new (t || ColorGradientComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, viewQuery: function ColorGradientComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c133, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c134, true);
        ɵngcc0.ɵɵviewQuery(_c135, true);
        ɵngcc0.ɵɵviewQuery(_c136, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.gradientDragHandle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.inputs = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.alphaSlider = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.gradientWrapper = _t.first);
    } }, hostBindings: function ColorGradientComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(6);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction)("aria-readonly", ctx.readonlyAttribute)("tabindex", ctx.hostTabindex)("id", ctx.gradientId);
        ɵngcc0.ɵɵclassProp("k-colorgradient", ctx.hostClasses);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabledClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { id: "id", opacity: "opacity", disabled: "disabled", readonly: "readonly", clearButton: "clearButton", delay: "delay", format: "format", value: "value", tabindex: "tabindex", contrastTool: "contrastTool" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorGradientComponent_1)
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorGradientComponent_1)
            },
            ColorGradientLocalizationService,
            {
                provide: LocalizationService,
                useExisting: ColorGradientLocalizationService
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorgradient'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], consts: 15, vars: 27, template: function ColorGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, _c137);
        ɵngcc0.ɵɵi18nAttributes(1, _c164);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "div", _c165);
        ɵngcc0.ɵɵelementStart(3, "div", _c166);
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵelementStart(4, "div", _c167, _c168);
        ɵngcc0.ɵɵlistener("click", function ColorGradientComponent_Template_div_click_4_listener($event) { return ctx.changePosition($event); });
        ɵngcc0.ɵɵlistener("kendoPress", function ColorGradientComponent_Template_div_kendoPress_4_listener($event) { return ctx.handleDragPress($event); });
        ɵngcc0.ɵɵlistener("kendoDrag", function ColorGradientComponent_Template_div_kendoDrag_4_listener($event) { return ctx.onHandleDrag($event); });
        ɵngcc0.ɵɵlistener("kendoRelease", function ColorGradientComponent_Template_div_kendoRelease_4_listener($event) { return ctx.onHandleRelease(); });
        ɵngcc0.ɵɵelement(6, "div", _c169, _c170);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div");
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵtemplate(9, ColorGradientComponent_span_9_Template, 2, 2, "span", _c171);
        ɵngcc0.ɵɵelementStart(10, "kendo-slider", _c172);
        ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_slider_valueChange_10_listener($event) { return ctx.hsva.h = $event; });
        ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_slider_valueChange_10_listener($event) { return ctx.handleHueSliderChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, ColorGradientComponent_kendo_slider_11_Template, 2, 14, "kendo-slider", _c173);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "kendo-colorinput", _c174, _c175);
        ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_colorinput_valueChange_12_listener($event) { return ctx.handleInputsValueChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(14, ColorGradientComponent_div_14_Template, 1, 2, "div", _c176);
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(3);
        ɵngcc0.ɵɵstyleSanitizer(ɵngcc0.ɵɵdefaultStyleSanitizer);
        ɵngcc0.ɵɵstyleProp("background", ctx.backgroundColor);
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵselect(6);
        ɵngcc0.ɵɵattribute("title", ctx.colorGradientHandleTitle)("aria-label", ctx.colorGradientHandleAriaLabel);
        ɵngcc0.ɵɵselect(8);
        ɵngcc0.ɵɵclassMapInterpolate1("k-hsv-controls k-hstack ", ctx.clearButton ? "k-sliders-wrap-clearable" : "", "");
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵselect(9);
        ɵngcc0.ɵɵproperty("ngIf", ctx.clearButton);
        ɵngcc0.ɵɵselect(10);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(25, _c181, ctx.clearButton))("dragHandleTitle", ctx.hueSliderTitle)("disabled", ctx.disabled)("readonly", ctx.readonly)("showButtons", false)("tickPlacement", "none")("vertical", true)("min", 0)("max", 360)("smallStep", 5)("largeStep", 10)("value", ctx.hsva.h);
        ɵngcc0.ɵɵselect(11);
        ɵngcc0.ɵɵproperty("ngIf", ctx.opacity && ctx.format === "rgba");
        ɵngcc0.ɵɵselect(12);
        ɵngcc0.ɵɵproperty("opacity", ctx.opacity)("formatView", ctx.format)("value", ctx.value)("disabled", ctx.disabled)("readonly", ctx.readonly);
        ɵngcc0.ɵɵselect(14);
        ɵngcc0.ɵɵproperty("ngIf", ctx.contrastToolVisible);
    } }, styles: [".k-clear-color[_ngcontent-%COMP%] {\n            position: absolute;\n            left: 50%;\n            transform: translateX(-50%);\n        }\n        .k-align-self-end[_ngcontent-%COMP%] {\n            height: 140px;\n        }"] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ColorGradientComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-colorgradient',
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ColorGradientComponent_1)
                    },
                    {
                        provide: KendoInput,
                        useExisting: forwardRef(() => ColorGradientComponent_1)
                    },
                    ColorGradientLocalizationService,
                    {
                        provide: LocalizationService,
                        useExisting: ColorGradientLocalizationService
                    },
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.colorgradient'
                    }
                ],
                template: `
        <ng-container kendoColorGradientLocalizedMessages
            i18n-colorGradientNoColor="kendo.colorgradient.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorGradientHandle="kendo.colorgradient.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.colorgradient.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.colorgradient.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.colorgradient.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-hexInputPlaceholder="kendo.colorgradient.hexInputPlaceholder|The placeholder for the HEX color input."
            hexInputPlaceholder="HEX Color"
            i18n-redInputPlaceholder="kendo.colorgradient.redInputPlaceholder|The placeholder for the red color input."
            redInputPlaceholder="Red"
            i18n-greenInputPlaceholder="kendo.colorgradient.greenInputPlaceholder|The placeholder for the green color input."
            greenInputPlaceholder="Green"
            i18n-blueInputPlaceholder="kendo.colorgradient.blueInputPlaceholder|The placeholder for the blue color input."
            blueInputPlaceholder="Blue"
            i18n-alphaInputPlaceholder="kendo.colorgradient.alphaInputPlaceholder|The placeholder for the alpha input."
            alphaInputPlaceholder="Alpha"
            i18n-passContrast="kendo.colorgradient.passContrast|The pass message for the contrast tool."
            passContrast="Pass"
            i18n-failContrast="kendo.colorgradient.failContrast|The fail message for the contrast tool."
            failContrast="Fail"
            i18n-contrastRatio="kendo.colorgradient.contrastRatio|The contrast ratio message for the contrast tool."
            contrastRatio="Contrast ratio">
        </ng-container>
        <div class="k-colorgradient-canvas k-hstack">
            <div class="k-hsv-rectangle" [style.background]="backgroundColor">
                <div
                    #gradientWrapper
                    kendoDraggable
                    class="k-hsv-gradient"
                    (click)="changePosition($event)"
                    (kendoPress)="handleDragPress($event)"
                    (kendoDrag)="onHandleDrag($event)"
                    (kendoRelease)="onHandleRelease()">
                    <div
                        #gradientDragHandle
                        class="k-hsv-draghandle k-draghandle"
                        tabindex="0"
                        [attr.title]="colorGradientHandleTitle"
                        [attr.aria-label]="colorGradientHandleAriaLabel"
                    >
                    </div>
                </div>
            </div>
            <div class="k-hsv-controls k-hstack {{ clearButton ? 'k-sliders-wrap-clearable' : '' }}">
                <span class="k-clear-color k-button k-flat k-button-icon"
                    *ngIf="clearButton"
                    (click)="reset()"
                    (keydown.enter)="reset()"
                    (keydown.space)="reset()"
                    [attr.aria-label]="clearButtonTitle"
                    [attr.title]="clearButtonTitle"
                    tabindex="0">
                    <span class="k-icon k-i-reset-color"></span>
                </span>
                <kendo-slider
                    [ngClass]="{'k-align-self-end': clearButton}"
                    class="k-hue-slider k-colorgradient-slider"
                    [dragHandleTitle]="hueSliderTitle"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    [tickPlacement]="'none'"
                    [vertical]="true"
                    [min]="0"
                    [max]="360"
                    [smallStep]="5"
                    [largeStep]="10"
                    [(value)]="hsva.h"
                    (valueChange)="handleHueSliderChange($event)"
                >
                </kendo-slider>
                <kendo-slider
                    *ngIf="opacity && format === 'rgba'"
                    #alphaSlider
                    [ngClass]="{'k-align-self-end': clearButton}"
                    class="k-alpha-slider k-colorgradient-slider"
                    [dragHandleTitle]="opacitySliderTitle"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    [tickPlacement]="'none'"
                    [vertical]="true"
                    [min]="0"
                    [max]="100"
                    [smallStep]="1"
                    [largeStep]="10"
                    [value]="alphaSliderValue"
                    (valueChange)="handleAlphaSliderChange($event)"
                >
                </kendo-slider>
            </div>
        </div>
        <kendo-colorinput  #inputs
            [opacity]="opacity"
            [formatView]="format"
            [value]="value"
            [disabled]="disabled"
            [readonly]="readonly"
            (valueChange)="handleInputsValueChange($event)"
        >
        </kendo-colorinput>
        <div class="k-colorgradient-color-contrast k-vbox" *ngIf="contrastToolVisible"
            kendoContrastTool
            [value]="value"
            [ratio]="contrastTool">
        </div>
    `,
                styles: [`
        .k-clear-color {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }
        .k-align-self-end {
            height: 140px;
        }
    `]
            }]
    }], function () { return [{ type: ElementRef }, { type: NgZone }, { type: Renderer2 }, { type: ChangeDetectorRef }, { type: LocalizationService }]; }, { constructor: [], host: [], ngZone: [], renderer: [], cdr: [], localizationService: [], hostClasses: [{
            type: HostBinding,
            args: ['class.k-colorgradient']
        }], id: [{
            type: Input
        }], opacity: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], delay: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], backgroundColor: [], hsva: [], format: [{
            type: Input
        }], _tabindex: [], listeners: [], updateValues: [], notifyNgChanged: [], notifyNgTouched: [], dynamicRTLSubscription: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], readonlyAttribute: [{
            type: HostBinding,
            args: ['attr.aria-readonly']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], hostTabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], gradientId: [{
            type: HostBinding,
            args: ['attr.id']
        }], value: [{
            type: Input
        }], value: [], _value: [], tabindex: [{
            type: Input
        }], tabindex: [], isFocused: [], alphaSliderValue: [], gradientRect: [], contrastToolVisible: [], ngAfterViewInit: [], ngOnChanges: [], ngOnDestroy: [], focus: [], reset: [], handleDragPress: [], onHandleDrag: [], onHandleRelease: [], onKeyboardAction: [], changePosition: [], handleHueSliderChange: [], handleAlphaSliderChange: [], handleInputsValueChange: [], writeValue: [], registerOnChange: [], registerOnTouched: [], setDisabledState: [], colorGradientHandleTitle: [], colorGradientHandleAriaLabel: [], hueSliderTitle: [], opacitySliderTitle: [], clearButtonTitle: [], isEmpty: [], moveDragHandle: [], updateUI: [], handleValueChange: [], setDragHandleElementPosition: [], setAlphaSliderBackground: [], setHostElementAriaLabel: [], addEventListeners: [], subscribeChanges: [], changeRequestsSubscription: [], unsubscribeChanges: [], contrastTool: [{
            type: Input
        }], gradientDragHandle: [{
            type: ViewChild,
            args: ['gradientDragHandle', { read: ElementRef, static: false }]
        }], inputs: [{
            type: ViewChild,
            args: ['inputs', { static: false }]
        }], alphaSlider: [{
            type: ViewChild,
            args: ['alphaSlider', { static: false }]
        }], gradientWrapper: [{
            type: ViewChild,
            args: ['gradientWrapper', { static: false }]
        }] });;
__decorate([
    HostBinding('class.k-colorgradient'),
    __metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('attr.aria-readonly'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "readonlyAttribute", null);
__decorate([
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "disabledClass", null);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "hostTabindex", null);
__decorate([
    HostBinding('attr.id'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "gradientId", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorGradientComponent.prototype, "id", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], ColorGradientComponent.prototype, "direction", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "clearButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ColorGradientComponent.prototype, "delay", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ColorGradientComponent.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorGradientComponent.prototype, "contrastTool", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], ColorGradientComponent.prototype, "tabindex", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorGradientComponent.prototype, "valueChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorGradientComponent.prototype, "format", void 0);
__decorate([
    ViewChild('gradientDragHandle', { read: ElementRef, static: false }),
    __metadata("design:type", ElementRef)
], ColorGradientComponent.prototype, "gradientDragHandle", void 0);
__decorate([
    ViewChild('inputs', { static: false }),
    __metadata("design:type", ColorInputComponent)
], ColorGradientComponent.prototype, "inputs", void 0);
__decorate([
    ViewChild('alphaSlider', { static: false }),
    __metadata("design:type", SliderComponent)
], ColorGradientComponent.prototype, "alphaSlider", void 0);
__decorate([
    ViewChild('gradientWrapper', { static: false }),
    __metadata("design:type", ElementRef)
], ColorGradientComponent.prototype, "gradientWrapper", void 0);
ColorGradientComponent = ColorGradientComponent_1 = __decorate([
    __metadata("design:paramtypes", [ElementRef,
        NgZone,
        Renderer2,
        ChangeDetectorRef,
        LocalizationService])
], ColorGradientComponent);

var ColorPickerComponent_1;
const DEFAULT_PRESET = 'office';
const DEFAULT_ACCESSIBLE_PRESET = 'accessible';
let serial$1 = 0;
/**
 * Represents the [Kendo UI ColorPicker component for Angular]({% slug overview_colorpicker %}).
 * Designed to replace the `<input type="color">` HTML5 tag which is not widely supported in browsers.
 */
let ColorPickerComponent = ColorPickerComponent_1 = class ColorPickerComponent {
    constructor(popupService, cdr, localizationService, ngZone) {
        this.popupService = popupService;
        this.cdr = cdr;
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        /**
         * @hidden
         */
        this.hostClasses = true;
        /**
         * @hidden
         */
        this.focusableId = `k-colorpicker-${serial$1++}`;
        /**
         * Sets what view the ColorPicker will render in the popup.
         */
        this.view = 'gradient';
        /**
         * Sets the read-only state of the ColorPicker.
         */
        this.readonly = false;
        /**
         * Sets the disabled state of the ColorPicker.
         */
        this.disabled = false;
        /**
         * Specifies the output format of the ColorPicker.
         * The input value may be in a different format. However, it will be parsed into the output `format`
         * after the component processes it.
         *
         * If the `gradient` view is used with the `opacity` option set to true, this setting will be ignored and `rgba` will be used instead.
         *
         * The supported values are:
         * * `rgba` (default)
         * * `hex`
         * * [name](https://www.w3.org/wiki/CSS/Properties/color/keywords)
         */
        this.format = 'rgba';
        /**
         * Fires each time the value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires each time ColorPicker is focused.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the ColorPicker is blurred.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires each time the left side of the ColorPicker wrapper is clicked.
         * The event is triggered regardless of whether a ColorPicker icon is set or not.
         *
         * The [ActiveColorClickEvent]({% slug api_inputs_activecolorclickevent %}) event provides the option to prevent the popup opening.
         */
        this.activeColorClick = new EventEmitter();
        this._tabindex = 0;
        this._popupSettings = { animate: true };
        this._paletteSettings = {};
        this._gradientSettings = { opacity: true, clearButton: false, delay: 0 };
        this.notifyNgTouched = () => { };
        this.notifyNgChanged = () => { };
        validatePackage(packageMetadata);
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor$1(value, this.format);
    }
    get value() {
        return this._value;
    }
    /**
     * Configures the popup of the ColorPicker.
     */
    set popupSettings(value) {
        this._popupSettings = Object.assign(this._popupSettings, value);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    /**
     * Configures the palette that is displayed in the ColorPicker popup.
     */
    set paletteSettings(value) {
        this._paletteSettings = Object.assign(this._paletteSettings, value);
    }
    get paletteSettings() {
        return this._paletteSettings;
    }
    /**
     * Configures the gradient that is displayed in the ColorPicker popup.
     */
    set gradientSettings(value) {
        this._gradientSettings = Object.assign(this._gradientSettings, value);
    }
    get gradientSettings() {
        return this._gradientSettings;
    }
    /**
     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * Indicates whether the ColorPicker popup is open.
     */
    get isOpen() {
        return isPresent(this.popupRef);
    }
    /**
     * @hidden
     */
    get iconStyles() {
        if (this.iconClass) {
            return this.iconClass;
        }
        if (this.icon) {
            return `k-icon k-i-${this.icon}`;
        }
    }
    ngOnInit() {
        const defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;
        const settingsPalette = this._paletteSettings.palette;
        const presetColumns = typeof settingsPalette === 'string' && PALETTEPRESETS[settingsPalette] ?
            PALETTEPRESETS[settingsPalette].columns :
            undefined;
        this._paletteSettings = {
            palette: settingsPalette || defaultPreset,
            tileSize: this._paletteSettings.tileSize || 24,
            columns: this._paletteSettings.columns || presetColumns || 10
        };
    }
    ngOnChanges(changes) {
        if (changes.format && changes.format.currentValue === 'name') {
            this.view = 'palette';
        }
        if (this.view === 'gradient' && this.gradientSettings.opacity) {
            this.format = 'rgba';
            this.value = parseColor$1(this.value, this.format);
        }
    }
    ngOnDestroy() {
        this.closePopup();
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    handleWrapperClick() {
        this.toggleWithEvents(!this.isOpen);
        this.focus();
    }
    /**
     * @hidden
     */
    handleActiveColorClick() {
        this.focus();
        const event = new ActiveColorClickEvent(this.value);
        this.activeColorClick.emit(event);
        if (!event.isOpenPrevented() || this.isOpen) {
            this.handleWrapperClick();
        }
    }
    /**
     * Focuses the wrapper of the ColorPicker.
     */
    focus() {
        if (this.disabled) {
            return;
        }
        this.wrapper.nativeElement.focus();
    }
    /**
     * @hidden
     */
    handleWrapperFocus() {
        if (isPresent(this.palette)) {
            this.palette.nativeElement.focus();
        }
        if (this.isFocused) {
            return;
        }
        this.isFocused = true;
        this.onFocus.emit();
    }
    /**
     * Blurs the ColorPicker.
     */
    blur() {
        this.wrapper.nativeElement.blur();
    }
    /**
     * @hidden
     */
    handleWrapperBlur() {
        if (this.isOpen) {
            return;
        }
        this.isFocused = false;
        this.onBlur.emit();
        this.notifyNgTouched();
    }
    /**
     * Clears the color value of the ColorPicker.
     */
    reset() {
        if (!isPresent(this.value)) {
            return;
        }
        this._value = undefined;
        this.notifyNgChanged(undefined);
    }
    /**
     * Toggles the popup of the ColorPicker.
     * Does not trigger the `open` and `close` events of the component.
     *
     * @param open An optional parameter. Specifies whether the popup will be opened or closed.
     */
    toggle(open) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.closePopup();
        open = isPresent(open) ? open : !this.isOpen;
        if (open) {
            this.openPopup();
        }
    }
    /**
     * @hidden
     */
    handleValueChange(color, closePopup) {
        const parsedColor = parseColor$1(color, this.format);
        const valueChange = parsedColor !== this.value;
        if (closePopup) {
            this.toggleWithEvents(false);
            this.focus();
        }
        if (valueChange) {
            this.value = parsedColor;
            this.valueChange.emit(parsedColor);
            this.notifyNgChanged(parsedColor);
        }
    }
    /**
     * @hidden
     */
    handlePopupBlur(event) {
        const focusInPopupElement = this.popupRef.popupElement.contains(event.relatedTarget);
        const wrapperClicked = event.relatedTarget === this.wrapper.nativeElement;
        if (!this.isFocused || wrapperClicked || focusInPopupElement) {
            return;
        }
        this.isFocused = false;
        this.onBlur.emit();
        this.notifyNgTouched();
        this.toggleWithEvents(false);
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.cdr.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    handleWrapperKeyDown(event) {
        if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.Enter) {
            event.preventDefault();
            this.toggleWithEvents(true);
        }
    }
    /**
     * @hidden
     */
    handlePopupKeyDown(event) {
        if (event.keyCode === Keys.Escape) {
            this.toggleWithEvents(false);
            this.wrapper.nativeElement.focus();
        }
        if (event.keyCode === Keys.Tab) {
            const firstElement = this.colorGradient ? this.colorGradient.gradientDragHandle.nativeElement : this.palette.nativeElement;
            const lastElement = this.palette ? this.palette.nativeElement :
                this.colorGradient.inputs.opacityInput.nativeElement.childNodes[1].children[0];
            if (event.shiftKey) {
                if (event.target === firstElement) {
                    event.preventDefault();
                    lastElement.focus();
                    return;
                }
            }
            else {
                if (event.target === lastElement) {
                    event.preventDefault();
                    firstElement.focus();
                    return;
                }
            }
        }
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    toggleWithEvents(open) {
        const sameState = this.isOpen === open;
        if (this.disabled || this.readonly || sameState) {
            return;
        }
        const eventArgs = new PreventableEvent();
        open ? this.open.emit(eventArgs) : this.close.emit(eventArgs);
        if (!eventArgs.isDefaultPrevented()) {
            this.toggle(open);
        }
        if (open) {
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    if (this.colorGradient) {
                        this.colorGradient.gradientDragHandle.nativeElement.focus();
                    }
                });
            });
        }
    }
    openPopup() {
        const horizontalAlign = this.direction === "rtl" ? "right" : "left";
        const anchorPosition = { horizontal: horizontalAlign, vertical: "bottom" };
        const popupPosition = { horizontal: horizontalAlign, vertical: "top" };
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            animate: this.popupSettings.animate,
            appendTo: this.popupSettings.appendTo,
            popupAlign: popupPosition,
            anchorAlign: anchorPosition,
            popupClass: 'k-colorpicker-popup',
            content: this.popupTemplate,
            positionMode: 'absolute'
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(() => {
            this.toggleWithEvents(false);
            if (!this.isOpen) {
                this.wrapper.nativeElement.focus({
                    preventScroll: true
                });
            }
        });
    }
    closePopup() {
        if (!this.isOpen) {
            return;
        }
        this.popupRef.close();
        this.popupRef = null;
        this.palette = null;
    }
}
ColorPickerComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: ColorPickerComponent, selectors: [["kendo-colorpicker"]], factory: function ColorPickerComponent_Factory(t) { return new (t || ColorPickerComponent)(ɵngcc0.ɵɵdirectiveInject(PopupService), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(NgZone)); }, viewQuery: function ColorPickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c183, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c184, true, ViewContainerRef);
        ɵngcc0.ɵɵstaticViewQuery(_c46, true);
        ɵngcc0.ɵɵstaticViewQuery(_c185, true);
        ɵngcc0.ɵɵviewQuery(_c186, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.palette = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.wrapper = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.popupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx.colorGradient = _t.first);
    } }, hostBindings: function ColorPickerComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(3);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses);
        ɵngcc0.ɵɵclassProp("k-colorpicker", ctx.hostClasses);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { focusableId: "focusableId", view: "view", readonly: "readonly", disabled: "disabled", format: "format", value: "value", popupSettings: "popupSettings", paletteSettings: "paletteSettings", gradientSettings: "gradientSettings", tabindex: "tabindex", icon: "icon", iconClass: "iconClass" }, outputs: { valueChange: "valueChange", open: "open", close: "close", onFocus: "focus", onBlur: "blur", activeColorClick: "activeColorClick" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorPickerComponent_1)
            }, {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorPickerComponent_1)
            },
            ColorPickerLocalizationService,
            {
                provide: LocalizationService,
                useExisting: ColorPickerLocalizationService
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorpicker'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], consts: 12, vars: 12, template: function ColorPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, _c187);
        ɵngcc0.ɵɵi18nAttributes(1, _c206);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "span", _c207, _c54);
        ɵngcc0.ɵɵlistener("focus", function ColorPickerComponent_Template_span_focus_2_listener($event) { return ctx.handleWrapperFocus(); });
        ɵngcc0.ɵɵlistener("blur", function ColorPickerComponent_Template_span_blur_2_listener($event) { return ctx.handleWrapperBlur(); });
        ɵngcc0.ɵɵlistener("mousedown", function ColorPickerComponent_Template_span_mousedown_2_listener($event) { return $event.preventDefault(); });
        ɵngcc0.ɵɵlistener("keydown", function ColorPickerComponent_Template_span_keydown_2_listener($event) { return ctx.handleWrapperKeyDown($event); });
        ɵngcc0.ɵɵtemplate(4, ColorPickerComponent_span_4_Template, 2, 2, "span", _c208);
        ɵngcc0.ɵɵtemplate(5, ColorPickerComponent_span_5_Template, 2, 2, "span", _c209);
        ɵngcc0.ɵɵelementStart(6, "span", _c210);
        ɵngcc0.ɵɵlistener("click", function ColorPickerComponent_Template_span_click_6_listener($event) { return ctx.handleWrapperClick(); });
        ɵngcc0.ɵɵelement(7, "span", _c79);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, ColorPickerComponent_ng_template_8_Template, 2, 2, "ng-template", null, _c211, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementContainer(10, null, _c212);
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(9, _c224, ctx.disabled, ctx.isFocused))("id", ctx.focusableId);
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.isOpen)("aria-readonly", ctx.readonly)("aria-disabled", ctx.disabled)("aria-label", ctx.value)("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.iconStyles);
        ɵngcc0.ɵɵselect(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconStyles);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ColorPickerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-colorpicker',
                providers: [{
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ColorPickerComponent_1)
                    }, {
                        provide: KendoInput,
                        useExisting: forwardRef(() => ColorPickerComponent_1)
                    },
                    ColorPickerLocalizationService,
                    {
                        provide: LocalizationService,
                        useExisting: ColorPickerLocalizationService
                    },
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.colorpicker'
                    }
                ],
                template: `
        <ng-container kendoColorPickerLocalizedMessages
            i18n-colorGradient="kendo.colorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorGradient="kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen"
            i18n-colorGradientHandle="kendo.colorpicker.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.colorpicker.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.colorpicker.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.colorpicker.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-hexInputPlaceholder="kendo.colorpicker.hexInputPlaceholder|The placeholder for the HEX color input."
            hexInputPlaceholder="HEX Color"
            i18n-redInputPlaceholder="kendo.colorpicker.redInputPlaceholder|The placeholder for the red color input."
            redInputPlaceholder="Red"
            i18n-greenInputPlaceholder="kendo.colorpicker.greenInputPlaceholder|The placeholder for the green color input."
            greenInputPlaceholder="Green"
            i18n-blueInputPlaceholder="kendo.colorpicker.blueInputPlaceholder|The placeholder for the blue color input."
            blueInputPlaceholder="Blue"
            i18n-alphaInputPlaceholder="kendo.colorpicker.alphaInputPlaceholder|The placeholder for the alpha input."
            alphaInputPlaceholder="Alpha">
        </ng-container>
        <span
            #wrapper
            [ngClass]="{
                'k-picker-wrap': true,
                'k-state-disabled': this.disabled,
                'k-state-focused': this.isFocused
            }"
            role="listbox"
            [attr.aria-expanded]="isOpen"
            [attr.aria-readonly]="readonly"
            [attr.aria-disabled]="disabled"
            [attr.aria-label]="value"
            [id]="focusableId"
            [attr.tabindex]="tabindex"
            (focus)="handleWrapperFocus()"
            (blur)="handleWrapperBlur()"
            (mousedown)="$event.preventDefault()"
            (keydown)="handleWrapperKeyDown($event)"
        >
            <span *ngIf="!iconStyles" class="k-selected-color" [style.background-color]="value" (click)="handleActiveColorClick()">
                <span class="k-icon k-i-line" *ngIf="!value"></span>
            </span>
            <span *ngIf="iconStyles" class="k-tool-icon" [ngClass]="iconStyles" (click)="handleActiveColorClick()">
                <span class="k-selected-color" [style.background-color]="value"></span>
            </span>
            <span class="k-select" (click)="handleWrapperClick()">
                <span class="k-icon k-i-arrow-s"></span>
            </span>
        </span>
        <ng-template #popupTemplate>
            <kendo-colorgradient  #colorGradient
                *ngIf="view === 'gradient' || view === 'combo'"
                [value]="value"
                [format]="format"
                [opacity]="gradientSettings.opacity"
                [clearButton]="gradientSettings.clearButton"
                [delay]="gradientSettings.delay"
                (focusout)="handlePopupBlur($event)"
                (valueChange)="handleValueChange($event, false)"
                (keydown)="handlePopupKeyDown($event)"
            >
            </kendo-colorgradient>
            <kendo-colorpalette
                #palette
                *ngIf="view === 'palette' || view === 'combo'"
                kendoFocusOnDomReady
                [palette]="paletteSettings.palette"
                [columns]="paletteSettings.columns"
                [tileSize]="paletteSettings.tileSize"
                [format]="format"
                [value]="value"
                (blur)="handlePopupBlur($event)"
                (cellSelection)="handleValueChange($event, true)"
                (mousedown)="$event.preventDefault()"
                (keydown)="handlePopupKeyDown($event)"
            >
            </kendo-colorpalette>
        </ng-template>
        <ng-container #container></ng-container>
    `
            }]
    }], function () { return [{ type: PopupService }, { type: ChangeDetectorRef }, { type: LocalizationService }, { type: NgZone }]; }, { constructor: [], popupService: [], cdr: [], localizationService: [], ngZone: [], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-colorpicker']
        }], focusableId: [{
            type: Input
        }], view: [{
            type: Input
        }], readonly: [{
            type: Input
        }], disabled: [{
            type: Input
        }], format: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], activeColorClick: [{
            type: Output
        }], _tabindex: [], _popupSettings: [], _paletteSettings: [], _gradientSettings: [], notifyNgTouched: [], notifyNgChanged: [], dynamicRTLSubscription: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], value: [{
            type: Input
        }], value: [], _value: [], popupSettings: [{
            type: Input
        }], popupSettings: [], paletteSettings: [{
            type: Input
        }], paletteSettings: [], gradientSettings: [{
            type: Input
        }], gradientSettings: [], tabindex: [{
            type: Input
        }], tabindex: [], isOpen: [], iconStyles: [], ngOnInit: [], ngOnChanges: [], ngOnDestroy: [], handleWrapperClick: [], handleActiveColorClick: [], focus: [], handleWrapperFocus: [], isFocused: [], blur: [], handleWrapperBlur: [], reset: [], toggle: [], handleValueChange: [], handlePopupBlur: [], writeValue: [], registerOnChange: [], registerOnTouched: [], setDisabledState: [], handleWrapperKeyDown: [], handlePopupKeyDown: [], isEmpty: [], toggleWithEvents: [], openPopup: [], popupRef: [], closePopup: [], palette: [{
            type: ViewChild,
            args: ['palette', { read: ElementRef, static: false }]
        }], icon: [{
            type: Input
        }], iconClass: [{
            type: Input
        }], container: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef, static: true }]
        }], wrapper: [{
            type: ViewChild,
            args: ['wrapper', { static: true }]
        }], popupTemplate: [{
            type: ViewChild,
            args: ['popupTemplate', { static: true }]
        }], colorGradient: [{
            type: ViewChild,
            args: ['colorGradient', { static: false }]
        }] });;
__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-colorpicker'),
    __metadata("design:type", Boolean)
], ColorPickerComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], ColorPickerComponent.prototype, "direction", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerComponent.prototype, "focusableId", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerComponent.prototype, "view", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorPickerComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorPickerComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ColorPickerComponent.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ColorPickerComponent.prototype, "popupSettings", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ColorPickerComponent.prototype, "paletteSettings", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ColorPickerComponent.prototype, "gradientSettings", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerComponent.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColorPickerComponent.prototype, "iconClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], ColorPickerComponent.prototype, "tabindex", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "valueChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "open", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "close", void 0);
__decorate([
    Output('focus'),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "onFocus", void 0);
__decorate([
    Output('blur'),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "onBlur", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "activeColorClick", void 0);
__decorate([
    ViewChild('container', { read: ViewContainerRef, static: true }),
    __metadata("design:type", ViewContainerRef)
], ColorPickerComponent.prototype, "container", void 0);
__decorate([
    ViewChild('wrapper', { static: true }),
    __metadata("design:type", ElementRef)
], ColorPickerComponent.prototype, "wrapper", void 0);
__decorate([
    ViewChild('popupTemplate', { static: true }),
    __metadata("design:type", TemplateRef)
], ColorPickerComponent.prototype, "popupTemplate", void 0);
__decorate([
    ViewChild('palette', { read: ElementRef, static: false }),
    __metadata("design:type", ElementRef)
], ColorPickerComponent.prototype, "palette", void 0);
__decorate([
    ViewChild('colorGradient', { static: false }),
    __metadata("design:type", ColorGradientComponent)
], ColorPickerComponent.prototype, "colorGradient", void 0);
ColorPickerComponent = ColorPickerComponent_1 = __decorate([
    __metadata("design:paramtypes", [PopupService,
        ChangeDetectorRef,
        LocalizationService,
        NgZone])
], ColorPickerComponent);

/**
 * @hidden
 */
let ColorPaletteService = class ColorPaletteService {
    /**
     * @hidden
     */
    constructor() {
        this.colorRows = [];
    }
    setColorMatrix(palette, columns) {
        this.colorRows = [];
        if (!(isPresent(palette) && palette.length)) {
            return;
        }
        columns = columns || palette.length;
        for (let start = 0; start < palette.length; start += columns) {
            const row = palette.slice(start, columns + start);
            this.colorRows.push(row);
        }
    }
    getCellCoordsFor(color) {
        if (!isPresent(color)) {
            return;
        }
        for (let row = 0; row < this.colorRows.length; row++) {
            for (let col = 0; col < this.colorRows[row].length; col++) {
                if (this.colorRows[row][col] === color) {
                    return { row, col };
                }
            }
        }
    }
    getColorAt(cellCoords) {
        if (!(isPresent(cellCoords) && isPresent(this.colorRows[cellCoords.row]))) {
            return;
        }
        return this.colorRows[cellCoords.row][cellCoords.col];
    }
    getNextCell(current, horizontalStep, verticalStep) {
        if (!(isPresent(current) && isPresent(current.row) && isPresent(current.col))) {
            return { row: 0, col: 0 };
        }
        const row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);
        const col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);
        return { row, col };
    }
    clampIndex(index, max) {
        const minArrayIndex = 0;
        if (index < minArrayIndex) {
            return minArrayIndex;
        }
        if (index > max) {
            return max;
        }
        return index;
    }
}
ColorPaletteService.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: ColorPaletteService, factory: function ColorPaletteService_Factory(t) { return new (t || ColorPaletteService)(); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ColorPaletteService, [{
        type: Injectable
    }], function () { return []; }, { constructor: [], colorRows: [], setColorMatrix: [], getCellCoordsFor: [], getColorAt: [], getNextCell: [], clampIndex: [] });;

/**
 * @hidden
 */
let ColorPaletteLocalizationService = class ColorPaletteLocalizationService extends LocalizationService {
    constructor(prefix, messageService, _rtl, colorPickerLocalization) {
        super(prefix, messageService, _rtl);
        this.colorPickerLocalization = colorPickerLocalization;
    }
    get(shortKey) {
        if (this.colorPickerLocalization) {
            return this.colorPickerLocalization.get(shortKey);
        }
        return super.get(shortKey);
    }
};
ColorPaletteLocalizationService = __decorate([
    __param(0, Inject(L10N_PREFIX)),
    __param(1, Optional()),
    __param(2, Optional()), __param(2, Inject(RTL)),
    __param(3, Optional()), __param(3, Inject(ColorPickerLocalizationService)),
    __metadata("design:paramtypes", [String, MessageService, Boolean, ColorPickerLocalizationService])
], ColorPaletteLocalizationService);

var ColorPaletteComponent_1;
const DEFAULT_TILE_SIZE = 24;
const DEFAULT_COLUMNS_COUNT = 10;
const DEFAULT_PRESET$1 = 'office';
const DEFAULT_ACCESSIBLE_PRESET$1 = 'accessible';
let serial$2 = 0;
/**
 * The ColorPalette component provides a set of predefined palette presets and enables you to implement a custom color palette.
 * The ColorPalette is independently used by `kendo-colorpicker` and can be directly added to the page.
 */
let ColorPaletteComponent = ColorPaletteComponent_1 = class ColorPaletteComponent {
    constructor(host, service, cdr, renderer, localizationService) {
        this.host = host;
        this.service = service;
        this.cdr = cdr;
        this.renderer = renderer;
        this.localizationService = localizationService;
        /**
         * @hidden
         */
        this.id = `k-colorpalette-${serial$2++}`;
        /**
         * Specifies the output format of the ColorPaletteComponent.
         * The input value may be in a different format. However, it will be parsed into the output `format`
         * after the component processes it.
         *
         * The supported values are:
         * * (Default) `hex`
         * * `rgba`
         * * `name`
         */
        this.format = 'hex';
        /**
         * Sets the disabled state of the ColorPalette.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorPalette.
         */
        this.readonly = false;
        /**
         * Specifies the size of a color cell.
         *
         * The possible values are:
         * * (Default) `tileSize = 24`
         * * `{ width: number, height: number }`
         */
        this.tileSize = { width: DEFAULT_TILE_SIZE, height: DEFAULT_TILE_SIZE };
        /**
         * Fires each time the color selection is changed.
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires each time the value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user selects a cell with the mouse or presses `Enter`.
         *
         * @hidden
         */
        this.cellSelection = new EventEmitter();
        /**
         * @hidden
         */
        this.hostClasses = true;
        this._tabindex = 0;
        this.notifyNgTouched = () => { };
        this.notifyNgChanged = () => { };
        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    /**
     * @hidden
     */
    get paletteId() {
        return this.id;
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor$1(value, this.format);
    }
    get value() {
        return this._value;
    }
    /**
     * Specifies the number of columns that will be displayed.
     * Defaults to `10`.
     */
    set columns(value) {
        const minColumnsCount = 1;
        this._columns = value > minColumnsCount ? value : minColumnsCount;
    }
    get columns() {
        return this._columns;
    }
    /**
     * The color palette that will be displayed.
     *
     * The supported values are:
     * * The name of the predefined palette preset (for example, `office`, `basic`, and `apex`).
     * * A string with comma-separated colors.
     * * A string array.
     */
    set palette(value) {
        if (!isPresent(value)) {
            value = DEFAULT_PRESET$1;
        }
        if (typeof value === 'string' && isPresent(PALETTEPRESETS[value])) {
            this.columns = this.columns || PALETTEPRESETS[value].columns;
            value = PALETTEPRESETS[value].colors;
        }
        const colors = (typeof value === 'string') ? value.split(',') : value;
        this._palette = colors.map(color => parseColor$1(color, this.format, false));
    }
    get palette() {
        return this._palette;
    }
    /**
     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * @hidden
     */
    get tileLayout() {
        if (typeof this.tileSize !== 'number') {
            return this.tileSize;
        }
        return { width: this.tileSize, height: this.tileSize };
    }
    /**
     * @hidden
     */
    get colorRows() {
        return this.service.colorRows;
    }
    /**
     * @hidden
     */
    get hostTabindex() { return this.tabindex; }
    /**
     * @hidden
     */
    get disabledClass() { return this.disabled; }
    /**
     * @hidden
     */
    get readonlyAttribute() { return this.readonly; }
    ngOnInit() {
        if (this.colorRows.length === 0) {
            const defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;
            this.palette = this.palette || defaultPreset;
            this.setRows();
            this.focusedCell = this.service.getCellCoordsFor(this.value);
        }
    }
    ngAfterViewInit() {
        this.setHostElementAriaLabel();
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    ngOnChanges(changes) {
        if (changes.palette || changes.columns) {
            this.setRows();
        }
        if (changes.palette || changes.value || changes.columns) {
            this.focusedCell = this.service.getCellCoordsFor(this.value);
            this.setHostElementAriaLabel();
        }
    }
    /**
     * @hidden
     */
    handleKeydown(event) {
        const isRTL = this.direction === 'rtl';
        switch (event.keyCode) {
            case Keys.ArrowDown:
                this.handleCellNavigation(0, 1);
                break;
            case Keys.ArrowUp:
                this.handleCellNavigation(0, -1);
                break;
            case Keys.ArrowRight:
                this.handleCellNavigation(isRTL ? -1 : 1, 0);
                break;
            case Keys.ArrowLeft:
                this.handleCellNavigation(isRTL ? 1 : -1, 0);
                break;
            case Keys.Enter:
                this.handleEnter();
                break;
            default: return;
        }
        event.preventDefault();
    }
    /**
     * @hidden
     */
    handleHostBlur() {
        this.notifyNgTouched();
        this.handleCellFocusOnBlur();
    }
    /**
     * @hidden
     */
    handleCellSelection(value, cell) {
        if (this.readonly) {
            return;
        }
        this.selectedCell = cell;
        this.focusedCell = this.selectedCell;
        this.focusInComponent = true;
        const parsedColor = parseColor$1(value, this.format, false);
        this.cellSelection.emit(parsedColor);
        if (this.value !== parsedColor) {
            this.value = parsedColor;
            this.valueChange.emit(parsedColor);
            this.notifyNgChanged(parsedColor);
            this.setHostElementAriaLabel();
        }
        if (this.selection !== parsedColor) {
            this.selection = parsedColor;
            this.selectionChange.emit(parsedColor);
        }
        if (cell) {
            this.activeCellId = `${this.selectedCell.row}-${this.selectedCell.col}`;
        }
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        this.focusedCell = this.service.getCellCoordsFor(this.value);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.cdr.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    /**
     * Clears the color value of the ColorPalette.
     */
    reset() {
        this.focusedCell = null;
        if (isPresent(this.value)) {
            this._value = undefined;
            this.notifyNgChanged(undefined);
        }
    }
    handleCellFocusOnBlur() {
        this.focusInComponent = false;
        this.focusedCell = this.selectedCell;
    }
    setRows() {
        if (!isPresent(this.palette)) {
            return;
        }
        this.columns = this.columns || DEFAULT_COLUMNS_COUNT;
        this.service.setColorMatrix(this.palette, this.columns);
    }
    handleCellNavigation(horizontalStep, verticalStep) {
        if (this.readonly) {
            return;
        }
        this.focusedCell = this.service.getNextCell(this.focusedCell, horizontalStep, verticalStep);
        this.focusInComponent = true;
    }
    setHostElementAriaLabel() {
        const parsed = parseColor$1(this.value, this.format);
        this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorPaletteNoColor')}`);
    }
    handleEnter() {
        if (!isPresent(this.focusedCell)) {
            return;
        }
        const selectedColor = this.service.getColorAt(this.focusedCell);
        this.handleCellSelection(selectedColor, this.focusedCell);
    }
}
ColorPaletteComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: ColorPaletteComponent, selectors: [["kendo-colorpalette"]], factory: function ColorPaletteComponent_Factory(t) { return new (t || ColorPaletteComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(ColorPaletteService), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, hostBindings: function ColorPaletteComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(7);
        ɵngcc0.ɵɵlistener("keydown", function ColorPaletteComponent_keydown_HostBindingHandler($event) { return ctx.handleKeydown($event); });
        ɵngcc0.ɵɵlistener("blur", function ColorPaletteComponent_blur_HostBindingHandler($event) { return ctx.handleHostBlur(); });
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction)("id", ctx.paletteId)("tabindex", ctx.hostTabindex)("aria-disabled", ctx.disabledClass)("aria-readonly", ctx.readonlyAttribute);
        ɵngcc0.ɵɵclassProp("k-colorpalette", ctx.hostClasses);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabledClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { id: "id", format: "format", disabled: "disabled", readonly: "readonly", tileSize: "tileSize", value: "value", columns: "columns", palette: "palette", tabindex: "tabindex" }, outputs: { selectionChange: "selectionChange", valueChange: "valueChange", cellSelection: "cellSelection" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorPaletteComponent_1) // tslint:disable-line:no-forward-ref
            }, {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorPaletteComponent_1)
            },
            ColorPaletteService,
            ColorPaletteLocalizationService,
            {
                provide: LocalizationService,
                useExisting: ColorPaletteLocalizationService
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorpalette'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], consts: 6, vars: 2, template: function ColorPaletteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, _c225);
        ɵngcc0.ɵɵi18nAttributes(1, _c228);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "div", _c229);
        ɵngcc0.ɵɵelementStart(3, "table", _c230);
        ɵngcc0.ɵɵelementStart(4, "tbody");
        ɵngcc0.ɵɵtemplate(5, ColorPaletteComponent_tr_5_Template, 2, 1, "tr", _c231);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeCellId);
        ɵngcc0.ɵɵselect(5);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.colorRows);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ColorPaletteComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-colorpalette',
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ColorPaletteComponent_1) // tslint:disable-line:no-forward-ref
                    }, {
                        provide: KendoInput,
                        useExisting: forwardRef(() => ColorPaletteComponent_1)
                    },
                    ColorPaletteService,
                    ColorPaletteLocalizationService,
                    {
                        provide: LocalizationService,
                        useExisting: ColorPaletteLocalizationService
                    },
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.colorpalette'
                    }
                ],
                template: `
        <ng-container kendoColorPaletteLocalizedMessages
            i18n-colorPaletteNoColor="kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen">
        </ng-container>
        <div role="listbox" class="k-colorpalette-table-wrap"
            [attr.aria-activedescendant]="activeCellId">
            <table class="k-colorpalette-table k-palette">
                <tbody>
                    <tr *ngFor="let row of colorRows; let rowIndex = index">
                        <td *ngFor="let color of row; let colIndex = index"
                            role="option"
                            [class.k-state-selected]="selectedCell?.row === rowIndex && selectedCell?.col === colIndex"
                            [class.k-state-focus]="focusInComponent && focusedCell?.row === rowIndex && focusedCell?.col === colIndex"
                            [attr.aria-selected]="selectedCell?.row === rowIndex && selectedCell?.col === colIndex"
                            [attr.aria-label]="color"
                            class="k-colorpalette-tile"
                            [id]="rowIndex + '-' + colIndex"
                            [attr.value]="color"
                            (click)="handleCellSelection(color, { row: rowIndex, col: colIndex })"
                            [ngStyle]="{
                                backgroundColor: color,
                                width: tileLayout.width + 'px',
                                height: tileLayout.height + 'px',
                                minWidth: tileLayout.width + 'px'
                            }">
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    `
            }]
    }], function () { return [{ type: ElementRef }, { type: ColorPaletteService }, { type: ChangeDetectorRef }, { type: Renderer2 }, { type: LocalizationService }]; }, { constructor: [], host: [], service: [], cdr: [], renderer: [], localizationService: [], id: [{
            type: Input
        }], format: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], tileSize: [{
            type: Input
        }], selectionChange: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], cellSelection: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-colorpalette']
        }], _tabindex: [], notifyNgTouched: [], notifyNgChanged: [], dynamicRTLSubscription: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], paletteId: [{
            type: HostBinding,
            args: ['attr.id']
        }], value: [{
            type: Input
        }], value: [], _value: [], columns: [{
            type: Input
        }], columns: [], _columns: [], palette: [{
            type: Input
        }], palette: [], _palette: [], tabindex: [{
            type: Input
        }], tabindex: [], tileLayout: [], colorRows: [], hostTabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], disabledClass: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], readonlyAttribute: [{
            type: HostBinding,
            args: ['attr.aria-readonly']
        }], ngOnInit: [], focusedCell: [], ngAfterViewInit: [], ngOnDestroy: [], ngOnChanges: [], handleKeydown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], handleHostBlur: [{
            type: HostListener,
            args: ['blur']
        }], handleCellSelection: [], selectedCell: [], focusInComponent: [], selection: [], activeCellId: [], writeValue: [], registerOnChange: [], registerOnTouched: [], setDisabledState: [], isEmpty: [], reset: [], handleCellFocusOnBlur: [], setRows: [], handleCellNavigation: [], setHostElementAriaLabel: [], handleEnter: [] });;
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], ColorPaletteComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('attr.id'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "paletteId", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPaletteComponent.prototype, "id", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPaletteComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ColorPaletteComponent.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], ColorPaletteComponent.prototype, "columns", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ColorPaletteComponent.prototype, "palette", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], ColorPaletteComponent.prototype, "tabindex", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorPaletteComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColorPaletteComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColorPaletteComponent.prototype, "tileSize", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPaletteComponent.prototype, "selectionChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPaletteComponent.prototype, "valueChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ColorPaletteComponent.prototype, "cellSelection", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "hostTabindex", null);
__decorate([
    HostBinding('class.k-colorpalette'),
    __metadata("design:type", Boolean)
], ColorPaletteComponent.prototype, "hostClasses", void 0);
__decorate([
    HostBinding('attr.aria-disabled'),
    HostBinding('class.k-state-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "disabledClass", null);
__decorate([
    HostBinding('attr.aria-readonly'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "readonlyAttribute", null);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], ColorPaletteComponent.prototype, "handleKeydown", null);
__decorate([
    HostListener('blur'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ColorPaletteComponent.prototype, "handleHostBlur", null);
ColorPaletteComponent = ColorPaletteComponent_1 = __decorate([
    __metadata("design:paramtypes", [ElementRef,
        ColorPaletteService,
        ChangeDetectorRef,
        Renderer2,
        LocalizationService])
], ColorPaletteComponent);

/**
 * @hidden
 */
class ColorPickerMessages extends ComponentMessages {
}
ColorPickerMessages.ngBaseDef = ɵngcc0.ɵɵdefineBase({ inputs: { colorPaletteNoColor: "colorPaletteNoColor", colorGradientNoColor: "colorGradientNoColor", colorGradientHandle: "colorGradientHandle", clearButton: "clearButton", hueSliderHandle: "hueSliderHandle", opacitySliderHandle: "opacitySliderHandle", hexInputPlaceholder: "hexInputPlaceholder", redInputPlaceholder: "redInputPlaceholder", greenInputPlaceholder: "greenInputPlaceholder", blueInputPlaceholder: "blueInputPlaceholder", alphaInputPlaceholder: "alphaInputPlaceholder", passContrast: "passContrast", failContrast: "failContrast", contrastRatio: "contrastRatio" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "colorPaletteNoColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "colorGradientNoColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "colorGradientHandle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "clearButton", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "hueSliderHandle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "opacitySliderHandle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "hexInputPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "redInputPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "greenInputPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "blueInputPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "alphaInputPlaceholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "passContrast", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "failContrast", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorPickerMessages.prototype, "contrastRatio", void 0);

var ColorPickerCustomMessagesComponent_1;
/**
 * Custom component messages override default component messages.
 */
let ColorPickerCustomMessagesComponent = ColorPickerCustomMessagesComponent_1 = class ColorPickerCustomMessagesComponent extends ColorPickerMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
ColorPickerCustomMessagesComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: ColorPickerCustomMessagesComponent, selectors: [["kendo-colorpicker-messages"], ["kendo-colorgradient-messages"], ["kendo-colorpalette-messages"]], factory: function ColorPickerCustomMessagesComponent_Factory(t) { return new (t || ColorPickerCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColorPickerMessages,
                useExisting: forwardRef(() => ColorPickerCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], consts: 0, vars: 0, template: function ColorPickerCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ColorPickerCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColorPickerMessages,
                        useExisting: forwardRef(() => ColorPickerCustomMessagesComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-colorpicker-messages, kendo-colorgradient-messages, kendo-colorpalette-messages',
                template: ``
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], service: [], override: [] });;
ColorPickerCustomMessagesComponent = ColorPickerCustomMessagesComponent_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], ColorPickerCustomMessagesComponent);

var LocalizedColorPickerMessagesDirective_1;
/**
 * @hidden
 */
let LocalizedColorPickerMessagesDirective = LocalizedColorPickerMessagesDirective_1 = class LocalizedColorPickerMessagesDirective extends ColorPickerMessages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedColorPickerMessagesDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: LocalizedColorPickerMessagesDirective, selectors: [["", "kendoColorPickerLocalizedMessages", ""], ["", "kendoColorGradientLocalizedMessages", ""], ["", "kendoColorPaletteLocalizedMessages", ""]], factory: function LocalizedColorPickerMessagesDirective_Factory(t) { return new (t || LocalizedColorPickerMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColorPickerMessages,
                useExisting: forwardRef(() => LocalizedColorPickerMessagesDirective_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(LocalizedColorPickerMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: ColorPickerMessages,
                        useExisting: forwardRef(() => LocalizedColorPickerMessagesDirective_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoColorPickerLocalizedMessages], [kendoColorGradientLocalizedMessages], [kendoColorPaletteLocalizedMessages]'
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], service: [] });;
LocalizedColorPickerMessagesDirective = LocalizedColorPickerMessagesDirective_1 = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], LocalizedColorPickerMessagesDirective);

/**
 * @hidden
 */
let FocusOnDomReadyDirective = class FocusOnDomReadyDirective {
    constructor(host, ngZone) {
        this.host = host;
        this.ngZone = ngZone;
    }
    ngAfterContentInit() {
        this.focusOnNextTick();
    }
    focusOnNextTick() {
        this.ngZone.runOutsideAngular(() => setTimeout(() => this.host.nativeElement.focus()));
    }
}
FocusOnDomReadyDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: FocusOnDomReadyDirective, selectors: [["", "kendoFocusOnDomReady", ""]], factory: function FocusOnDomReadyDirective_Factory(t) { return new (t || FocusOnDomReadyDirective)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(NgZone)); } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(FocusOnDomReadyDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoFocusOnDomReady]'
            }]
    }], function () { return [{ type: ElementRef }, { type: NgZone }]; }, { constructor: [], host: [], ngZone: [], ngAfterContentInit: [], focusOnNextTick: [] });;
FocusOnDomReadyDirective = __decorate([
    __metadata("design:paramtypes", [ElementRef,
        NgZone])
], FocusOnDomReadyDirective);

/**
 * @hidden
 */
let ContrastValidationComponent = class ContrastValidationComponent {
    constructor(localization) {
        this.localization = localization;
    }
    get passMessage() {
        return this.localization.get('passContrast');
    }
    get failMessage() {
        return this.localization.get('failContrast');
    }
    get contrastText() {
        return `${this.type}: ${this.ratio.toFixed(1)}`;
    }
}
ContrastValidationComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: ContrastValidationComponent, selectors: [["", "kendoContrastValidation", ""]], factory: function ContrastValidationComponent_Factory(t) { return new (t || ContrastValidationComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, inputs: { type: "type", ratio: "ratio", pass: "pass" }, attrs: _c235, consts: 4, vars: 3, template: function ContrastValidationComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, ContrastValidationComponent_span_2_Template, 3, 1, "span", _c236);
        ɵngcc0.ɵɵtemplate(3, ContrastValidationComponent_span_3_Template, 3, 1, "span", _c237);
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.contrastText);
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pass);
        ɵngcc0.ɵɵselect(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.pass);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ContrastValidationComponent, [{
        type: Component,
        args: [{
                selector: '[kendoContrastValidation]',
                template: `
        <span>{{contrastText}}</span>
                <span class="k-contrast-validation k-text-success" *ngIf="pass">
                    {{passMessage}}
                    <span class="k-icon k-i-check"></span>
                </span>
                <span class="k-contrast-validation k-text-error" *ngIf="!pass">
                    {{failMessage}}
                <span class="k-icon k-i-close"></span>
        </span>
    `
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], localization: [], passMessage: [], failMessage: [], contrastText: [], type: [{
            type: Input
        }], ratio: [{
            type: Input
        }], pass: [{
            type: Input
        }] });;
__decorate([
    Input(),
    __metadata("design:type", String)
], ContrastValidationComponent.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ContrastValidationComponent.prototype, "ratio", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ContrastValidationComponent.prototype, "pass", void 0);
ContrastValidationComponent = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], ContrastValidationComponent);

/**
 * @hidden
 */
let ContrastComponent = class ContrastComponent {
    constructor(localization) {
        this.localization = localization;
        this.aaRatio = AA_RATIO;
        this.aaaRatio = AAA_RATIO;
    }
    get formatedRatio() {
        return this.contrastRatio.toFixed(2);
    }
    get contrastRatioMessage() {
        return this.localization.get('contrastRatio');
    }
    get satisfiesAACondition() {
        return this.contrastRatio >= this.aaRatio;
    }
    get satisfiesAAACondition() {
        return this.contrastRatio >= this.aaaRatio;
    }
    get contrastRatio() {
        let contrast = getContrastFromTwoRGBAs(getRGBA(this.value), getRGBA(this.ratio));
        return contrast;
    }
}
ContrastComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: ContrastComponent, selectors: [["", "kendoContrastTool", ""]], factory: function ContrastComponent_Factory(t) { return new (t || ContrastComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService)); }, inputs: { value: "value", ratio: "ratio" }, attrs: _c242, consts: 7, vars: 8, template: function ContrastComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", _c243);
        ɵngcc0.ɵɵelementStart(1, "span", _c244);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ContrastComponent_span_3_Template, 3, 1, "span", _c236);
        ɵngcc0.ɵɵtemplate(4, ContrastComponent_span_4_Template, 2, 0, "span", _c237);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(5, "div", _c245);
        ɵngcc0.ɵɵelement(6, "div", _c246);
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵtextInterpolate2("", ctx.contrastRatioMessage, ": ", ctx.formatedRatio, "");
        ɵngcc0.ɵɵselect(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.satisfiesAACondition);
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.satisfiesAACondition);
        ɵngcc0.ɵɵselect(5);
        ɵngcc0.ɵɵproperty("ratio", ctx.aaaRatio)("pass", ctx.satisfiesAACondition);
        ɵngcc0.ɵɵselect(6);
        ɵngcc0.ɵɵproperty("ratio", ctx.aaaRatio)("pass", ctx.satisfiesAAACondition);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ContrastComponent, [{
        type: Component,
        args: [{
                selector: '[kendoContrastTool]',
                template: `
        <div class="k-contrast-ratio">
            <span class="k-contrast-ratio-text">{{contrastRatioMessage}}: {{formatedRatio}}</span>
            <span class="k-contrast-validation k-text-success" *ngIf="satisfiesAACondition">
                <span class="k-icon k-i-check"></span>
                <span class="k-icon k-i-check" *ngIf="satisfiesAAACondition"></span>
            </span>
            <span class="k-contrast-validation k-text-error" *ngIf="!satisfiesAACondition">
                <span class="k-icon k-i-close"></span>
            </span>
        </div>
        <div kendoContrastValidation
            type="AA"
            [ratio]="aaaRatio"
            [pass]="satisfiesAACondition">
        </div>
        <div kendoContrastValidation
            type="AAA"
            [ratio]="aaaRatio"
            [pass]="satisfiesAAACondition">
        </div>
    `
            }]
    }], function () { return [{ type: LocalizationService }]; }, { constructor: [], localization: [], aaRatio: [], aaaRatio: [], formatedRatio: [], contrastRatioMessage: [], satisfiesAACondition: [], satisfiesAAACondition: [], contrastRatio: [], value: [{
            type: Input
        }], ratio: [{
            type: Input
        }] });;
__decorate([
    Input(),
    __metadata("design:type", String)
], ContrastComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ContrastComponent.prototype, "ratio", void 0);
ContrastComponent = __decorate([
    __metadata("design:paramtypes", [LocalizationService])
], ContrastComponent);

const PUBLIC_DIRECTIVES = [
    ColorPickerComponent,
    ColorPaletteComponent,
    ColorGradientComponent,
    LocalizedColorPickerMessagesDirective,
    ColorPickerCustomMessagesComponent
];
const INTERNAL_DIRECTIVES = [
    ColorInputComponent,
    FocusOnDomReadyDirective,
    ContrastComponent,
    ContrastValidationComponent
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the ColorPicker.
 */
let ColorPickerModule = class ColorPickerModule {
}
ColorPickerModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: ColorPickerModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(ColorPickerModule, { declarations: function () { return [ColorPickerComponent,
        ColorPaletteComponent,
        ColorGradientComponent,
        LocalizedColorPickerMessagesDirective,
        ColorPickerCustomMessagesComponent,
        ColorInputComponent,
        FocusOnDomReadyDirective,
        ContrastComponent,
        ContrastValidationComponent]; }, imports: function () { return [SliderModule,
        NumericTextBoxModule,
        CommonModule,
        PopupModule,
        DraggableModule]; }, exports: function () { return [ColorPickerComponent,
        ColorPaletteComponent,
        ColorGradientComponent,
        LocalizedColorPickerMessagesDirective,
        ColorPickerCustomMessagesComponent]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ColorPickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    PUBLIC_DIRECTIVES,
                    INTERNAL_DIRECTIVES
                ],
                exports: [PUBLIC_DIRECTIVES],
                imports: [
                    SliderModule,
                    NumericTextBoxModule,
                    CommonModule,
                    PopupModule,
                    DraggableModule
                ]
            }]
    }], null, null);
ColorPickerModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function ColorPickerModule_Factory(t) { return new (t || ColorPickerModule)(); }, imports: [[
            SliderModule,
            NumericTextBoxModule,
            CommonModule,
            PopupModule,
            DraggableModule
        ]] });;

/**
 * Represents the directive that renders the [Kendo UI CheckBox]({% slug overview_checkbox %}) input component.
 * The directive is placed on input type="checkbox" elements.
 *
 * @example
 * ```ts-no-run
 * <input type="checkbox" kendoCheckBox />
 * ```
 */
let CheckBoxDirective = class CheckBoxDirective {
    /**
     * Represents the directive that renders the [Kendo UI CheckBox]({% slug overview_checkbox %}) input component.
     * The directive is placed on input type="checkbox" elements.
     *
     * @example
     * ```ts-no-run
     * <input type="checkbox" kendoCheckBox />
     * ```
     */
    constructor() {
        this.kendoClass = true;
    }
}
CheckBoxDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: CheckBoxDirective, selectors: [["input", "kendoCheckBox", ""]], factory: function CheckBoxDirective_Factory(t) { return new (t || CheckBoxDirective)(); }, hostBindings: function CheckBoxDirective_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-checkbox", ctx.kendoClass);
        ɵngcc0.ɵɵstylingApply();
    } } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(CheckBoxDirective, [{
        type: Directive,
        args: [{
                selector: 'input[kendoCheckBox]'
            }]
    }], function () { return []; }, { constructor: [], kendoClass: [{
            type: HostBinding,
            args: ['class.k-checkbox']
        }] });;
__decorate([
    HostBinding('class.k-checkbox'),
    __metadata("design:type", Boolean)
], CheckBoxDirective.prototype, "kendoClass", void 0);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the CheckBox directive.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the CheckBox module
 * import { CheckBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, CheckBoxModule], // import CheckBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let CheckBoxModule = class CheckBoxModule {
}
CheckBoxModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: CheckBoxModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(CheckBoxModule, { declarations: function () { return [CheckBoxDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [CheckBoxDirective]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(CheckBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [CheckBoxDirective],
                exports: [CheckBoxDirective],
                imports: [CommonModule]
            }]
    }], null, null);
CheckBoxModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function CheckBoxModule_Factory(t) { return new (t || CheckBoxModule)(); }, imports: [[CommonModule]] });;

/**
 * Represents the directive that renders the [Kendo UI RadioButton]({% slug overview_checkbox %}) input component.
 * The directive is placed on input type="radio" elements.
 *
 * @example
 * ```ts-no-run
 * <input type="radio" kendoRadioButton />
 * ```
 */
let RadioButtonDirective = class RadioButtonDirective {
    /**
     * Represents the directive that renders the [Kendo UI RadioButton]({% slug overview_checkbox %}) input component.
     * The directive is placed on input type="radio" elements.
     *
     * @example
     * ```ts-no-run
     * <input type="radio" kendoRadioButton />
     * ```
     */
    constructor() {
        this.kendoClass = true;
    }
}
RadioButtonDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: RadioButtonDirective, selectors: [["input", "kendoRadioButton", ""]], factory: function RadioButtonDirective_Factory(t) { return new (t || RadioButtonDirective)(); }, hostBindings: function RadioButtonDirective_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(1);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-radio", ctx.kendoClass);
        ɵngcc0.ɵɵstylingApply();
    } } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(RadioButtonDirective, [{
        type: Directive,
        args: [{
                selector: 'input[kendoRadioButton]'
            }]
    }], function () { return []; }, { constructor: [], kendoClass: [{
            type: HostBinding,
            args: ['class.k-radio']
        }] });;
__decorate([
    HostBinding('class.k-radio'),
    __metadata("design:type", Boolean)
], RadioButtonDirective.prototype, "kendoClass", void 0);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the RadioButton directive.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the RadioButton module
 * import { RadioButtonModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, RadioButtonModule], // import RadioButton module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let RadioButtonModule = class RadioButtonModule {
}
RadioButtonModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: RadioButtonModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(RadioButtonModule, { declarations: function () { return [RadioButtonDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [RadioButtonDirective]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(RadioButtonModule, [{
        type: NgModule,
        args: [{
                declarations: [RadioButtonDirective],
                exports: [RadioButtonDirective],
                imports: [CommonModule]
            }]
    }], null, null);
RadioButtonModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function RadioButtonModule_Factory(t) { return new (t || RadioButtonModule)(); }, imports: [[CommonModule]] });;

let serial$3 = 0;
/**
 * Represents an error message that will be shown underneath
 * a Kendo control or native HTML form-bound component after a validation.
 */
let ErrorComponent = class ErrorComponent {
    /**
     * Represents an error message that will be shown underneath
     * a Kendo control or native HTML form-bound component after a validation.
     */
    constructor() {
        this.hostClass = true;
        /**
         * Specifies the alignment of the Error message.
         *
         * The possible values are:
         * * (Default) `start`
         * * `end`
         */
        this.align = 'start';
        /**
         * @hidden
         */
        this.id = `kendo-error-${serial$3++}`;
        this.roleAttribute = 'alert';
    }
    get startClass() {
        return this.align === 'start';
    }
    get endClass() {
        return this.align === 'end';
    }
    get idAttribute() {
        return this.id;
    }
}
ErrorComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: ErrorComponent, selectors: [["kendo-formerror"]], factory: function ErrorComponent_Factory(t) { return new (t || ErrorComponent)(); }, hostBindings: function ErrorComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(5);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.roleAttribute)("id", ctx.idAttribute);
        ɵngcc0.ɵɵclassProp("k-form-error", ctx.hostClass);
        ɵngcc0.ɵɵclassProp("k-text-start", ctx.startClass);
        ɵngcc0.ɵɵclassProp("k-text-end", ctx.endClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { align: "align" }, ngContentSelectors: _c61, consts: 1, vars: 0, template: function ErrorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(ErrorComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-formerror',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { constructor: [], hostClass: [{
            type: HostBinding,
            args: ['class.k-form-error']
        }], align: [{
            type: Input
        }], id: [], roleAttribute: [{
            type: HostBinding,
            args: ['attr.role']
        }], startClass: [{
            type: HostBinding,
            args: ['class.k-text-start']
        }], endClass: [{
            type: HostBinding,
            args: ['class.k-text-end']
        }], idAttribute: [{
            type: HostBinding,
            args: ['attr.id']
        }] });;
__decorate([
    HostBinding('class.k-form-error'),
    __metadata("design:type", Boolean)
], ErrorComponent.prototype, "hostClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ErrorComponent.prototype, "align", void 0);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", String)
], ErrorComponent.prototype, "roleAttribute", void 0);
__decorate([
    HostBinding('class.k-text-start'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ErrorComponent.prototype, "startClass", null);
__decorate([
    HostBinding('class.k-text-end'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ErrorComponent.prototype, "endClass", null);
__decorate([
    HostBinding('attr.id'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], ErrorComponent.prototype, "idAttribute", null);

let serial$4 = 0;
/**
 * Represents a hint message that will be shown underneath a form-bound component.
 */
let HintComponent = class HintComponent {
    /**
     * Represents a hint message that will be shown underneath a form-bound component.
     */
    constructor() {
        /**
         * Specifies the alignment of the Hint message.
         *
         * The possible values are:
         * * (Default) `start`
         * * `end`
         */
        this.align = 'start';
        /**
         * @hidden
         */
        this.id = `kendo-hint-${serial$4++}`;
        this.hostClass = true;
    }
    get startClass() {
        return this.align === 'start';
    }
    get endClass() {
        return this.align === 'end';
    }
    get idAttribute() {
        return this.id;
    }
}
HintComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: HintComponent, selectors: [["kendo-formhint"]], factory: function HintComponent_Factory(t) { return new (t || HintComponent)(); }, hostBindings: function HintComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(4);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.idAttribute);
        ɵngcc0.ɵɵclassProp("k-form-hint", ctx.hostClass);
        ɵngcc0.ɵɵclassProp("k-text-start", ctx.startClass);
        ɵngcc0.ɵɵclassProp("k-text-end", ctx.endClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { align: "align" }, ngContentSelectors: _c61, consts: 1, vars: 0, template: function HintComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(HintComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-formhint',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { constructor: [], align: [{
            type: Input
        }], id: [], hostClass: [{
            type: HostBinding,
            args: ['class.k-form-hint']
        }], startClass: [{
            type: HostBinding,
            args: ['class.k-text-start']
        }], endClass: [{
            type: HostBinding,
            args: ['class.k-text-end']
        }], idAttribute: [{
            type: HostBinding,
            args: ['attr.id']
        }] });;
__decorate([
    Input(),
    __metadata("design:type", String)
], HintComponent.prototype, "align", void 0);
__decorate([
    HostBinding('class.k-form-hint'),
    __metadata("design:type", Boolean)
], HintComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('class.k-text-start'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], HintComponent.prototype, "startClass", null);
__decorate([
    HostBinding('class.k-text-end'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], HintComponent.prototype, "endClass", null);
__decorate([
    HostBinding('attr.id'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], HintComponent.prototype, "idAttribute", null);

/**
 * Specifies a container for form-bound controls (Kendo controls or native HTML controls).
 * Applies styling and behavior rules.
 */
let FormFieldComponent = class FormFieldComponent {
    constructor(renderer, localizationService, hostElement) {
        this.renderer = renderer;
        this.localizationService = localizationService;
        this.hostElement = hostElement;
        this.hostClass = true;
        /**
         *
         * Specifies when the Hint messages will be shown.
         *
         * The possible values are:
         *
         * * (Default) `initial`&mdash;Allows displaying hints when the form-bound component state is
         * `valid` or `untouched` and `pristine`.
         * * `always`&mdash;Allows full control over the visibility of the hints.
         *
         */
        this.showHints = 'initial';
        /**
         * Specifies the layout orientation of the form field.
         *
         * * The possible values are:
         *
         * * (Default) `vertical`
         * * `horizontal`
         */
        this.orientation = 'vertical';
        /**
         * Specifies when the Error messages will be shown.
         *
         * The possible values are:
         *
         * * (Default) `initial`&mdash;Allows displaying errors when the form-bound component state is
         * `invalid` and `touched` or `dirty`.
         * * `always`&mdash;Allows full control over the visibility of the errors.
         *
         */
        this.showErrors = 'initial';
        this.subscriptions = new Subscription();
        this.rtl = false;
        validatePackage(packageMetadata);
        this.subscriptions.add(this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        }));
    }
    get errorClass() {
        if (!this.control) {
            return false;
        }
        return this.control.invalid && (this.control.touched || this.control.dirty);
    }
    get disabledClass() {
        if (!this.control) {
            return false;
        }
        // radiobutton group
        if (this.isRadioControl(this.control)) {
            return false;
        }
        return this.disabledControl() ||
            this.disabledElement() ||
            this.disabledKendoInput();
    }
    set formControls(formControls) {
        this.validateFormControl(formControls);
        this.control = formControls.first;
    }
    /**
     * @hidden
     */
    get horizontal() {
        return this.orientation === 'horizontal';
    }
    /**
     * @hidden
     */
    get hasHints() {
        return this.showHints === 'always' ? true : this.showHintsInitial();
    }
    /**
     * @hidden
     */
    get hasErrors() {
        return this.showErrors === 'always' ? true : this.showErrorsInitial();
    }
    ngAfterViewInit() {
        this.setDescription();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    disabledKendoInput() {
        return this.kendoInput && this.kendoInput.disabled;
    }
    disabledControl() {
        return this.control.disabled;
    }
    disabledElement() {
        const elements = this.controlElementRefs.toArray();
        return elements.every(e => e.nativeElement.hasAttribute('disabled'));
    }
    validateFormControl(formControls) {
        if (isDevMode() && formControls.length !== 1 && !this.isControlGroup(formControls)) {
            throw new Error('The `kendo-formfield` component should contain ' +
                'only one control of type NgControl with a formControlName(https://angular.io/api/forms/FormControlName)' +
                'or an ngModel(https://angular.io/api/forms/NgModel) binding.');
        }
    }
    isControlGroup(formControls) {
        if (!formControls.length) {
            return false;
        }
        const name = formControls.first.name;
        return formControls.toArray().every(c => c.name === name && (this.isRadioControl(c)));
    }
    isRadioControl(control) {
        return control.valueAccessor instanceof RadioControlValueAccessor;
    }
    updateDescription() {
        const controls = this.findControlElements();
        if (!controls) {
            return;
        }
        controls.forEach((control) => {
            if (this.errorChildren.length > 0 || this.hintChildren.length > 0) {
                const ariaIds = this.generateDescriptionIds(control);
                this.renderer.setAttribute(control, 'aria-describedby', ariaIds);
            }
        });
    }
    findControlElements() {
        if (!this.controlElementRefs) {
            return;
        }
        // if the control is KendoInput and has focusableId - dropdowns, dateinputs
        if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {
            return [this.hostElement.nativeElement.querySelector(`#${this.kendoInput.focusableId}`)];
        }
        return this.controlElementRefs.map(el => el.nativeElement);
    }
    generateDescriptionIds(control) {
        const ids = new Set();
        if (control.hasAttribute('aria-describedby')) {
            const attributes = control.getAttribute('aria-describedby').split(' ');
            attributes.forEach((attr) => {
                if (attr.includes('kendo-hint-') || attr.includes('kendo-error-')) {
                    return;
                }
                ids.add(attr);
            });
        }
        this.hintChildren.forEach((hint) => {
            ids.add(hint.id);
        });
        this.errorChildren.forEach((error) => {
            ids.add(error.id);
        });
        return Array.from(ids).join(' ');
    }
    showHintsInitial() {
        if (!this.control) {
            return true;
        }
        const { valid, untouched, pristine } = this.control;
        return valid || (untouched && pristine);
    }
    showErrorsInitial() {
        if (!this.control) {
            return false;
        }
        const { invalid, dirty, touched } = this.control;
        return invalid && (dirty || touched);
    }
    setDescription() {
        this.updateDescription();
        this.subscriptions.add(this.errorChildren.changes.subscribe(() => this.updateDescription()));
        this.subscriptions.add(this.hintChildren.changes.subscribe(() => this.updateDescription()));
    }
}
FormFieldComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: FormFieldComponent, selectors: [["kendo-formfield"]], factory: function FormFieldComponent_Factory(t) { return new (t || FormFieldComponent)(ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, contentQueries: function FormFieldComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, KendoInput, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgControl, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgControl, true, ElementRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ErrorComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, HintComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.kendoInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.formControls = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.controlElementRefs = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.errorChildren = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.hintChildren = _t);
    } }, hostBindings: function FormFieldComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(4);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-form-field", ctx.hostClass);
        ɵngcc0.ɵɵclassProp("k-form-field-error", ctx.errorClass);
        ɵngcc0.ɵɵclassProp("k-form-field-disabled", ctx.disabledClass);
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { showHints: "showHints", orientation: "orientation", showErrors: "showErrors" }, features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.formfield'
            }
        ])], ngContentSelectors: _c249, consts: 5, vars: 3, template: function FormFieldComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c248);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "div");
        ɵngcc0.ɵɵstyling();
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵtemplate(3, FormFieldComponent_3_Template, 1, 0, undefined, _c104);
        ɵngcc0.ɵɵtemplate(4, FormFieldComponent_4_Template, 1, 0, undefined, _c104);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(1);
        ɵngcc0.ɵɵclassProp("k-form-field-wrap", ctx.horizontal);
        ɵngcc0.ɵɵstylingApply();
        ɵngcc0.ɵɵselect(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasHints);
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasErrors);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(FormFieldComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-formfield',
                template: `
        <ng-content select="label, kendo-label"></ng-content>
        <div [class.k-form-field-wrap]="horizontal">
            <ng-content></ng-content>
            <ng-content select="kendo-formhint" *ngIf="hasHints"></ng-content>
            <ng-content select="kendo-formerror" *ngIf="hasErrors"></ng-content>
        </div>
    `,
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.formfield'
                    }
                ]
            }]
    }], function () { return [{ type: Renderer2 }, { type: LocalizationService }, { type: ElementRef }]; }, { constructor: [], renderer: [], localizationService: [], hostElement: [], hostClass: [{
            type: HostBinding,
            args: ['class.k-form-field']
        }], showHints: [{
            type: Input
        }], orientation: [{
            type: Input
        }], showErrors: [{
            type: Input
        }], subscriptions: [], rtl: [], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], errorClass: [{
            type: HostBinding,
            args: ['class.k-form-field-error']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-form-field-disabled']
        }], formControls: [{
            type: ContentChildren,
            args: [NgControl, { descendants: true }]
        }], control: [], horizontal: [], hasHints: [], hasErrors: [], ngAfterViewInit: [], ngOnDestroy: [], disabledKendoInput: [], disabledControl: [], disabledElement: [], validateFormControl: [], isControlGroup: [], isRadioControl: [], updateDescription: [], findControlElements: [], generateDescriptionIds: [], showHintsInitial: [], showErrorsInitial: [], setDescription: [], controlElementRefs: [{
            type: ContentChildren,
            args: [NgControl, { read: ElementRef, descendants: true }]
        }], kendoInput: [{
            type: ContentChild,
            args: [KendoInput, { static: true }]
        }], errorChildren: [{
            type: ContentChildren,
            args: [ErrorComponent, { descendants: true }]
        }], hintChildren: [{
            type: ContentChildren,
            args: [HintComponent, { descendants: true }]
        }] });;
__decorate([
    HostBinding('class.k-form-field'),
    __metadata("design:type", Boolean)
], FormFieldComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('attr.dir'),
    __metadata("design:type", String)
], FormFieldComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('class.k-form-field-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], FormFieldComponent.prototype, "errorClass", null);
__decorate([
    HostBinding('class.k-form-field-disabled'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], FormFieldComponent.prototype, "disabledClass", null);
__decorate([
    ContentChildren(NgControl, { descendants: true }),
    __metadata("design:type", QueryList),
    __metadata("design:paramtypes", [QueryList])
], FormFieldComponent.prototype, "formControls", null);
__decorate([
    ContentChildren(NgControl, { read: ElementRef, descendants: true }),
    __metadata("design:type", QueryList)
], FormFieldComponent.prototype, "controlElementRefs", void 0);
__decorate([
    ContentChild(KendoInput, { static: true }),
    __metadata("design:type", Object)
], FormFieldComponent.prototype, "kendoInput", void 0);
__decorate([
    ContentChildren(ErrorComponent, { descendants: true }),
    __metadata("design:type", QueryList)
], FormFieldComponent.prototype, "errorChildren", void 0);
__decorate([
    ContentChildren(HintComponent, { descendants: true }),
    __metadata("design:type", QueryList)
], FormFieldComponent.prototype, "hintChildren", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormFieldComponent.prototype, "showHints", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormFieldComponent.prototype, "orientation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormFieldComponent.prototype, "showErrors", void 0);
FormFieldComponent = __decorate([
    __metadata("design:paramtypes", [Renderer2,
        LocalizationService,
        ElementRef])
], FormFieldComponent);

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the FormField, Error and Hint components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the FormField module
 * import { FormFieldModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, FormFieldModule], // import FormField module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let FormFieldModule = class FormFieldModule {
}
FormFieldModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: FormFieldModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(FormFieldModule, { declarations: function () { return [HintComponent,
        ErrorComponent,
        FormFieldComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [HintComponent,
        ErrorComponent,
        FormFieldComponent]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(FormFieldModule, [{
        type: NgModule,
        args: [{
                declarations: [HintComponent, ErrorComponent, FormFieldComponent],
                exports: [HintComponent, ErrorComponent, FormFieldComponent],
                imports: [CommonModule]
            }]
    }], null, null);
FormFieldModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function FormFieldModule_Factory(t) { return new (t || FormFieldModule)(); }, imports: [[CommonModule]] });;

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Inputs components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Inputs module
 * import { InputsModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, InputsModule], // import Inputs module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let InputsModule = class InputsModule {
}
InputsModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: InputsModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(InputsModule, { imports: function () { return [CommonModule]; }, exports: function () { return [TextAreaModule,
        TextBoxModule,
        SliderModule,
        RangeSliderModule,
        SwitchModule,
        NumericTextBoxModule,
        MaskedTextBoxModule,
        ColorPickerModule,
        CheckBoxModule,
        RadioButtonModule,
        FormFieldModule]; } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(InputsModule, [{
        type: NgModule,
        args: [{
                exports: [
                    TextAreaModule,
                    TextBoxModule,
                    SliderModule,
                    RangeSliderModule,
                    SwitchModule,
                    NumericTextBoxModule,
                    MaskedTextBoxModule,
                    ColorPickerModule,
                    CheckBoxModule,
                    RadioButtonModule,
                    FormFieldModule
                ],
                imports: [CommonModule]
            }]
    }], null, null);
InputsModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function InputsModule_Factory(t) { return new (t || InputsModule)(); }, imports: [[CommonModule]] });;

/**
 * Generated bundle index. Do not edit.
 */

export { CheckBoxModule, ColorInputComponent, ContrastValidationComponent, ContrastComponent, FocusOnDomReadyDirective, ColorGradientLocalizationService, ColorPaletteLocalizationService, ColorPickerLocalizationService, ColorPickerCustomMessagesComponent, ColorPickerMessages, ColorPaletteService, MaskingService, NumericTextBoxMessages, RadioButtonModule, RangeSliderCustomMessagesComponent, RangeSliderMessages, SHARED_DIRECTIVES, SliderCustomMessagesComponent, SliderMessages, SliderBase, SlidersCommonModule, SwitchCustomMessagesComponent, Messages, TextFieldsBase, TextBoxCustomMessagesComponent, TextBoxMessages, SliderComponent, RangeSliderComponent, LabelTemplateDirective, SwitchComponent, TextBoxContainerComponent, TextBoxDirective, TextAreaDirective, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, MaskedTextBoxComponent, InputsModule, SliderTicksComponent, SliderModule, RangeSliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule, TextBoxModule, TextAreaModule, ColorPickerComponent, ColorPaletteComponent, ColorGradientComponent, ColorPickerModule, ActiveColorClickEvent, CheckBoxDirective, RadioButtonDirective, HintComponent, ErrorComponent, FormFieldComponent, FormFieldModule, TextBoxComponent, TextBoxPrefixTemplateDirective, TextBoxSuffixTemplateDirective, TextAreaComponent, TextAreaSuffixComponent, InputSeparatorComponent, SharedModule, LocalizedColorPickerMessagesDirective, LocalizedNumericTextBoxMessagesDirective, LocalizedTextBoxMessagesDirective, LocalizedSliderMessagesDirective, LocalizedRangeSliderMessagesDirective, LocalizedSwitchMessagesDirective };

//# sourceMappingURL=index.js.map